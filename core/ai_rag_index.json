{"version": 1, "model": "", "created_at": 1769292161, "chunks": [{"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "# Отчёт о проделанной работе по проекту Logist2 **Дата последнего обновления:** 24 января 2026 г. --- ## Общее описание задач из промта Основная задача - доработка системы управления контейнерами и ТС: 1. Расширение типов ТС с 2 до 11 2. Пропорциональное распределение THS по типам ТС 3. Возможность указать плательщика THS (линия или склад) 4. Синхронизация данных между контейнером и карточками ТС --- ## ВЫПОЛНЕННАЯ РАБОТА ### 1. Расширение типов транспортных средств **Статус:** Завершено **Файл:** `core/models.py` - модель `Car` Было 2 типа (CAR, MOTO), стало 11: - SEDAN (Легковой), CROSSOVER (Кроссовер), SUV (Джип), PICKUP (Пикап) - NEW_CAR (Новый автомобиль), MOTO (Мотоцикл), BIG_MOTO (Большой мотоцикл) - ATV (Квадроцикл/Багги), BOAT (Лодка), RV (Автодом), CONSTRUCTION (Стр. техника) **Миграция:** `0089_expand_vehicle_types_and_ths_system.py` - Расширен `max_length` поля с 10 до 20 - Записи с `CAR` конвертированы в `SEDAN` --- ### 2. Система коэффициентов THS по типам ТС (обновлено 16.01.2026) **Статус:** Завершено **Модель `LineTHSCoefficient`** в `core/models.py` (ранее LineTHSPercent): - Связана с линией через ForeignKey - Хранит коэффициент (вес) для каждого типа ТС - unique_", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "6.01.2026) **Статус:** Завершено **Модель `LineTHSCoefficient`** в `core/models.py` (ранее LineTHSPercent): - Связана с линией через ForeignKey - Хранит коэффициент (вес) для каждого типа ТС - unique_together: line + vehicle_type - По умолчанию коэффициент = 1.0 **Миграция:** `0093_rename_ths_percent_to_coefficient.py` - Переименована модель LineTHSPercent → LineTHSCoefficient - Переименовано поле percent → coefficient - Данные конвертированы: коэффициент = процент / 25 **Админка:** `LineTHSCoefficientInline` в `LineAdmin` **Логика распределения THS:** - Сумма THS контейнера распределяется пропорционально коэффициентам - Формула: THS_ТС = общий_THS × (коэффициент_ТС / сумма_всех_коэффициентов) - Результат округляется вверх до 5 EUR **Рекомендуемые коэффициенты:** | Тип ТС | Коэффициент | |--------|-------------| | Легковой | 1.0 | | Кроссовер | 1.2 | | Джип/Пикап | 1.5 | | Мотоцикл | 0.3 | | Большой мотоцикл | 0.5 | | Лодка | 2.0 | | Автодом (RV) | 3.0 | | Стр. техника | 2.5 | --- ### 3. Поле \"Оплата THS через\" в контейнере **Статус:** Завершено **Поле `ths_payer`** в модели `Container`: - LINE = услуга THS как service_type='LINE' - WAREHOUSE = услуга THS как service_type='WAREHOUS", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "3. Поле \"Оплата THS через\" в контейнере **Статус:** Завершено **Поле `ths_payer`** в модели `Container`: - LINE = услуга THS как service_type='LINE' - WAREHOUSE = услуга THS как service_type='WAREHOUSE' **Миграция:** `0090_update_ths_payer_labels.py` --- ### 4. Округление THS до 5 EUR **Статус:** Завершено Вспомогательная функция `round_up_to_5()` внутри `calculate_ths_for_container()` в `core/signals.py` Пример: 73.12 EUR -> 75 EUR --- ### 5. Функция создания THS услуг **Статус:** Завершено Функция `create_ths_services_for_container()` в `core/signals.py`: - Рассчитывает пропорциональный THS - Удаляет старые THS-услуги - Создаёт новые с правильным service_type - Применяет округление Вызывается из `ContainerAdmin.save_model()` и `save_formset()` --- ### 6. Упрощение системы цен (16.01.2026) **Статус:** Завершено **Изменения:** - Удалено поле `current_price` из модели `Car` - Оставлено только поле `total_price` (переименовано в \"Цена\") - Цена динамически пересчитывается до статуса \"Передан\" - После передачи цена фиксируется **Миграция:** `0092_remove_current_price.py` --- ### 7. Динамический расчёт услуги \"Хранение\" (16.01.2026) **Статус:** Завершено **Проблема:** Услуга \"Хранение\" ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "дан\" - После передачи цена фиксируется **Миграция:** `0092_remove_current_price.py` --- ### 7. Динамический расчёт услуги \"Хранение\" (16.01.2026) **Статус:** Завершено **Проблема:** Услуга \"Хранение\" добавлялась с фиксированной ценой 5 EUR, даже когда платных дней ещё не было. **Решение:** - Удалено поле `rate` из модели `Warehouse` - Ставка за день теперь берётся из услуги \"Хранение\" в списке услуг склада (`WarehouseService.default_price`) - Цена услуги \"Хранение\" = платные_дни × ставка_за_день - Если платных дней нет - цена = 0 **Миграция:** `0091_remove_warehouse_rate.py` **Изменённые методы в `Car`:** - `update_days_and_storage()` - обновляет дни и вызывает пересчёт цены хранения - `_get_storage_daily_rate()` - получает ставку из услуги \"Хранение\" - `_update_storage_service_price()` - обновляет цену в CarService --- ### 8. Улучшение сводки по услугам (16.01.2026) **Статус:** Завершено **Изменения в `services_summary_display`:** - THS отображается отдельно (вне зависимости от плательщика) - Услуги склада показываются с детализацией (каждая услуга отдельно) - Показываются бесплатные и платные дни - Отображается наценка Caromoto Lithuania --- ### 9. Пересоздание THS при смене скла", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "ьщика) - Услуги склада показываются с детализацией (каждая услуга отдельно) - Показываются бесплатные и платные дни - Отображается наценка Caromoto Lithuania --- ### 9. Пересоздание THS при смене склада (16.01.2026) **Статус:** Завершено **Проблема:** При изменении склада в контейнере с `ths_payer='WAREHOUSE'` услуга THS не обновлялась. **Решение:** Добавлено `'warehouse'` в список отслеживаемых полей в `ContainerAdmin.save_model()` --- ### 10. Кнопка \"Пересчитать THS\" в карточке линии (16.01.2026) **Статус:** Завершено **Функционал:** - В карточке линии появилась кнопка \"↻ Пересчитать THS\" - При нажатии пересчитываются THS-услуги для всех ТС этой линии со статусом \"Разгружен\" или \"В пути\" - После пересчёта THS обновляются итоговые цены ТС **Файлы:** - `templates/admin/line_change.html` - шаблон с кнопкой - `core/admin.py` - метод `recalculate_ths_view()` в `LineAdmin` **Использование:** 1. Изменить коэффициенты THS в карточке линии 2. Сохранить линию 3. Нажать кнопку \"Пересчитать THS\" 4. Дождаться сообщения \"Пересчитано: X контейнеров, Y ТС\" --- ### 11. Исправление кэширования при расчёте цены (16.01.2026) **Статус:** Завершено **Проблема:** После пересчёта THS-услуг цена ТС не об", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": " 4. Дождаться сообщения \"Пересчитано: X контейнеров, Y ТС\" --- ### 11. Исправление кэширования при расчёте цены (16.01.2026) **Статус:** Завершено **Проблема:** После пересчёта THS-услуг цена ТС не обновлялась из-за кэша `_prefetched_objects_cache`. **Решение:** В методе `calculate_total_price()` добавлен сброс кэша перед расчётом: ```python if hasattr(self, '_prefetched_objects_cache'): self._prefetched_objects_cache.pop('car_services', None) ``` --- ### 12. Система скрытой наценки (17.01.2026) **Статус:** Завершено **Цель:** Возможность скрыто распределить наценку (прибыль) по услугам, чтобы она не отображалась отдельной строкой в инвойсе. **Новое поле `markup_amount`** в модели `CarService`: - Скрытая наценка для каждой услуги - Добавляется к цене услуги в инвойсе - Не видна клиенту как отдельная строка **Новое поле `default_markup`** в моделях услуг: - `WarehouseService.default_markup` - наценка по умолчанию для услуг склада - `LineService.default_markup` - наценка по умолчанию для услуг линии - `CarrierService.default_markup` - наценка по умолчанию для услуг перевозчика - При создании CarService наценка копируется из default_markup **Миграции:** - `0094_add_hide_markup_in_fiel", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": " услуг линии - `CarrierService.default_markup` - наценка по умолчанию для услуг перевозчика - При создании CarService наценка копируется из default_markup **Миграции:** - `0094_add_hide_markup_in_field.py` - `0095_add_markup_distribution.py` - `0096_add_default_markup_to_services.py` **Интерфейс в карточке ТС:** - Рядом с каждой услугой появилось жёлтое поле для ввода наценки - Наценка редактируется напрямую в блоках услуг (склад, линия, перевозчик) - Сводка показывает общую сумму наценки **Логика цен:** - `final_price` = базовая цена услуги (без наценки) — для внутреннего учёта - `invoice_price` = базовая цена + наценка — для инвойса клиенту - `total_price` ТС = сумма всех услуг + сумма всех наценок **Особенности для услуги \"Хранение\":** - Наценка умножается на количество платных дней (как и цена) - При `default_markup=1` и 7 платных дней → наценка = 7 EUR **Сводка по услугам (services_summary_display):** - Услуги линий показываются с детализацией (включая THS даже если оплата через склад) - Услуги склада показываются с детализацией (без THS) - Перевозчик отдельно - Скрытая наценка отдельным блоком **Инвойс:** - Наценка НЕ отображается отдельной строкой - Наценка добавляется к цен", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "клад) - Услуги склада показываются с детализацией (без THS) - Перевозчик отдельно - Скрытая наценка отдельным блоком **Инвойс:** - Наценка НЕ отображается отдельной строкой - Наценка добавляется к ценам услуг (только для Company) --- ### 13. Обратная синхронизация статуса контейнера (актуализировано 24.01.2026) **Статус:** Завершено **Функционал:** - Если все ТС контейнера имеют статус `TRANSFERRED`, контейнер автоматически переводится в `TRANSFERRED` - Вызывается в `Car.save()` и в действиях админки **Файлы:** - `core/models.py` — `Container.check_and_update_status_from_cars()`, вызов из `Car.save()` - `core/admin.py` — доп. проверка при массовых действиях ## РЕШЁННЫЕ ПРОБЛЕМЫ | # | Проблема | Причина | Решение | |---|----------|---------|---------| | 1 | THS не рассчитывался по процентам | Старый код в сигнале перезаписывал логику | Отключена секция \"УСЛУГИ ЛИНИИ\" в create_car_services_on_car_save | | 2 | THS записывался как LINE вместо WAREHOUSE | Старая логика игнорировала ths_payer | Логика перенесена в create_ths_services_for_container() | | 3 | THS не создавался при новом контейнере | Функция вызывалась только при change=True | Добавлен вызов в save_formset() после сохранени", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "r | Логика перенесена в create_ths_services_for_container() | | 3 | THS не создавался при новом контейнере | Функция вызывалась только при change=True | Добавлен вызов в save_formset() после сохранения ТС | | 4 | Все услуги линии добавлялись при сохранении ТС | Сигнал update_cars_on_line_service_change | Отключена автоматическая логика добавления | | 5 | Цена на 5 EUR больше при 0 платных дней | Услуга \"Хранение\" создавалась с фиксированной ценой | Цена рассчитывается динамически: дни × ставка | | 6 | Фильтр `icontains` не находил \"Хранение\" | Проблемы с кодировкой в PostgreSQL | Используется точное совпадение `name='Хранение'` | | 7 | Цена в списке ТС отличалась от карточки | Prefetch кэш не обновлялся | Расчёт напрямую из БД в `total_price_display` | | 8 | THS не обновлялся при смене склада | Поле warehouse не отслеживалось | Добавлено в список ths_related_changed | | 9 | Проценты THS неинтуитивны | Трудно понять пропорции | Заменены на коэффициенты (1.0 = стандарт) | | 10 | Нет способа пересчитать THS для существующих ТС | Пересчёт только при изменении контейнера | Кнопка \"Пересчитать THS\" в карточке линии | | 11 | Цена не обновлялась после пересчёта THS | Кэш car_services не сб", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "оба пересчитать THS для существующих ТС | Пересчёт только при изменении контейнера | Кнопка \"Пересчитать THS\" в карточке линии | | 11 | Цена не обновлялась после пересчёта THS | Кэш car_services не сбрасывался | Сброс кэша в calculate_total_price() | | 12 | Кнопка пересчёта отправляла основную форму | Form внутри form | Заменена на ссылку (тег `<a>`) | | 13 | Наценка видна клиенту в инвойсе | Отдельная строка \"Наценка Caromoto\" | Наценка распределяется по услугам скрыто | | 14 | Нельзя редактировать наценку по услугам | Только общее поле proft | Жёлтые поля наценки в каждой услуге | | 15 | Услуги линий не учитывались в сводке | custom_price=None считалось как 0 | Используется final_price с проверкой `is not None` | | 16 | THS через склад не показывался в услугах линий | Фильтр по service_type='LINE' | THS учитывается по имени, независимо от service_type | | 17 | +5 EUR при 0 платных дней | custom_price=0 → False → default_price=5 | Проверка `custom_price is not None` | | 18 | В услугах линий/перевозчиков нет флага \"Добавлять по умолчанию\" | Не было поля add_by_default | Добавлены поля и инлайны для LineService/CarrierService | | 19 | Услуга с add_by_default добавлялась всем существ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": " линий/перевозчиков нет флага \"Добавлять по умолчанию\" | Не было поля add_by_default | Добавлены поля и инлайны для LineService/CarrierService | | 19 | Услуга с add_by_default добавлялась всем существующим ТС | Сигналы создавали CarService для всех ТС | Обновление только существующих связей, автодобавление только для новых | --- ## НЕВЫПОЛНЕННАЯ РАБОТА (согласно промту) - Нет активных задач, влияющих на текущую функциональность. - Отдельный аналитический учёт прибыли (отчёты/сводки) не выделен в отдельный модуль. --- ## ИЗМЕНЁННЫЕ ФАЙЛЫ ### Модели (`core/models.py`) - Типы ТС расширены до 11 - Модель `LineTHSCoefficient` для коэффициентов THS (ранее LineTHSPercent) - Поле `ths_payer` в `Container` - Удалено поле `rate` из `Warehouse` - Удалено поле `current_price` из `Car` - Методы расчёта хранения: `update_days_and_storage()`, `_get_storage_daily_rate()`, `_update_storage_service_price()` - Сброс кэша в `calculate_total_price()` - **Новое:** `CarService.markup_amount` - скрытая наценка для услуги - **Новое:** `CarService.final_price` - цена без наценки (с проверкой `is not None`) - **Новое:** `CarService.invoice_price` - цена с наценкой для инвойса - **Новое:** `WarehouseService.d", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "а для услуги - **Новое:** `CarService.final_price` - цена без наценки (с проверкой `is not None`) - **Новое:** `CarService.invoice_price` - цена с наценкой для инвойса - **Новое:** `WarehouseService.default_markup`, `LineService.default_markup`, `CarrierService.default_markup` - **Новое:** `calculate_total_price()` учитывает markup_amount - **Новое:** `Container.check_and_update_status_from_cars()` + вызов из `Car.save()` - **Новое:** `CompanyService` + тип `COMPANY` в `CarService` - **Новое:** `LineService.add_by_default`, `CarrierService.add_by_default` - **Новое:** `Car.get_company_services()` и учёт `company_total` в расчёте цены ### Админка (`core/admin.py`) - `LineTHSCoefficientInline` в LineAdmin (с полем coefficient вместо percent) - `LineAdmin.recalculate_ths_view()` - кнопка пересчёта THS - `LineAdmin.get_urls()` - кастомный URL для пересчёта - `ContainerAdmin.save_model()` - вызов THS при изменении line/ths/ths_payer/warehouse - `ContainerAdmin.save_formset()` - вызов THS после сохранения ТС - `WarehouseAdmin` - удалено поле rate - `CarAdmin.services_summary_display()` - улучшенная сводка - `CarAdmin.total_price_display()` - динамический расчёт цены - **Новое:** Жёлтые п", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "сле сохранения ТС - `WarehouseAdmin` - удалено поле rate - `CarAdmin.services_summary_display()` - улучшенная сводка - `CarAdmin.total_price_display()` - динамический расчёт цены - **Новое:** Жёлтые поля для ввода наценки рядом с каждой услугой - **Новое:** `save_model()` сохраняет markup_amount для услуг - **Новое:** Сводка показывает услуги линий с детализацией (включая THS через склад) - **Новое:** Сводка показывает общую сумму скрытой наценки - **Новое:** Инлайн `CompanyServiceInline` в `CompanyAdmin` - **Новое:** Блок \"Услуги компании\" в карточке ТС - **Новое:** Всегда показывается кнопка добавления услуг у линий/перевозчиков ### Сигналы (`core/signals.py`) - `calculate_ths_for_container()` - расчёт THS по коэффициентам - `create_ths_services_for_container()` - создание услуг THS - `round_up_to_5()` - округление до 5 EUR - Изменён фильтр \"Хранение\" на точное совпадение - **Новое:** Копирование `default_markup` при создании CarService - **Новое:** Умножение наценки на дни для услуги \"Хранение\" - **Новое:** Услуги компаний добавляются только для новых ТС (Caromoto Lithuania) - **Новое:** Обновление существующих услуг при изменении справочников (без добавления всем) ### Биллинг (", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "и \"Хранение\" - **Новое:** Услуги компаний добавляются только для новых ТС (Caromoto Lithuania) - **Новое:** Обновление существующих услуг при изменении справочников (без добавления всем) ### Биллинг (`core/models_billing.py`) - **Новое:** Наценка НЕ создаётся отдельной строкой в инвойсе - **Новое:** `invoice_price` используется для цены услуги (с наценкой) ### Вьюхи (`core/views.py`) - **Новое:** `add_services()` копирует `default_price` и `default_markup` при добавлении услуги - **Новое:** `get_companies()` и поддержка `company` в get_available_services/add_services ### Шаблоны - `templates/admin/line_change.html` - кнопка \"Пересчитать THS\" - `templates/admin/core/car/change_form.html` - модальное окно \"Услуги компании\" ### Миграции - `0089_expand_vehicle_types_and_ths_system.py` - `0090_update_ths_payer_labels.py` - `0091_remove_warehouse_rate.py` - `0092_remove_current_price.py` - `0093_rename_ths_percent_to_coefficient.py` - переход на коэффициенты - `0094_add_hide_markup_in_field.py` - поле для скрытия наценки - `0095_add_markup_distribution.py` - поле markup_amount в CarService - `0096_add_default_markup_to_services.py` - поле default_markup в услугах - `0099_add_default_flag", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "py` - поле для скрытия наценки - `0095_add_markup_distribution.py` - поле markup_amount в CarService - `0096_add_default_markup_to_services.py` - поле default_markup в услугах - `0099_add_default_flags_line_carrier_services.py` - `0100_add_company_service.py` - `0101_alter_carservice_service_type_and_more.py` --- ## ПРИМЕЧАНИЯ 1. Коэффициенты THS по умолчанию = 1.0 (настраиваются в карточке линии) 2. Для пересчёта существующих ТС - используйте кнопку \"Пересчитать THS\" в карточке линии 3. Ставка хранения берётся из услуги \"Хранение\" в списке услуг склада 4. При добавлении нового склада нужно создать услугу \"Хранение\" с нужной ставкой за день 5. Тестовые контейнеры можно удалить после проверки --- ### 14. Улучшенная система фотографий контейнеров (21.01.2026) **Статус:** Завершено #### Автоматическая синхронизация с Google Drive **Файл:** `core/google_drive_sync.py` **Функционал:** - Автоматический поиск папки контейнера на Google Drive по номеру - Поддержка папок с дополнительным текстом (например \"ECMU5566195 CAROMOTO D\") - Разделение фото по типам: - `IN_CONTAINER` - фото внутри контейнера (папка \"KONTO VIDUS\") - `UNLOADING` - фото после разгрузки (папка \"AUTO IŠ KONTO\") - Автомат", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "м (например \"ECMU5566195 CAROMOTO D\") - Разделение фото по типам: - `IN_CONTAINER` - фото внутри контейнера (папка \"KONTO VIDUS\") - `UNLOADING` - фото после разгрузки (папка \"AUTO IŠ KONTO\") - Автоматическое сохранение ссылки на найденную папку Google Drive **Management команда:** `sync_photos_gdrive` ```bash python manage.py sync_photos_gdrive --no-photos # Только контейнеры без фото (быстрый режим) python manage.py sync_photos_gdrive --recent # Недавние контейнеры python manage.py sync_photos_gdrive --container ECMU5566195 # Конкретный контейнер ``` **Cron задачи (sync_photos_cron.sh):** - Каждые 3 часа - быстрая проверка контейнеров без фото - Раз в сутки в 3:00 - полная проверка недавних контейнеров #### Галерея в админке контейнера **Файлы:** - `templates/admin/core/container/change_form.html` - `templates/admin/core/container/photos_gallery.html` **Функционал:** - Галерея по умолчанию свёрнута (для быстрой загрузки страницы) - Фото загружаются через AJAX только при клике на заголовок - Вкладки \"В контейнере\" и \"Выгруженные\" - Lazy loading миниатюр - Lightbox для просмотра полноразмерных фото - Навигация стрелками клавиатуры **API endpoint:** `GET /core/container/<id>/photos-j", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "овок - Вкладки \"В контейнере\" и \"Выгруженные\" - Lazy loading миниатюр - Lightbox для просмотра полноразмерных фото - Навигация стрелками клавиатуры **API endpoint:** `GET /core/container/<id>/photos-json/` #### Галерея на клиентском сайте **Файл:** `templates/website/home.html` **Функционал:** - Вкладки \"Все\", \"В контейнере\", \"Выгруженные\" - Выбор фото для скачивания - Кнопка \"Скачать выбранные\" (зелёная) - Lightbox с правильной навигацией в рамках текущей вкладки - Улучшенное перетаскивание фото (drag работает при зажатой кнопке мыши) **API endpoint:** `GET /api/container-photos/<container_number>/` - Возвращает `photo_type_code` для фильтрации по вкладкам --- ### 15. Исправления поиска на клиентском сайте (21.01.2026) **Статус:** Завершено **Файл:** `core/views_website.py` - функция `track_shipment` **Исправления:** - Убрано несуществующее поле `current_price` из `ClientCarSerializer` - Добавлена нормализация VIN (убираются пробелы, тире) - Добавлен поиск по частичному совпадению VIN - Улучшенное логирование и обработка ошибок --- ### 16. Исправление URL фотографий на VPS (21.01.2026) **Статус:** Завершено **Проблема:** Фотографии не отображались на VPS сервере (иконка поломанной", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": " - Улучшенное логирование и обработка ошибок --- ### 16. Исправление URL фотографий на VPS (21.01.2026) **Статус:** Завершено **Проблема:** Фотографии не отображались на VPS сервере (иконка поломанной картинки), хотя файлы были загружены. **Причина:** API endpoints возвращали URL без `/media/` префикса (например `/container_photos/...` вместо `/media/container_photos/...`). **Решение:** - Добавлена проверка и добавление `/media/` префикса в `core/views.py` (функция `get_container_photos_json`) - Добавлена проверка и добавление `/media/` префикса в `core/views_website.py` (функция `get_container_photos`) - Исправлены права доступа к media файлам (`chown -R www-root:www-root`) **Код исправления:** ```python # Ensure URLs have /media/ prefix photo_url = photo.photo.url if photo_url and not photo_url.startswith('/media/') and not photo_url.startswith('http'): photo_url = '/media/' + photo_url.lstrip('/') ``` --- ### 17. Улучшение hover-эффекта кнопок на сайте (21.01.2026) **Статус:** Завершено **Проблема:** При наведении на кнопки происходило раздражающее мигание из-за `transform: translateY(-2px)` и конфликтующих `box-shadow`. **Решение:** - Убран `transform: translateY` (приподнимани", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "шено **Проблема:** При наведении на кнопки происходило раздражающее мигание из-за `transform: translateY(-2px)` и конфликтующих `box-shadow`. **Решение:** - Убран `transform: translateY` (приподнимание кнопки) - Убран конфликтующий `box-shadow` - Изменён `transition: all` на `transition: opacity` (убирает перерисовку всех свойств) - Финальный hover-эффект: простое `opacity: 0.85` **Файл:** `core/static/website/css/style.css` **До:** ```css .btn { transition: all 0.3s ease; } .btn:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(0,0,0,.2); } ``` **После:** ```css .btn { transition: opacity 0.2s ease; } .btn:hover { opacity: 0.85; } ``` --- ## ИСТОРИЯ ИЗМЕНЕНИЙ | Дата | Описание | |------|----------| | 14.01.2026 | Первоначальная реализация THS системы | | 16.01.2026 (день) | Упрощение цен, динамический расчёт хранения, исправление отображения | | 16.01.2026 (вечер) | Замена процентов на коэффициенты, кнопка \"Пересчитать THS\", исправление кэша | | 17.01.2026 | Система скрытой наценки: markup_amount, default_markup, распределение по услугам | | 21.01.2026 | Улучшенная система фотографий: автосинхронизация с Google Drive, разделение по типам, галерея с вкладками | | 21.", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "ытой наценки: markup_amount, default_markup, распределение по услугам | | 21.01.2026 | Улучшенная система фотографий: автосинхронизация с Google Drive, разделение по типам, галерея с вкладками | | 21.01.2026 | Исправление URL фотографий на VPS (добавление /media/ префикса) | | 21.01.2026 | Исправление hover-эффекта кнопок (убрано мигание, простой opacity) | | 21.01.2026 | Улучшение Lightbox для мобильных: прозрачные кнопки, скрытие при зуме, touch-жесты | | 23.01.2026 | AI-помощник на сайте и в админке, контекст из БД, ссылки на галерею | | 24.01.2026 | Актуализация статуса: обратная синхронизация контейнера при TRANSFERRED | | 24.01.2026 | Услуги компаний, add_by_default для линий/перевозчиков, исправление автодобавления | --- ### 18. AI-помощник на сайте и в админке (23.01.2026) **Статус:** Завершено **Функционал:** - Подключён AI-помощник с контекстом из БД (VIN/контейнер, статус, склад, даты, фото) - Блокировка финансовых вопросов (цены/оплата/балансы/инвойсы) с направлением к менеджеру - Авто-поиск по VIN/контейнеру и выдача статуса, истории дат и фото - Ссылки на галерею контейнера открываются одной ссылкой без регистрации - В админке добавлен чат-видет **Файлы:** - `core/ser", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "джеру - Авто-поиск по VIN/контейнеру и выдача статуса, истории дат и фото - Ссылки на галерею контейнера открываются одной ссылкой без регистрации - В админке добавлен чат-видет **Файлы:** - `core/services/ai_chat_service.py` — сервис AI, контекст, поиск VIN/контейнера, фото - `core/views_website.py` — AI чат, блок финансов, быстрый ответ по фото, ссылка на галерею - `logist2/settings.py`, `logist2/settings_base.py` — AI настройки из `.env` - `templates/admin/base_site.html` — виджет чата в админке - `core/static/admin/css/ai-chat.css` — стили админ-виджета - `core/static/website/js/ai-chat.js` — CSRF, кликабельные ссылки, fallback-диагностика - `templates/website/home.html` — автозапуск поиска и открытия фото по параметрам `track`/`photos` - `env.example`, `env.local.example` — пример AI настроек **Новая ссылка на галерею:** - `/?track=ECMU5566195&photos=1` — открывает поиск и сразу показывает фото контейнера --- ### 19. Система услуг компаний и унификация услуг поставщиков (24.01.2026) **Статус:** Завершено **Ключевые изменения:** - Добавлены **услуги компаний** (`CompanyService`) и тип `COMPANY` для `CarService` - Компания стала полноценным участником системы услуг (включая доба", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\LOGIST2_PROGRESS_REPORT.md", "content": "6) **Статус:** Завершено **Ключевые изменения:** - Добавлены **услуги компаний** (`CompanyService`) и тип `COMPANY` для `CarService` - Компания стала полноценным участником системы услуг (включая добавление услуг к ТС) - Для услуг линий и перевозчиков добавлен флаг `add_by_default` - Исправлен баг: услуги по умолчанию больше **не добавляются ко всем существующим ТС** - В карточке ТС добавлен блок \"Услуги компании\" с модальным добавлением - Кнопка добавления услуг у линий/перевозчиков показывается всегда (даже если услуг нет) **Файлы:** - `core/models.py` — модель CompanyService, тип `COMPANY`, расчёт totals - `core/admin.py` — инлайны и UI для CompanyService, правки add_by_default - `core/signals.py` — корректная логика add_by_default только для новых ТС - `core/views.py` — поддержка `company` в get_available_services/add_services - `templates/admin/core/car/change_form.html` — модальное окно услуг компании - `logist2/urls.py` — endpoint `GET /api/companies/` **Миграции:** - `0099_add_default_flags_line_carrier_services.py` - `0100_add_company_service.py` - `0101_alter_carservice_service_type_and_more.py`", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "# КОНТЕКСТ ПРОЕКТА LOGIST2 ДЛЯ AI ## О ПРОЕКТЕ **Название:** Logist2 (Caromoto Lithuania) **Тип:** Django-приложение для логистической компании **Основная функция:** Управление контейнерами, ТС, клиентами, складами, инвойсами ### Технологии - **Backend:** Django 5.1.7 + Python 3.10-3.12 - **Database:** PostgreSQL (тесты — SQLite через `settings_test.py`) - **API:** Django REST Framework - **Frontend:** Django templates + Bootstrap 5 + HTMX + кастомный JS - **WebSockets:** Channels + Daphne (Redis в `settings_base.py`, InMemory в `settings.py`) - **Web Server:** Nginx + Gunicorn, статика через WhiteNoise - **Клиентский сайт:** Django templates + REST API ### Основные компоненты - **CRM система** - управление клиентами, балансами - **Логистика** - контейнеры, ТС, склады, линии, перевозчики - **Биллинг** - инвойсы, платежи, балансы - **Клиентский портал** - отслеживание грузов, фотографии - **Google Drive интеграция** - автозагрузка фотографий контейнеров - **Система услуг компаний** - услуги Company (Caromoto Lithuania) как отдельный тип ## VPS СЕРВЕР **IP:** 176.118.198.78 **SSH:** `root@176.118.198.78` **Домен:** https://caromoto-lt.com > ⚠️ **Пароли и секреты** находятся в файле `", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "луги Company (Caromoto Lithuania) как отдельный тип ## VPS СЕРВЕР **IP:** 176.118.198.78 **SSH:** `root@176.118.198.78` **Домен:** https://caromoto-lt.com > ⚠️ **Пароли и секреты** находятся в файле `CREDENTIALS.md` (не в git) ### Расположение ``` Проект: /var/www/www-root/data/www/logist2 Virtualenv: /var/www/www-root/data/www/logist2/.venv Media: /var/www/www-root/data/www/logist2/media Static: /var/www/www-root/data/www/logist2/staticfiles ``` ### Сервисы ```bash # Gunicorn (Django application) systemctl restart gunicorn systemctl status gunicorn # Daphne (WebSockets) systemctl restart daphne systemctl status daphne # Nginx systemctl reload nginx nginx -t ``` ### Nginx конфигурация ``` Файл: /etc/nginx/vhosts/www-root/176.118.198.78.conf location /media/ { alias /var/www/www-root/data/www/logist2/media/; } location /static/ { alias /var/www/www-root/data/www/logist2/staticfiles/; } ``` ## ДЕПЛОЙ ### Способ 1: PowerShell скрипт (с Windows) ```powershell .\\deploy.ps1 ``` ### Способ 2: Git на сервере ```bash ssh root@176.118.198.78 cd /var/www/www-root/data/www/logist2 git pull origin master source .venv/bin/activate python manage.py migrate python manage.py collectstatic --noinput", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": " Git на сервере ```bash ssh root@176.118.198.78 cd /var/www/www-root/data/www/logist2 git pull origin master source .venv/bin/activate python manage.py migrate python manage.py collectstatic --noinput systemctl restart gunicorn systemctl restart daphne ``` ### Что делает deploy.ps1: 1. Копирует файлы через SCP: `core/*`, `logist2/*`, `templates/*` 2. Запускает collectstatic 3. Перезапускает gunicorn и daphne ### ⚠️ ВАЖНО: Что НЕ перезаписывается при деплое: - `.env` файл на сервере (SMTP настройки, пароли БД) — **безопасен** - База данных — **безопасна** - Media файлы (фотографии) — **безопасны** - Nginx конфигурация — **безопасна** ## СТРУКТУРА ПРОЕКТА ``` logist2/ ├── core/ # Основное приложение │ ├── models.py # Основные модели (Container, Car, Client, etc) │ ├── models_website.py # Модели для клиентского сайта │ ├── models_billing.py # Биллинг система │ ├── admin.py # Django Admin конфигурация │ ├── admin_website.py # Admin для клиентского сайта │ ├── views.py # Views для админки │ ├── views_website.py # Views для клиентского сайта │ ├── google_drive_sync.py # Интеграция с Google Drive │ ├── management/commands/ # Management команды │ │ ├── add_performance_indexes.py │ │ ├── ap", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": " ├── views_website.py # Views для клиентского сайта │ ├── google_drive_sync.py # Интеграция с Google Drive │ ├── management/commands/ # Management команды │ │ ├── add_performance_indexes.py │ │ ├── apply_optimizations.py │ │ ├── check_photo_environment.py │ │ ├── cleanup_broken_photos.py │ │ ├── create_default_company.py │ │ ├── fix_photo_names.py │ │ ├── fix_ths_line_services.py │ │ ├── generate_thumbnails.py │ │ ├── init_new_balance_system.py │ │ ├── migrate_services.py │ │ ├── recalculate_car_services.py │ │ ├── recalculate_storage.py │ │ ├── regenerate_thumbnails.py │ │ ├── reset_billing.py │ │ ├── sync_client_balances.py │ │ ├── sync_google_drive_photos.py │ │ ├── sync_photos_gdrive.py │ │ ├── test_invoice_markup.py │ │ ├── test_unload_date_inheritance.py │ │ └── update_container_statuses.py │ ├── services/ # Бизнес-логика │ │ └── ai_chat_service.py # AI-помощник (контекст из БД) │ ├── static/ # Статика для админки │ └── templates/ # Шаблоны админки ├── templates/ # Общие шаблоны │ ├── admin/ # Кастомные админ шаблоны │ └── website/ # Клиентский сайт ├── media/ # Загружаемые файлы │ ├── container_photos/ # Фото контейнеров │ │ └── thumbnails/ # Миниатюры │ ├── container_archiv", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "│ ├── admin/ # Кастомные админ шаблоны │ └── website/ # Клиентский сайт ├── media/ # Загружаемые файлы │ ├── container_photos/ # Фото контейнеров │ │ └── thumbnails/ # Миниатюры │ ├── container_archives/ # ZIP архивы │ └── car_photos/ # Фото ТС ├── logist2/ # Настройки проекта │ ├── settings.py # Локальные настройки (InMemory Channels) │ ├── settings_base.py # Базовые настройки (Redis Channels) │ ├── settings_dev.py # Dev-профиль │ ├── settings_prod.py # Prod-профиль │ ├── settings_test.py # Test-профиль (SQLite) │ ├── urls.py # URL routing │ └── wsgi.py / asgi.py # WSGI/ASGI ├── requirements.txt # Python зависимости └── requirements_website.txt # Доп. зависимости сайта (опционально) ``` ## КЛЮЧЕВЫЕ МОДЕЛИ ### Container (Контейнер) - `number` - номер контейнера (уникальный) - `status` - статус (FLOATING, IN_PORT, UNLOADED, TRANSFERRED) - `line`, `warehouse`, `client` - основные связи - `ths`, `ths_payer` - сумма THS и плательщик (LINE/WAREHOUSE) - `planned_unload_date`, `unload_date`, `eta`, `unloaded_status_at` - ключевые даты - `customs_procedure`, `sklad`, `dekl`, `proft` - дополнительные/legacy поля - `google_drive_folder_url` - ссылка на папку с фотографиями в Google Drive - `", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "`eta`, `unloaded_status_at` - ключевые даты - `customs_procedure`, `sklad`, `dekl`, `proft` - дополнительные/legacy поля - `google_drive_folder_url` - ссылка на папку с фотографиями в Google Drive - `container_cars` - связанные ТС ### Car (ТС) - `vin` - VIN номер (уникальный) - `container` - связь с контейнером (необязательное поле с 20.10.2025) - `client` - клиент-владелец - `warehouse`, `line`, `carrier` - основные связи - `vehicle_type` - тип ТС (11 вариантов) - `status`, `unload_date`, `transfer_date` - статусы и даты - `days`, `storage_cost` - хранение (динамический расчет) - `car_services` - дополнительные услуги от разных складов/линий/перевозчиков ### CarService (Услуга ТС) - `car` - связь с ТС - `service_type` - тип поставщика (WAREHOUSE, LINE, CARRIER, COMPANY) - `service_id` - ID услуги (WarehouseService, LineService, CarrierService, CompanyService) - `custom_price` - индивидуальная цена (если отличается от дефолтной) - `markup_amount` - скрытая наценка (добавляется в инвойсе) - `quantity` - количество услуг - **Позволяет добавлять услуги от ЛЮБЫХ складов к ТС (не только от основного)** ### CompanyService (Услуга компании) - `company` - связь с Company (Caromoto Lithuani", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "е) - `quantity` - количество услуг - **Позволяет добавлять услуги от ЛЮБЫХ складов к ТС (не только от основного)** ### CompanyService (Услуга компании) - `company` - связь с Company (Caromoto Lithuania и др.) - `name`, `description` - название и описание услуги - `default_price`, `default_markup` - цена и наценка по умолчанию - `is_active` - активность - `add_by_default` - добавлять ли услугу автоматически новым ТС компании **Дополнительно:** - `LineService` и `CarrierService` также получили флаг `add_by_default` ### ContainerPhoto (Фотография контейнера) - `container` - связь с контейнером - `photo` - оригинальное фото - `thumbnail` - миниатюра (создается автоматически) - `is_public` - доступно клиенту ### AI-помощник (чат) - Контекст формируется из БД на каждый запрос - Авто-поиск по VIN/контейнеру, статус, склад, даты и фото - Финансовые вопросы (цены/оплаты/балансы/инвойсы) блокируются - Виджет доступен на клиентском сайте и в админке ### NewInvoice (Новый инвойс) - ОСНОВНАЯ СИСТЕМА БИЛЛИНГА - `number` - номер инвойса (генерируется автоматически) - `issuer_*` - кто выставил (может быть Company, Warehouse, Line, Carrier) - `recipient_*` - кому выставлен (может быть Client, Compa", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "А БИЛЛИНГА - `number` - номер инвойса (генерируется автоматически) - `issuer_*` - кто выставил (может быть Company, Warehouse, Line, Carrier) - `recipient_*` - кому выставлен (может быть Client, Company, Warehouse, Line, Carrier) - `cars` - ManyToMany связь с ТС - `items` - позиции инвойса (генерируются автоматически из услуг ТС) - **При изменении ТС инвойс АВТОМАТИЧЕСКИ пересчитывается** через сигнал ### InvoiceItem (Позиция инвойса) - `invoice` - связь с инвойсом - `car` - связь с ТС (опционально) - `description` - описание услуги - `quantity` - количество - `unit_price` - цена за единицу - `total_price` - автоматически рассчитывается (quantity × unit_price) **Как формируются позиции при создании инвойса от Caromoto Lithuania клиенту:** 1. Хранение (только для Company): `{car.days} дней × ставка из услуги \"Хранение\"` + статус `[Передан]` или `[Текущее хранение]` 2. Все услуги складов (от всех складов, не только основного) 3. Все услуги линий 4. Все услуги перевозчиков 5. Скрытая наценка добавляется в цены услуг через `markup_amount` (отдельной строкой не выводится) ## API ENDPOINTS ### Для управления услугами ТС: - `GET /api/warehouses/` - список всех складов - `GET /api/car/<car", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "нка добавляется в цены услуг через `markup_amount` (отдельной строкой не выводится) ## API ENDPOINTS ### Для управления услугами ТС: - `GET /api/warehouses/` - список всех складов - `GET /api/car/<car_id>/get_available_services/?type=warehouse&warehouse_id=<id>` - доступные услуги склада - `GET /api/companies/` - список компаний - `GET /api/car/<car_id>/get_available_services/?type=company&company_id=<id>` - доступные услуги компании - `POST /api/car/<car_id>/add_services/` - добавить услуги к ТС - `GET /core/api/search-counterparties/` - поиск контрагентов для инвойсов - `GET /core/api/search-cars/` - поиск ТС для инвойсов ### Для клиентского портала: - `POST /api/track/` - отслеживание груза по VIN или номеру контейнера - `GET /api/container-photos/<container_number>/` - фотографии контейнера - `POST /api/download-photos-archive/` - скачать архив фотографий - `POST /api/ai-chat/` - AI-помощник (контекст из БД, блок финансовых вопросов) ### Публичная ссылка на галерею: - `/?track=<номер_контейнера>&photos=1` — автоматически запускает поиск и открывает фото ## GOOGLE DRIVE ИНТЕГРАЦИЯ ### Структура папок Google Drive: ``` Главная папка: https://drive.google.com/drive/u/1/folders/1Pk", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "ер_контейнера>&photos=1` — автоматически запускает поиск и открывает фото ## GOOGLE DRIVE ИНТЕГРАЦИЯ ### Структура папок Google Drive: ``` Главная папка: https://drive.google.com/drive/u/1/folders/1PkrfxocilDZjDaT3R1SQ9DflyWBBFNpW ├── AUTO IŠ KONTO (ВЫГРУЖЕННЫЕ) │ └── [месяц]/[номер_контейнера]/[фотографии] │ └── KONTO VIDUS (В КОНТЕЙНЕРЕ) └── [месяц]/[номер_контейнера]/[фотографии] ``` ### Как работает загрузка: 1. В админке контейнера указываем ссылку на папку Google Drive 2. Нажимаем кнопку \"📥 Загрузить фото с Google Drive\" 3. Фотографии скачиваются асинхронно (в фоне) 4. Миниатюры создаются автоматически 5. Через 1-2 минуты обновляем страницу - фотографии появляются ## ПОЛЕЗНЫЕ КОМАНДЫ ### На сервере: ```bash # Подключение ssh root@176.118.198.78 # Переход в проект cd /var/www/www-root/data/www/logist2 source .venv/bin/activate # Проверка окружения для фотографий python manage.py check_photo_environment # Пересоздание миниатюр python manage.py regenerate_thumbnails python manage.py regenerate_thumbnails --force # Удаление битых записей фотографий python manage.py cleanup_broken_photos python manage.py cleanup_broken_photos --delete # Синхронизация с Google Drive (устаревшая ком", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": " regenerate_thumbnails --force # Удаление битых записей фотографий python manage.py cleanup_broken_photos python manage.py cleanup_broken_photos --delete # Синхронизация с Google Drive (устаревшая команда) python manage.py sync_google_drive_photos # Синхронизация фото с Google Drive (НОВАЯ - рекомендуется) python manage.py sync_photos_gdrive --no-photos # Быстрая проверка контейнеров без фото python manage.py sync_photos_gdrive --recent # Недавние контейнеры (14 дней) python manage.py sync_photos_gdrive --container ECMU5566195 # Конкретный контейнер python manage.py sync_photos_gdrive --verbose # С подробным логированием # Исправление прав доступа после загрузки фотографий (ВАЖНО!) ./fix_media_permissions.sh # Проверка логов journalctl -u gunicorn -f journalctl -u daphne -f # Очистка кэша Python find . -type d -name __pycache__ -exec rm -rf {} + 2>/dev/null || true ``` ### Локально: ```powershell # Запуск dev сервера .\\START_ME.bat # Деплой на VPS .\\deploy.ps1 # Миграции python manage.py makemigrations python manage.py migrate ``` ## EMAIL УВЕДОМЛЕНИЯ КЛИЕНТАМ (Декабрь 2025) ### Функционал: - **Уведомления о планируемой разгрузке** — отправляются автоматически при указании даты в п", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "py makemigrations python manage.py migrate ``` ## EMAIL УВЕДОМЛЕНИЯ КЛИЕНТАМ (Декабрь 2025) ### Функционал: - **Уведомления о планируемой разгрузке** — отправляются автоматически при указании даты в поле \"Будем разгружать\" - **Уведомления о фактической разгрузке** — отправляются автоматически при указании даты разгрузки - Письма отправляются только клиентам, чьи ТС находятся в контейнере - В письме указаны конкретные ТС клиента (VIN, марка, год) - Защита от повторной отправки (через NotificationLog) ### Новые поля в моделях: **Client (core/models.py):** - `email` — Email для уведомлений - `notification_enabled` — Флаг получения уведомлений (по умолчанию True) **Container (core/models.py):** - `planned_unload_date` — \"Будем разгружать\" (при установке отправляется уведомление) **NotificationLog (core/models_website.py):** - Логирование всех отправленных уведомлений - Типы: PLANNED (планируемая разгрузка), UNLOADED (фактическая разгрузка) - Хранит: контейнер, клиент, email, список ТС, статус отправки, ошибки ### Файлы: ``` core/services/email_service.py # Сервис отправки уведомлений core/signals.py # Сигналы для автоматической отправки templates/email/planned_notification.html # Шабло", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "тус отправки, ошибки ### Файлы: ``` core/services/email_service.py # Сервис отправки уведомлений core/signals.py # Сигналы для автоматической отправки templates/email/planned_notification.html # Шаблон планируемой разгрузки templates/email/unload_notification.html # Шаблон фактической разгрузки ``` ### SMTP настройки (на сервере в .env) — через Brevo: ``` EMAIL_BACKEND=django.core.mail.backends.smtp.EmailBackend EMAIL_HOST=smtp-relay.brevo.com EMAIL_PORT=587 EMAIL_USE_TLS=True # Пароли в файле CREDENTIALS.md ``` ### Контактные данные в письмах (settings_base.py): ``` COMPANY_NAME = 'Caromoto Lithuania' COMPANY_PHONE = '+37068830450' COMPANY_EMAIL = 'lithuania@caromoto.com' COMPANY_WEBSITE = 'https://caromoto-lt.com' ``` ### Brevo (бывший Sendinblue): - **Аккаунт:** Caromoto Lithuania - **Бесплатно:** 300 писем/день - **Домен:** caromoto-lt.com ✅ **Authenticated** - **DNS записи добавлены в Hostika.LT** (регистратор домена): - TXT: `brevo-code:6113c7d9b16365464c534b6bff2e13b6` - CNAME: `brevo1._domainkey` → `b1.caromoto-lt-com.dkim.brevo.com` - CNAME: `brevo2._domainkey` → `b2.caromoto-lt-com.dkim.brevo.com` - TXT: `_dmarc` → `v=DMARC1; p=none; rua=mailto:rua@dmarc.brevo.com` - **Па", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "`brevo1._domainkey` → `b1.caromoto-lt-com.dkim.brevo.com` - CNAME: `brevo2._domainkey` → `b2.caromoto-lt-com.dkim.brevo.com` - TXT: `_dmarc` → `v=DMARC1; p=none; rua=mailto:rua@dmarc.brevo.com` - **Панель управления:** https://app.brevo.com - **Также поддерживает:** SMS-уведомления (платно, ~0.05-0.08€/SMS) ### Админ-действия для контейнеров: - **📧 Повторить уведомление о планируемой разгрузке** — ручная отправка - **📧 Повторить уведомление о разгрузке** — ручная отправка ### Статус настройки (декабрь 2025): - ✅ Перешли на Brevo (бывший Sendinblue) для надёжной доставки - ✅ SMTP настроен через smtp-relay.brevo.com - ✅ DNS записи добавлены в Hostika.LT (DKIM, DMARC, Brevo code) - ✅ Домен caromoto-lt.com аутентифицирован в Brevo - ✅ Gmail и другие почтовые сервисы работают ### Как добавить клиенту email: 1. Админка → Клиенты → выбрать клиента 2. В разделе \"Основная информация\" указать Email и включить \"Получать уведомления\" --- ## ТЕКУЩЕЕ СОСТОЯНИЕ ### Что работает: ✅ Основная CRM система ✅ Управление контейнерами и ТС ✅ Биллинг и балансы ✅ Клиентский портал ✅ Google Drive интеграция (загрузка фотографий) ✅ Автоматическое создание миниатюр ✅ Email уведомления клиентам (через Brevo SM", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "а ✅ Управление контейнерами и ТС ✅ Биллинг и балансы ✅ Клиентский портал ✅ Google Drive интеграция (загрузка фотографий) ✅ Автоматическое создание миниатюр ✅ Email уведомления клиентам (через Brevo SMTP) ### Известные проблемы: ⚠️ SSH connection timeout при длительных операциях ⚠️ Миниатюры могут не отображаться если nginx конфигурация неправильная ⚠️ Асинхронная загрузка из Google Drive - нужно ждать 1-2 минуты ⚠️ **ВАЖНО:** После загрузки фотографий вручную (через команды от root) нужно исправить права доступа: `./fix_media_permissions.sh` ### Недавние изменения (январь 2026): **21.01.2026 - Улучшенная система фотографий контейнеров:** 1. **АВТОМАТИЧЕСКАЯ СИНХРОНИЗАЦИЯ С GOOGLE DRIVE:** ⭐ НОВЫЙ ФУНКЦИОНАЛ - ✅ Автоматический поиск папки контейнера на Google Drive по номеру - ✅ Поддержка папок с дополнительным текстом в названии - ✅ Разделение фото по типам: IN_CONTAINER (в контейнере) и UNLOADING (выгруженные) - ✅ Автоматическое сохранение ссылки на найденную папку Google Drive - ✅ Management команда `sync_photos_gdrive` с режимами: --no-photos, --recent, --container - ✅ Cron задачи для периодической синхронизации 2. **ГАЛЕРЕЯ В АДМИНКЕ КОНТЕЙНЕРА:** - ✅ Свёрнутая по умолчанию гал", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "nagement команда `sync_photos_gdrive` с режимами: --no-photos, --recent, --container - ✅ Cron задачи для периодической синхронизации 2. **ГАЛЕРЕЯ В АДМИНКЕ КОНТЕЙНЕРА:** - ✅ Свёрнутая по умолчанию галерея (быстрая загрузка страницы) - ✅ AJAX загрузка фото при клике на заголовок - ✅ Вкладки \"В контейнере\" и \"Выгруженные\" - ✅ Lazy loading миниатюр - ✅ Lightbox с навигацией 3. **ГАЛЕРЕЯ НА КЛИЕНТСКОМ САЙТЕ:** - ✅ Вкладки \"Все\", \"В контейнере\", \"Выгруженные\" - ✅ Выбор фото для скачивания - ✅ Кнопка \"Скачать выбранные\" (зелёная) - ✅ Lightbox с правильной навигацией в рамках текущей вкладки - ✅ Улучшенное перетаскивание (drag при зажатой кнопке мыши) 4. **ИСПРАВЛЕНИЯ ПОИСКА:** - ✅ Убрано несуществующее поле `current_price` из сериализатора - ✅ Нормализация VIN при поиске - ✅ Поиск по частичному совпадению VIN 5. **ИСПРАВЛЕНИЕ URL ФОТОГРАФИЙ НА VPS:** - ✅ Фото не отображались на сервере (иконка поломанной картинки) - ✅ Причина: API возвращал URL без `/media/` префикса - ✅ Решение: добавлена проверка и добавление `/media/` в `views.py` и `views_website.py` - ✅ Исправлены права доступа к media файлам (`chown -R www-root:www-root`) 6. **ИСПРАВЛЕНИЕ HOVER-ЭФФЕКТА КНОПОК:** - ✅ Убрано мигание ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "роверка и добавление `/media/` в `views.py` и `views_website.py` - ✅ Исправлены права доступа к media файлам (`chown -R www-root:www-root`) 6. **ИСПРАВЛЕНИЕ HOVER-ЭФФЕКТА КНОПОК:** - ✅ Убрано мигание при наведении на кнопки - ✅ Заменён `transition: all` на `transition: opacity` (убирает перерисовку) - ✅ Финальный hover-эффект: простой `opacity: 0.85` - ✅ Файл: `core/static/website/css/style.css` 7. **УЛУЧШЕНИЕ LIGHTBOX ДЛЯ МОБИЛЬНЫХ УСТРОЙСТВ:** - ✅ Кнопки навигации стали полупрозрачными (35% вместо 90%) - ✅ Кнопки скрываются при зуме > 1, появляются при сбросе зума - ✅ Добавлен pinch-to-zoom (увеличение двумя пальцами) - ✅ Добавлен свайп влево/вправо для перелистывания фото - ✅ Добавлено панорамирование одним пальцем при зуме - ✅ Файл: `templates/website/home.html` **Файлы изменены:** - `core/google_drive_sync.py` - автопоиск папок, разделение по типам - `core/management/commands/sync_photos_gdrive.py` - новые режимы - `core/views.py` - API endpoint для AJAX загрузки фото - `core/views_website.py` - улучшенный поиск, API для клиентских фото - `core/serializers_website.py` - удалено поле current_price - `templates/admin/core/container/change_form.html` - кнопка синхронизации - `tem", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "s_website.py` - улучшенный поиск, API для клиентских фото - `core/serializers_website.py` - удалено поле current_price - `templates/admin/core/container/change_form.html` - кнопка синхронизации - `templates/admin/core/container/photos_gallery.html` - AJAX галерея с вкладками - `templates/website/home.html` - клиентская галерея с вкладками и lightbox - `sync_photos_cron.sh` - cron скрипт для автосинхронизации - `core/static/website/css/style.css` - исправлен hover-эффект кнопок (убрано мигание) **23.01.2026 - AI-помощник на сайте и в админке:** 1. **AI-ЧАТ:** подключён чат на клиентском сайте и в админке 2. **КОНТЕКСТ ИЗ БД:** VIN/контейнер, статус, склад, даты и фото 3. **ОГРАНИЧЕНИЕ ФИНАНСОВ:** вопросы про цены/оплату/балансы блокируются 4. **ГАЛЕРЕЯ ФОТО:** ссылка вида `/?track=<номер>&photos=1` открывает фото **Файлы изменены:** - `core/services/ai_chat_service.py` — сервис AI - `core/views_website.py` — endpoint AI и логика фото/галереи - `core/static/website/js/ai-chat.js` — CSRF и кликабельные ссылки - `templates/admin/base_site.html` — виджет чата в админке - `core/static/admin/css/ai-chat.css` — стили админ-виджета - `logist2/settings.py`, `logist2/settings_base.py` — AI на", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "и кликабельные ссылки - `templates/admin/base_site.html` — виджет чата в админке - `core/static/admin/css/ai-chat.css` — стили админ-виджета - `logist2/settings.py`, `logist2/settings_base.py` — AI настройки - `env.example`, `env.local.example` — примеры AI переменных --- ### Недавние изменения (декабрь 2025): **13.12.2025 - Email уведомления клиентам:** 1. **УВЕДОМЛЕНИЯ О РАЗГРУЗКЕ КОНТЕЙНЕРОВ:** ⭐ НОВЫЙ ФУНКЦИОНАЛ - ✅ Автоматическая отправка уведомлений при указании планируемой даты разгрузки - ✅ Автоматическая отправка уведомлений при указании фактической даты разгрузки - ✅ Письма отправляются только клиентам с ТС в контейнере - ✅ В письме указаны конкретные ТС клиента (VIN, марка, год) - ✅ Логирование всех уведомлений в NotificationLog - ✅ Защита от повторной отправки - ✅ Админ-действия для ручной повторной отправки 2. **НОВЫЕ МОДЕЛИ И ПОЛЯ:** - `Client.email` — email для уведомлений - `Client.notification_enabled` — флаг получения уведомлений - `Container.planned_unload_date` — \"Будем разгружать\" - `NotificationLog` — журнал отправленных уведомлений 3. **SMTP НАСТРОЙКА (через Brevo):** - ~~Локальный почтовый сервер~~ → перешли на **Brevo** (бывший Sendinblue) - Причина: Gmail ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "удем разгружать\" - `NotificationLog` — журнал отправленных уведомлений 3. **SMTP НАСТРОЙКА (через Brevo):** - ~~Локальный почтовый сервер~~ → перешли на **Brevo** (бывший Sendinblue) - Причина: Gmail отклонял письма без PTR записи - Brevo обеспечивает надёжную доставку (95-99%) - Бесплатно: 300 писем/день - DNS записи для DKIM/DMARC добавлены в ISPmanager - ⏳ Ожидает аутентификации домена в Brevo **Файлы изменены:** - `core/models.py` — новые поля Client и Container - `core/models_website.py` — модель NotificationLog - `core/services/email_service.py` — сервис отправки (новый файл) - `core/signals.py` — сигналы для автоматической отправки - `core/admin.py` — админ-действия и отображение полей - `core/admin_website.py` — админка NotificationLog - `logist2/settings_base.py` — настройки email - `templates/email/planned_notification.html` — шаблон (новый) - `templates/email/unload_notification.html` — шаблон (новый) --- ### Предыдущие изменения (октябрь 2025): **21.10.2025 - Комплексное улучшение системы:** 1. **НАСЛЕДОВАНИЕ ДАТЫ РАЗГРУЗКИ КОНТЕЙНЕРА:** ⭐ КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ - ✅ **ПРОБЛЕМА РЕШЕНА:** Дата разгрузки контейнера теперь ВСЕГДА наследуется всеми ТС - Добавлена логика в с", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "учшение системы:** 1. **НАСЛЕДОВАНИЕ ДАТЫ РАЗГРУЗКИ КОНТЕЙНЕРА:** ⭐ КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ - ✅ **ПРОБЛЕМА РЕШЕНА:** Дата разгрузки контейнера теперь ВСЕГДА наследуется всеми ТС - Добавлена логика в сигнал `post_save` для Container - работает при ЛЮБОМ способе сохранения - Раскомментирован и улучшен код в `ContainerAdmin.save_model()` для админки - Убрано условие `if not car.unload_date:` - теперь обновляются ВСЕ ТС принудительно - Улучшены методы `Container.sync_cars_after_warehouse_change()` и `sync_cars_after_edit()` - Исправлен метод `Car.save()` - дата разгрузки ВСЕГДА берется из контейнера - Улучшен метод `ContainerAdmin.save_formset()` - новые ТС всегда получают дату контейнера - Добавлена тестовая команда `test_unload_date_inheritance` для проверки функциональности - ✅ **РЕЗУЛЬТАТ:** При указании или изменении даты разгрузки контейнера все ТС в нём автоматически получают эту дату 2. **ОПТИМИЗАЦИЯ ПРОИЗВОДИТЕЛЬНОСТИ:** ⚡ - Использован `bulk_update()` вместо сохранения ТС в цикле (одним SQL запросом) - Временное отключение сигналов при массовом обновлении для ускорения операции - Массовое обновление инвойсов после обновления всех ТС (вместо обновления после каждого) - Добавле", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": " (одним SQL запросом) - Временное отключение сигналов при массовом обновлении для ускорения операции - Массовое обновление инвойсов после обновления всех ТС (вместо обновления после каждого) - Добавлен `select_related('warehouse')` для оптимизации запросов к БД - ✅ **РЕЗУЛЬТАТ:** Обновление даты разгрузки контейнера с 20+ ТС теперь выполняется в 10-20 раз быстрее 3. **ИСПРАВЛЕНИЕ НАЦЕНКИ В ИНВОЙСАХ:** - ✅ Добавлено автоматическое присвоение Caromoto Lithuania как выставителя в `NewInvoiceAdmin.save_model()` - ✅ Улучшено логирование для отслеживания добавления наценки - Добавлена тестовая команда `test_invoice_markup` для проверки наценки - ✅ **РЕЗУЛЬТАТ:** Наценка Caromoto Lithuania корректно добавляется как отдельная позиция в инвойсы 4. **УЛУЧШЕНИЯ ИНТЕРФЕЙСА АДМИНКИ:** - ✅ Удален столбец \"Перевозчик\" из списка ТС (не нужная информация) - ✅ Добавлено действие \"Передан сегодня\" в меню Actions для ТС - Массовая установка статуса \"Передан\" с текущей датой - Работает для множественного выбора ТС - ✅ Удален фильтр по перевозчику из списка ТС 5. **ТЕСТОВЫЕ КОМАНДЫ:** - `python manage.py test_unload_date_inheritance` - проверка наследования даты разгрузки - `python manage.py test_invoic", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "ыбора ТС - ✅ Удален фильтр по перевозчику из списка ТС 5. **ТЕСТОВЫЕ КОМАНДЫ:** - `python manage.py test_unload_date_inheritance` - проверка наследования даты разгрузки - `python manage.py test_invoice_markup` - проверка добавления наценки в инвойсы **Файлы изменены:** - `core/admin.py` - оптимизация обновления контейнера, новое действие \"Передан сегодня\" - `core/models.py` - принудительное наследование даты разгрузки - `core/signals.py` - массовое обновление ТС при изменении контейнера - `core/admin_billing.py` - автоматическое присвоение Caromoto Lithuania - `core/models_billing.py` - улучшенное логирование наценки **20.10.2025 - Синхронизация БД, услуги складов и автоматический пересчет инвойсов:** 1. **СИНХРОНИЗАЦИЯ БД:** - ✅ Реализована синхронизация production БД на локальный компьютер через `pg_dump`/`pg_restore` - ✅ Команды для создания бэкапа, скачивания и восстановления 2. **УСЛУГИ СКЛАДОВ:** - ✅ Добавлена возможность добавлять услуги от разных складов к одному ТС - Изменен `get_warehouse_services()` для получения услуг от всех складов - Добавлен API endpoint `/api/warehouses/` для выбора склада - Обновлено отображение с указанием названия склада (основной - зеленый, друг", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "get_warehouse_services()` для получения услуг от всех складов - Добавлен API endpoint `/api/warehouses/` для выбора склада - Обновлено отображение с указанием названия склада (основной - зеленый, другие - желтый) - Все услуги от всех складов суммируются в общую стоимость 3. **АВТОМАТИЧЕСКИЙ ПЕРЕСЧЕТ ИНВОЙСОВ:** ⭐ КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ - ✅ **Исправлен сигнал** `update_related_on_car_save` - убран `return` который блокировал обновление NewInvoice - ✅ **Автоматическое обновление инвойсов** при изменении любых данных ТС: - Изменение количества дней хранения - Добавление/удаление даты передачи - Изменение статуса - Добавление/изменение/удаление услуг - ✅ **Наценка автоматически добавляется** в инвойс как отдельная позиция - ✅ **Хранение пересчитывается** автоматически перед генерацией позиций - ✅ **Статус в описании:** `[Передан ДАТА]` или `[Текущее хранение на ДАТА]` - ✅ Защита от рекурсии при обновлении 4. **ДРУГИЕ ИСПРАВЛЕНИЯ:** - ✅ **ПОЛЕ CONTAINER:** Сделано необязательным в модели Car (миграция 0080) - ✅ **ФОНОВЫЕ ИЗОБРАЖЕНИЯ:** Исправлена проблема с отсутствующим фоном на главной странице сайта - Скопированы изображения в `core/static/website/images/` - Добавлены `hero-backgrou", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "ar (миграция 0080) - ✅ **ФОНОВЫЕ ИЗОБРАЖЕНИЯ:** Исправлена проблема с отсутствующим фоном на главной странице сайта - Скопированы изображения в `core/static/website/images/` - Добавлены `hero-background.jpg` и `caromoto_logo.png` **Предыдущие изменения:** - Исправлена логика создания миниатюр контейнеров - Добавлена интеграция с Google Drive - Улучшена админка фотографий контейнеров - Добавлены команды для диагностики и восстановления - **ИСПРАВЛЕНО:** Проблема с отображением миниатюр на VPS (права доступа) - Добавлен скрипт `fix_media_permissions.sh` для автоматического исправления прав - **ИСПРАВЛЕНО:** Проблема с именами файлов при загрузке с Google Drive (суффиксы) - Добавлена команда `fix_photo_names` для исправления старых записей ## 🔴 АКТИВНЫЕ ПРОБЛЕМЫ (20.10.2025) ### ⚠️ НЕРЕШЕННАЯ ПРОБЛЕМА: Отображение миниатюр в Django админке на VPS **Описание проблемы:** - Фотографии загружаются корректно на сервер - Файлы существуют и доступны через Nginx - В Python коде Django генерирует правильные URL с `/media/` префиксом - В методе `image_preview` используется `_safe_media_url` для корректировки путей - **НО в HTML админки браузера отображаются неправильные ссылки** (`/container_ph", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "правильные URL с `/media/` префиксом - В методе `image_preview` используется `_safe_media_url` для корректировки путей - **НО в HTML админки браузера отображаются неправильные ссылки** (`/container_photos/...` без `/media/`) **Что было испробовано:** 1. ✅ Исправлены права доступа файлов (`chown www-data:www-data`) 2. ✅ Убран кастомный `CustomFileSystemStorage` из `settings.py` 3. ✅ Убраны дублирующие настройки `MEDIA_URL`/`MEDIA_ROOT` 4. ✅ Добавлен метод `_safe_media_url()` в `ContainerPhotoAdmin` 5. ✅ Убрана ручная коррекция URL в методе `save()` модели `ContainerPhoto` 6. ✅ Убран несуществующий импорт `MediaFileInput` widget 7. ✅ Выполнены команды: `regenerate_thumbnails`, `fix_photo_names`, `cleanup_broken_photos` **Диагностика показала:** ```python # Python код генерирует ПРАВИЛЬНЫЕ URL: obj.thumbnail.url -> '/media/container_photos/2025/10/19/thumb_IMG_20251015_101923806.jpg' image_preview(obj) -> '<img src=\"/media/container_photos/...\" />' # НО в HTML браузера: <img src=\"/container_photos/2025/10/19/thumb_IMG_20251015_101923806.jpg\" /> ``` **Вывод:** - Проблема НЕ в Python коде Django (он генерирует правильные URL) - Проблема где-то на уровне рендеринга HTML или клиент-сайда ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "er_photos/2025/10/19/thumb_IMG_20251015_101923806.jpg\" /> ``` **Вывод:** - Проблема НЕ в Python коде Django (он генерирует правильные URL) - Проблема где-то на уровне рендеринга HTML или клиент-сайда - Возможно: JavaScript, кастомные admin templates, или неизвестная middleware - Требует дальнейшего исследования **Файлы, которые были изменены для фотографий:** - `logist2/settings.py` - убраны дубликаты и кастомный storage - `core/admin_website.py` - добавлен `_safe_media_url()`, убран несуществующий import - `core/models_website.py` - убрана ручная коррекция URL в `save()` **Файлы, которые были изменены для инвойсов:** - `core/signals.py` - исправлен `update_related_on_car_save`, добавлена обработка NewInvoice - `core/models_billing.py` - добавлена наценка в позиции, автопересчет хранения - `core/models.py` - `get_warehouse_services()` получает услуги от всех складов ## ВАЖНЫЕ НАСТРОЙКИ ### База данных PostgreSQL ``` DB_NAME=logist2_db DB_USER=arturas DB_HOST=localhost DB_PORT=5432 # Пароль в файле CREDENTIALS.md ``` ### Django Superuser (админка) ``` Username: arturas URL: https://caromoto-lt.com/admin/ # Пароль в файле CREDENTIALS.md ``` ### Пользователь веб-сервера ``` Nginx: www", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "роль в файле CREDENTIALS.md ``` ### Django Superuser (админка) ``` Username: arturas URL: https://caromoto-lt.com/admin/ # Пароль в файле CREDENTIALS.md ``` ### Пользователь веб-сервера ``` Nginx: www-data или www-root Gunicorn: www-root ``` ### AI чат (в `.env`) ``` AI_CHAT_ENABLED=True AI_API_KEY=... AI_API_BASE_URL=https://api.openai.com/v1 AI_MODEL=gpt-4o-mini AI_MAX_TOKENS=400 AI_TEMPERATURE=0.2 AI_REQUEST_TIMEOUT=40 ``` ### Права на файлы ```bash # Media файлы chown -R www-root:www-root media/ chmod -R 755 media/ # Для загрузки chmod -R 775 media/container_photos/ chmod -R 775 media/container_archives/ ``` ## ⚠️ POWERSHELL ОГРАНИЧЕНИЯ (ВАЖНО!) При выполнении команд через Shell tool на Windows помни: ### НЕ РАБОТАЕТ в PowerShell: - `&&` — используй `;` или отдельные команды - `cd path && command` — используй `Set-Location` или полные пути - Вложенные кавычки `\"...'...'...\"` — проблемы с экранированием - Кириллица в аргументах через SSH — кодировка ломается - Многострочные heredoc `<< EOF` — не работает - `$variable` без экранирования — PowerShell интерпретирует как свою переменную ### ПРАВИЛЬНЫЕ ПОДХОДЫ: **Для SSH команд:** ```powershell # ПЛОХО: ssh root@server \"cd /path && p", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "`<< EOF` — не работает - `$variable` без экранирования — PowerShell интерпретирует как свою переменную ### ПРАВИЛЬНЫЕ ПОДХОДЫ: **Для SSH команд:** ```powershell # ПЛОХО: ssh root@server \"cd /path && python script.py\" # ХОРОШО (простые команды): ssh root@server \"systemctl restart gunicorn\" ssh root@server \"python manage.py migrate\" # ХОРОШО (с путём): ssh root@server \"cd /var/www/www-root/data/www/logist2; source .venv/bin/activate; python manage.py migrate\" ``` **Для локальных команд:** ```powershell # ПЛОХО: cd c:\\project && python manage.py runserver # ХОРОШО: c:\\project\\.venv\\Scripts\\python.exe c:\\project\\manage.py runserver ``` **Для сложных операций:** - Используй `deploy.ps1` скрипт - Или выполняй команды по одной - Избегай кириллицы в аргументах — лучше создай скрипт на сервере ### SSH + Python shell: ```powershell # ПЛОХО (кавычки): ssh root@server \"python -c 'from models import X; print(X.objects.all())'\" # ХОРОШО (простая проверка): ssh root@server \"cd /path; source .venv/bin/activate; python manage.py showmigrations\" ``` --- ## ПАМЯТКА ДЛЯ AI 1. **Не создавай документацию** если пользователь не просит 2. **Сразу деплой** - измени код и задеплой через git push 3. **SSH не", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "/activate; python manage.py showmigrations\" ``` --- ## ПАМЯТКА ДЛЯ AI 1. **Не создавай документацию** если пользователь не просит 2. **Сразу деплой** - измени код и задеплой через git push 3. **SSH нестабилен** - если timeout, попробуй еще раз через минуту 4. **Главная компания** - Caromoto Lithuania (все процессы привязаны к ней) 5. **После изменений** - всегда перезапускай gunicorn и daphne 6. **Очищай __pycache__** после изменений в коде 7. **Синхронизация БД** - используй pg_dump/pg_restore для синхронизации с production 8. **Услуги складов** - можно добавлять от любых складов через CarService (не только от основного) 9. **Инвойсы обновляются автоматически** - при изменении Car сигнал пересчитывает все связанные NewInvoice 10. **Тестирование сигналов** - если сигнал не работает локально, проверь что нет `return` который прерывает выполнение 11. **Email уведомления** - отправляются автоматически через сигналы при изменении planned_unload_date или unload_date контейнера 12. **SMTP настройки** - хранятся в .env на сервере (НЕ перезаписываются при деплое) 13. **Brevo для email** - используется smtp-relay.brevo.com для надёжной доставки (бесплатно 300 писем/день) 14. **SMS через Bre", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "стройки** - хранятся в .env на сервере (НЕ перезаписываются при деплое) 13. **Brevo для email** - используется smtp-relay.brevo.com для надёжной доставки (бесплатно 300 писем/день) 14. **SMS через Brevo** - возможно добавить в будущем (платно, требует поле phone в Client) ## БЫСТРЫЕ КОМАНДЫ ### На сервере (Linux/Bash): ```bash # Полный деплой с сервера cd /var/www/www-root/data/www/logist2 && git pull && source .venv/bin/activate && python manage.py migrate && python manage.py collectstatic --noinput && find . -type d -name __pycache__ -delete && systemctl restart gunicorn && systemctl restart daphne # Проверка статуса systemctl is-active gunicorn daphne nginx # Логи последние journalctl -u gunicorn -n 50 --no-pager # Проверка фотографий python manage.py check_photo_environment python manage.py regenerate_thumbnails # Исправление прав доступа к media файлам (после загрузки фотографий) ./fix_media_permissions.sh # Создание бэкапа базы данных cd /var/www/www-root/data/www/logist2 PGPASSWORD='YOUR_DB_PASSWORD' pg_dump -U arturas -h localhost -d logist2_db -F c -b -f logist2_backup_$(date +%Y%m%d).dump # Проверка логов email (через Brevo) journalctl -u gunicorn --since '10 minutes ago'", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": "ORD='YOUR_DB_PASSWORD' pg_dump -U arturas -h localhost -d logist2_db -F c -b -f logist2_backup_$(date +%Y%m%d).dump # Проверка логов email (через Brevo) journalctl -u gunicorn --since '10 minutes ago' --no-pager | grep -i email # Проверка SMTP настроек grep EMAIL /var/www/www-root/data/www/logist2/.env # Статистика отправки - в панели Brevo: https://app.brevo.com ``` ### На локальном компьютере (PowerShell): ```powershell # Синхронизация базы данных с сервера на локальный компьютер # Шаг 1: Создать дамп на сервере ssh root@176.118.198.78 \"cd /var/www/www-root/data/www/logist2 && PGPASSWORD='YOUR_DB_PASSWORD' pg_dump -U arturas -h localhost -d logist2_db -F c -b -f logist2_sync_backup.dump\" # Шаг 2: Скачать дамп scp root@176.118.198.78:/var/www/www-root/data/www/logist2/logist2_sync_backup.dump . # Шаг 3: Восстановить локально $env:PGPASSWORD='YOUR_DB_PASSWORD'; pg_restore -U arturas -h localhost -d logist2_db --clean --if-exists logist2_sync_backup.dump # Проверка количества записей .\\.venv\\Scripts\\activate.ps1 py manage.py shell -c \"from core.models import Car, Client, Container; print(f'Cars: {Car.objects.count()}'); print(f'Clients: {Client.objects.count()}'); print(f'Containers", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\AI_PROJECT_CONTEXT.md", "content": ".venv\\Scripts\\activate.ps1 py manage.py shell -c \"from core.models import Car, Client, Container; print(f'Cars: {Car.objects.count()}'); print(f'Clients: {Client.objects.count()}'); print(f'Containers: {Container.objects.count()}')\" ``` ## РЕПОЗИТОРИЙ **GitHub:** https://github.com/Arturas7777/logist2.git **Branch:** master --- **Используй этот контекст в начале каждого диалога для быстрого старта работы над проектом.**", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "# ПОЛНОЕ ОПИСАНИЕ ПРОЕКТА LOGIST2 **Версия документа:** 24 января 2026 **Назначение:** Описание функционала для работы с AI-ассистентами --- ## 📋 ОБЩАЯ ИНФОРМАЦИЯ **Название проекта:** Logist2 (Caromoto Lithuania) **Тип:** Django-приложение для логистической компании **Основная функция:** Управление морскими контейнерами, ТС, складами, клиентами, инвойсами ### Технологический стек | Компонент | Технология | |-----------|------------| | Backend | Django 5.1.7, Python 3.10-3.12 | | API | Django REST Framework | | База данных | PostgreSQL (тесты — SQLite в `settings_test.py`) | | Web-сервер | Nginx + Gunicorn, статика через WhiteNoise | | WebSockets | Django Channels + Daphne (Redis в `settings_base.py`, InMemory в `settings.py`) | | Интерактивность | HTMX + кастомный JS | | UI сайта | Bootstrap 5 | | Email | Brevo (SMTP) | | Интеграции | Google Drive API | ### Сервер - **IP:** 176.118.198.78 - **Домен:** https://caromoto-lt.com - **Путь на сервере:** `/var/www/www-root/data/www/logist2` --- ## 🏗️ АРХИТЕКТУРА И ИЕРАРХИЯ ДАННЫХ ### Главная иерархия ``` КОНТЕЙНЕР (Container) — главная сущность, \"родитель\" │ ├── Морская линия (Line) ├── Склад (Warehouse) ├── THS (сумма оплаты линиям за в", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "--- ## 🏗️ АРХИТЕКТУРА И ИЕРАРХИЯ ДАННЫХ ### Главная иерархия ``` КОНТЕЙНЕР (Container) — главная сущность, \"родитель\" │ ├── Морская линия (Line) ├── Склад (Warehouse) ├── THS (сумма оплаты линиям за весь контейнер) │ └── АВТОМОБИЛИ (Car) — \"дети\", наследуют данные от контейнера │ ├── Клиент (Client) — владелец ТС ├── Перевозчик (Carrier) — доставка ТС после разгрузки │ └── УСЛУГИ (CarService) — связь ТС с услугами ├── Услуги линии (LINE) — включая THS ├── Услуги склада (WAREHOUSE) — хранение, разгрузка и др. ├── Услуги перевозчика (CARRIER) └── Услуги компании (COMPANY) ``` ### Принцип наследования данных **ВАЖНО:** Контейнер — главная страница. Все изменения в контейнере автоматически применяются ко всем ТС внутри: | Поле контейнера | Наследуется в ТС | Примечание | |-----------------|------------------|------------| | `status` | ✅ Да | При изменении статуса контейнера меняется статус всех ТС | | `warehouse` | ✅ Да | Склад копируется во все ТС | | `unload_date` | ✅ Да (принудительно) | Дата разгрузки ВСЕГДА наследуется | | `line` | ✅ Да | Линия копируется во все ТС | | `ths` | ✅ Распределяется | THS распределяется пропорционально по типам ТС | **Обратная синхронизация:** Когда ВСЕ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "| Дата разгрузки ВСЕГДА наследуется | | `line` | ✅ Да | Линия копируется во все ТС | | `ths` | ✅ Распределяется | THS распределяется пропорционально по типам ТС | **Обратная синхронизация:** Когда ВСЕ ТС в контейнере получают статус \"Передан\" — контейнер автоматически тоже получает статус \"Передан\". --- ## 📦 МОДЕЛИ ДАННЫХ ### Container (Контейнер) ```python # Файл: core/models.py Container: number # Номер контейнера (уникальный) status # FLOATING (В пути), IN_PORT (В порту), UNLOADED (Разгружен), TRANSFERRED (Передан) line # FK → Line (Морская линия) warehouse # FK → Warehouse (Склад разгрузки) client # FK → Client (клиент контейнера) customs_procedure # Таможенная процедура (TRANSIT/IMPORT/REEXPORT/EXPORT) # THS система ths # Decimal — общая сумма THS за контейнер ths_payer # LINE или WAREHOUSE — кому записать расход THS sklad # Оплата складу (legacy поле контейнера) dekl # Декларация (legacy поле контейнера) proft # Наценка (legacy поле контейнера) # Даты eta # Ожидаемая дата прибытия planned_unload_date # \"Будем разгружать\" — при установке отправляется email клиентам unload_date # Фактическая дата разгрузки — при установке отправляется email unloaded_status_at # Когда контейнер ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "я planned_unload_date # \"Будем разгружать\" — при установке отправляется email клиентам unload_date # Фактическая дата разгрузки — при установке отправляется email unloaded_status_at # Когда контейнер получил статус \"Разгружен\" # Хранение на уровне контейнера (legacy расчёт) free_days # Бесплатные дни days # Платные дни rate # Ставка (legacy) storage_cost # Стоимость хранения (legacy) notes # Примечания # Google Drive google_drive_folder_url # Ссылка на папку с фото контейнера ``` **Валидация:** При статусе \"Разгружен\" поля `warehouse` и `unload_date` обязательны. ### Car (Автомобиль/Транспортное средство) ```python # Файл: core/models.py Car: # Идентификация vin # VIN номер (уникальный, 17 символов) brand # Марка (Toyota, BMW и т.д.) year # Год выпуска # ТИП ТРАНСПОРТНОГО СРЕДСТВА (11 вариантов) vehicle_type: SEDAN # Легковой (коэффициент THS: 1.0) CROSSOVER # Кроссовер (1.2) SUV # Джип (1.5) PICKUP # Пикап (1.5) NEW_CAR # Новый автомобиль (1.0) MOTO # Мотоцикл (0.3) BIG_MOTO # Большой мотоцикл (0.5) ATV # Квадроцикл/Багги (0.5) BOAT # Лодка (2.0) RV # Автодом (3.0) CONSTRUCTION # Стр. техника (2.5) # Связи container # FK → Container (может быть NULL для ТС без контейнера) client #", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": " мотоцикл (0.5) ATV # Квадроцикл/Багги (0.5) BOAT # Лодка (2.0) RV # Автодом (3.0) CONSTRUCTION # Стр. техника (2.5) # Связи container # FK → Container (может быть NULL для ТС без контейнера) client # FK → Client (владелец) warehouse # FK → Warehouse (склад хранения) line # FK → Line (морская линия) carrier # FK → Carrier (перевозчик) # Статус и даты status # Наследуется от контейнера unload_date # Наследуется от контейнера (принудительно) transfer_date # Дата передачи клиенту # Хранение free_days # Бесплатные дни хранения (из склада) days # Платные дни (рассчитывается автоматически) storage_cost # Стоимость хранения (дни × ставка) # Цена total_price # Итоговая цена = сумма всех услуг + наценки proft # Наценка Caromoto Lithuania (legacy поле) hide_markup_in # FK → CarService (в какую услугу скрыть наценку) # Документы has_title # Есть ли Title title_notes # Примечания к Title # Доп.расходы (legacy поля, используются в старых расчетах/отчетах) unload_fee, delivery_fee, loading_fee, docs_fee, transfer_fee transit_declaration, export_declaration, extra_costs, complex_fee price, auction_fee, transport_usa, ocean_freight, transport_kz broker_fee, additional_expenses, rate ``` ### CarSer", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "_fee, transfer_fee transit_declaration, export_declaration, extra_costs, complex_fee price, auction_fee, transport_usa, ocean_freight, transport_kz broker_fee, additional_expenses, rate ``` ### CarService (Связь ТС с услугами) ```python # Файл: core/models.py CarService: car # FK → Car service_type # LINE, WAREHOUSE, CARRIER или COMPANY service_id # ID услуги в соответствующей таблице (LineService/WarehouseService/CarrierService/CompanyService) custom_price # Индивидуальная цена (если отличается от дефолтной) markup_amount # СКРЫТАЯ НАЦЕНКА (добавляется к цене в инвойсе, не видна клиенту отдельно) quantity # Количество (обычно 1) notes # Примечания # Свойства (property) final_price # = custom_price × quantity (БЕЗ наценки, для внутреннего учёта) invoice_price # = (custom_price + markup_amount) × quantity (для инвойса клиенту) ``` ### Услуги поставщиков ```python # Файл: core/models.py LineService: # Услуги морских линий line # FK → Line name # \"THS MAERSK 3 АВТО\", \"Документы\" и т.д. default_price # Цена по умолчанию default_markup # Наценка по умолчанию is_active # Активна ли услуга add_by_default # ✅ ВАЖНО: добавлять ли автоматически при создании ТС этой линии WarehouseService: # ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "fault_price # Цена по умолчанию default_markup # Наценка по умолчанию is_active # Активна ли услуга add_by_default # ✅ ВАЖНО: добавлять ли автоматически при создании ТС этой линии WarehouseService: # Услуги складов warehouse # FK → Warehouse name # \"Хранение\", \"Разгрузка\", \"Документы\" и т.д. default_price # Цена по умолчанию (для \"Хранение\" — ставка за ДЕНЬ) default_markup # Наценка по умолчанию (для \"Хранение\" — наценка за ДЕНЬ) is_active # Активна ли услуга add_by_default # ✅ ВАЖНО: добавлять ли автоматически при создании ТС на этом складе CarrierService: # Услуги перевозчиков carrier # FK → Carrier name # \"Доставка\", \"Погрузка\" и т.д. default_price # Цена по умолчанию default_markup # Наценка по умолчанию is_active # Активна ли услуга add_by_default # ✅ ВАЖНО: добавлять ли автоматически при создании ТС этого перевозчика CompanyService: # Услуги компаний company # FK → Company (Caromoto Lithuania и др.) name # \"Документы\", \"Комиссия\" и т.д. description # Описание услуги default_price # Цена по умолчанию default_markup # Наценка по умолчанию is_active # Активна ли услуга add_by_default # ✅ ВАЖНО: добавлять ли автоматически при создании ТС компании ``` ### LineTHSCoefficient (Коэфф", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": " # Цена по умолчанию default_markup # Наценка по умолчанию is_active # Активна ли услуга add_by_default # ✅ ВАЖНО: добавлять ли автоматически при создании ТС компании ``` ### LineTHSCoefficient (Коэффициенты THS) ```python # Файл: core/models.py LineTHSCoefficient: line # FK → Line vehicle_type # Тип ТС (SEDAN, MOTO и т.д.) coefficient # Коэффициент (вес) для распределения THS # Пример: Линия MAERSK # SEDAN: 1.0, SUV: 1.5, MOTO: 0.3, BOAT: 2.0 ``` --- ## 💰 СИСТЕМА THS (TERMINAL HANDLING SURCHARGE) ### Что такое THS THS — это сбор морских линий за обработку контейнера в порту. Сумма THS указывается в контейнере и распределяется между всеми ТС внутри пропорционально их \"весу\" (коэффициенту). ### Алгоритм распределения THS ``` 1. Получить общую сумму THS контейнера 2. Для каждого ТС получить коэффициент его типа из LineTHSCoefficient 3. Рассчитать долю: THS_ТС = общий_THS × (коэффициент / сумма_всех_коэффициентов) 4. Округлить ВВЕРХ до 5 EUR (73.12 → 75 EUR) ``` ### Пример расчёта ``` Контейнер THS = 500 EUR 3 ТС: легковой(1.0) + джип(1.5) + мото(0.3) = сумма коэффициентов 2.8 - Легковой: 500 × (1.0/2.8) = 178.57 → округляем до 180 EUR - Джип: 500 × (1.5/2.8) = 267.86 → округляем до 2", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "тейнер THS = 500 EUR 3 ТС: легковой(1.0) + джип(1.5) + мото(0.3) = сумма коэффициентов 2.8 - Легковой: 500 × (1.0/2.8) = 178.57 → округляем до 180 EUR - Джип: 500 × (1.5/2.8) = 267.86 → округляем до 270 EUR - Мото: 500 × (0.3/2.8) = 53.57 → округляем до 55 EUR ``` ### Поле ths_payer Определяет, от чьего имени записать расход THS в карточках ТС: | Значение | Описание | Услуга создаётся как | |----------|----------|---------------------| | `LINE` | Оплата напрямую линии | CarService с service_type='LINE' | | `WAREHOUSE` | Оплата через склад | CarService с service_type='WAREHOUSE' | **Когда используется WAREHOUSE:** Иногда склад оплачивает THS линии от своего имени, а потом выставляет счёт нам. В этом случае THS записывается как услуга склада. ### Ключевые функции ```python # Файл: core/signals.py calculate_ths_for_container(container) # Рассчитывает THS для каждого ТС пропорционально коэффициентам # Возвращает: {car_id: ths_amount} create_ths_services_for_container(container) # Создаёт CarService записи с THS для всех ТС в контейнере # Удаляет старые THS-услуги перед созданием новых # Тип услуги (LINE/WAREHOUSE) определяется полем ths_payer round_up_to_5(value) # Округляет вверх с ша", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "arService записи с THS для всех ТС в контейнере # Удаляет старые THS-услуги перед созданием новых # Тип услуги (LINE/WAREHOUSE) определяется полем ths_payer round_up_to_5(value) # Округляет вверх с шагом 5 EUR # Пример: 73.12 → 75 ``` ### Когда пересчитывается THS 1. **При сохранении контейнера** — если изменились поля: `line`, `ths`, `ths_payer`, `warehouse` 2. **При нажатии кнопки \"Пересчитать THS\"** в карточке линии --- ## 🏭 СИСТЕМА УСЛУГ СКЛАДОВ ### Автоматическое добавление услуг При создании ТС на складе автоматически добавляются услуги с флагом `add_by_default=True`. **Для линий, перевозчиков и компаний:** - Логика `add_by_default` работает аналогично складам - Услуги добавляются **только для новых ТС**, уже существующие ТС не затрагиваются **Типичные услуги склада:** - **Хранение** — цена = платные_дни × ставка_за_день - **Разгрузка** — фиксированная цена - **Документы** — фиксированная цена - **Погрузка на трал** — фиксированная цена ### Услуга \"Хранение\" — особая логика ```python # Цена услуги \"Хранение\" рассчитывается динамически: storage_price = платные_дни × цена_за_день storage_markup = платные_дни × наценка_за_день # Где: # - платные_дни = (сегодня или дата_передачи)", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "thon # Цена услуги \"Хранение\" рассчитывается динамически: storage_price = платные_дни × цена_за_день storage_markup = платные_дни × наценка_за_день # Где: # - платные_дни = (сегодня или дата_передачи) - дата_разгрузки - бесплатные_дни # - цена_за_день берётся из WarehouseService.default_price для услуги \"Хранение\" # - наценка_за_день берётся из WarehouseService.default_markup ``` **ВАЖНО:** Если платных дней нет (ТС ещё на бесплатном хранении) — цена услуги \"Хранение\" = 0. ### Бесплатные дни - Указываются в карточке склада (`Warehouse.free_days`) - Наследуются в ТС при назначении склада - Влияют на расчёт платных дней хранения --- ## 💵 СИСТЕМА НАЦЕНКИ (MARKUP) ### Скрытая наценка Наценка Caromoto Lithuania — это прибыль компании, которая НЕ показывается клиенту отдельной строкой в инвойсе. Вместо этого она распределяется по услугам. ### Как работает ```python CarService.markup_amount # Скрытая наценка для каждой услуги # Цены: final_price = custom_price × quantity # Для внутреннего учёта invoice_price = (custom_price + markup_amount) × quantity # Для клиента ``` ### Пример ``` Услуга \"Разгрузка\": - custom_price = 50 EUR - markup_amount = 10 EUR - В инвойсе клиенту: 60 EUR (клиент н", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "та invoice_price = (custom_price + markup_amount) × quantity # Для клиента ``` ### Пример ``` Услуга \"Разгрузка\": - custom_price = 50 EUR - markup_amount = 10 EUR - В инвойсе клиенту: 60 EUR (клиент не видит, что 10 EUR — это наценка) ``` ### Наценка по умолчанию При создании CarService наценка копируется из `default_markup` соответствующей услуги (LineService, WarehouseService, CarrierService). --- ## 📧 EMAIL-УВЕДОМЛЕНИЯ ### Триггеры отправки | Событие | Тип уведомления | Кому | |---------|-----------------|------| | Установка `planned_unload_date` | \"Планируем разгрузку\" | Всем клиентам с ТС в контейнере | | Установка `unload_date` | \"Контейнер разгружен\" | Всем клиентам с ТС в контейнере | ### Настройки клиента ```python Client: email # Основной email email2, email3, email4 # Дополнительные email notification_enabled # Получать ли уведомления (по умолчанию True) ``` ### Email-сервис ```python # Файл: core/services/email_service.py ContainerNotificationService: send_planned_to_all_clients(container) # Уведомление о планируемой разгрузке send_unload_to_all_clients(container) # Уведомление о разгрузке was_planned_notification_sent(container) # Проверка, было ли отправлено was_unloa", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "ients(container) # Уведомление о планируемой разгрузке send_unload_to_all_clients(container) # Уведомление о разгрузке was_planned_notification_sent(container) # Проверка, было ли отправлено was_unload_notification_sent(container) # Проверка, было ли отправлено ``` ### Защита от повторной отправки Все отправленные уведомления логируются в модели `NotificationLog`. Повторная отправка того же типа уведомления для того же контейнера блокируется. --- ## 📄 СИСТЕМА ИНВОЙСОВ ### Модель NewInvoice ```python # Файл: core/models_billing.py NewInvoice: number # Уникальный номер (генерируется автоматически: INV-202601-0001) date # Дата выставления due_date # Срок оплаты (по умолчанию +14 дней) # Выставитель (ОДИН из четырёх) issuer_company # FK → Company (Caromoto Lithuania) issuer_warehouse # FK → Warehouse issuer_line # FK → Line issuer_carrier # FK → Carrier # Получатель (ОДИН из пяти) recipient_client # FK → Client recipient_warehouse # FK → Warehouse recipient_line # FK → Line recipient_carrier # FK → Carrier recipient_company # FK → Company # Финансы subtotal # Сумма всех позиций discount # Скидка tax # Налог total # Итого к оплате paid_amount # Уже оплачено # Связь с ТС cars # ManyToMan", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "er # FK → Carrier recipient_company # FK → Company # Финансы subtotal # Сумма всех позиций discount # Скидка tax # Налог total # Итого к оплате paid_amount # Уже оплачено # Связь с ТС cars # ManyToMany → Car (выбранные ТС) status # DRAFT, ISSUED, PARTIALLY_PAID, PAID, OVERDUE, CANCELLED ``` ### Автоматическая генерация позиций При выборе ТС в инвойсе позиции создаются автоматически из их услуг (CarService). **Логика зависит от типа выставителя:** | Выставитель | Какие услуги включаются | |-------------|------------------------| | Company (Caromoto Lithuania) | ВСЕ услуги + хранение + скрытая наценка (добавляется к ценам) | | Warehouse | Только услуги этого склада + хранение | | Line | Только услуги этой линии | | Carrier | Только услуги этого перевозчика | ### Метод regenerate_items_from_cars() ```python # Файл: core/models_billing.py → NewInvoice regenerate_items_from_cars(): # 1. Удаляет старые позиции инвойса # 2. Для каждого выбранного ТС: # - Пересчитывает хранение (update_days_and_storage) # - Создаёт позиции из CarService # 3. Для Company: добавляет markup_amount к ценам (скрыто) # 4. Пересчитывает итоги ``` ### Автоматический пересчёт инвойсов Инвойс автоматически пересчиты", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "d_storage) # - Создаёт позиции из CarService # 3. Для Company: добавляет markup_amount к ценам (скрыто) # 4. Пересчитывает итоги ``` ### Автоматический пересчёт инвойсов Инвойс автоматически пересчитывается при: - Изменении услуг ТС (CarService) - Изменении данных ТС (дни хранения, статус) Это реализовано через сигналы в `core/signals.py`. --- ## 📸 ФОТОГРАФИИ КОНТЕЙНЕРОВ ### Google Drive интеграция ```python # Файл: core/google_drive_sync.py GoogleDriveSync: sync_container_by_number(container_number) # Автопоиск папки по номеру download_folder_photos(folder_url, container) # Скачивание по ссылке ``` ### Типы фотографий | Тип | Код | Папка на Google Drive | |-----|-----|----------------------| | В контейнере | `IN_CONTAINER` | \"KONTO VIDUS\" | | Выгруженные | `UNLOADING` | \"AUTO IŠ KONTO\" | ### Автоматическая синхронизация Фотографии автоматически синхронизируются при: - Установке статуса \"Разгружен\" - Установке даты разгрузки ### Management команда ```bash python manage.py sync_photos_gdrive --no-photos # Контейнеры без фото python manage.py sync_photos_gdrive --recent # Недавние контейнеры python manage.py sync_photos_gdrive --container ECMU5566195 # Конкретный ``` --- ## 🤖 AI-ПОМО", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "drive --no-photos # Контейнеры без фото python manage.py sync_photos_gdrive --recent # Недавние контейнеры python manage.py sync_photos_gdrive --container ECMU5566195 # Конкретный ``` --- ## 🤖 AI-ПОМОЩНИК ### Основной функционал - Чат-виджет доступен на клиентском сайте и в админке - Контекст формируется из БД: VIN/контейнер, статус, склад, даты и фото - Финансовые вопросы (цены/оплаты/балансы/инвойсы) блокируются и отправляют к менеджеру - Ссылки на галерею контейнера открываются одной ссылкой без регистрации ### Публичная ссылка на галерею - `/?track=<номер_контейнера>&photos=1` — автоматически запускает поиск и открывает фото ### Endpoint - `POST /api/ai-chat/` — принимает `message` и `session_id` ### Настройки в `.env` ``` AI_CHAT_ENABLED=True AI_API_KEY=... AI_API_BASE_URL=https://api.openai.com/v1 AI_MODEL=gpt-4o-mini AI_MAX_TOKENS=400 AI_TEMPERATURE=0.2 AI_REQUEST_TIMEOUT=40 ``` ### Ключевые файлы - `core/services/ai_chat_service.py` — сервис AI, сбор контекста, вызов API - `core/views_website.py` — endpoint и бизнес-правила (финансы/фото/ссылки) - `core/static/website/js/ai-chat.js` — клиентский чат, CSRF, кликабельные ссылки - `templates/admin/base_site.html` + `core/stati", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "e/views_website.py` — endpoint и бизнес-правила (финансы/фото/ссылки) - `core/static/website/js/ai-chat.js` — клиентский чат, CSRF, кликабельные ссылки - `templates/admin/base_site.html` + `core/static/admin/css/ai-chat.css` — виджет в админке ## 🔧 СТРУКТУРА ФАЙЛОВ ### Основные файлы ``` logist2/ ├── core/ # Основное приложение │ ├── models.py # Главные модели (Container, Car, CarService и др.) │ ├── models_billing.py # Инвойсы и транзакции (NewInvoice, InvoiceItem) │ ├── models_website.py # Модели для клиентского сайта │ │ │ ├── admin.py # Django Admin (ContainerAdmin, CarAdmin, LineAdmin) │ ├── admin_billing.py # Admin для инвойсов │ ├── admin_website.py # Admin для клиентского сайта │ │ │ ├── signals.py # Сигналы (наследование данных, THS, email) │ ├── views.py # Views для админки │ ├── views_website.py # Views для клиентского сайта │ │ │ ├── google_drive_sync.py # Интеграция с Google Drive │ │ │ ├── services/ │ │ ├── email_service.py # Email-уведомления │ │ ├── ai_chat_service.py # AI-помощник (контекст из БД) │ │ ├── billing_service.py # Биллинг │ │ └── balance_manager.py # Управление балансами │ │ │ ├── management/commands/ # Management команды │ └── migrations/ # Миграции БД", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": " AI-помощник (контекст из БД) │ │ ├── billing_service.py # Биллинг │ │ └── balance_manager.py # Управление балансами │ │ │ ├── management/commands/ # Management команды │ └── migrations/ # Миграции БД (88+ файлов) │ ├── templates/ │ ├── admin/ # Кастомные шаблоны админки │ │ ├── line_change.html # Кнопка \"Пересчитать THS\" │ │ ├── base_site.html # Вставка AI-виджета в админке │ │ └── core/container/ # Шаблоны контейнера │ ├── email/ # Шаблоны email │ └── website/ # Клиентский сайт │ ├── logist2/ │ ├── settings.py # Локальные настройки (InMemory Channels) │ ├── settings_base.py # Базовые настройки (Redis Channels) │ ├── settings_dev.py # Dev-профиль │ ├── settings_prod.py # Prod-профиль │ ├── settings_test.py # Test-профиль (SQLite) │ ├── urls.py # URL routing │ └── wsgi.py / asgi.py # WSGI/ASGI │ ├── requirements.txt # Python зависимости └── requirements_website.txt # Доп. зависимости сайта (опционально) ``` --- ## 🔄 КЛЮЧЕВЫЕ СИГНАЛЫ ### Файл: core/signals.py ```python # При сохранении Container save_old_container_values() # Сохраняет старые значения для сравнения update_related_on_container_save() # Обновляет ТС при изменении контейнера send_container_notifications_on_save() # Отпр", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "Container save_old_container_values() # Сохраняет старые значения для сравнения update_related_on_container_save() # Обновляет ТС при изменении контейнера send_container_notifications_on_save() # Отправляет email-уведомления auto_sync_photos_on_container_change() # Синхронизирует фото с Google Drive # При сохранении Car save_old_contractors() # Сохраняет старые контрагенты update_related_on_car_save() # Обновляет инвойсы create_car_services_on_car_save() # Создаёт услуги (склад, перевозчик) # При изменении CarService recalculate_invoices_on_car_service_save() # Пересчитывает инвойсы recalculate_invoices_on_car_service_delete() # Пересчитывает инвойсы # При изменении услуг в справочниках update_cars_on_warehouse_service_change() # Обновляет CarService update_cars_on_carrier_service_change() # Обновляет CarService update_cars_on_company_service_change() # Обновляет CarService (Company) delete_car_services_on_company_service_delete() # Удаляет Company CarService ``` --- ## ⚙️ АДМИНКА (DJANGO ADMIN) ### ContainerAdmin **Инлайны:** - `CarInline` — список ТС в контейнере - `ContainerPhotoInline` — фотографии **Actions:** - Установка статусов (В пути, В порту, Разгружен, Передан) - Синхро", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "NGO ADMIN) ### ContainerAdmin **Инлайны:** - `CarInline` — список ТС в контейнере - `ContainerPhotoInline` — фотографии **Actions:** - Установка статусов (В пути, В порту, Разгружен, Передан) - Синхронизация фото с Google Drive - Повторная отправка уведомлений **save_model() — ключевая логика:** 1. Если изменился `warehouse` → синхронизировать склад во все ТС 2. Если изменился `status` → обновить статус всех ТС (bulk_update) 3. Если изменилась `unload_date` → обновить дату во всех ТС (bulk_update) 4. Если изменились `line/ths/ths_payer/warehouse` → пересчитать THS ### CarAdmin **Особенности:** - Отображение услуг с возможностью редактирования наценки - Сводка по услугам (services_summary_display) - Динамический расчёт цены ### LineAdmin **Инлайны:** - `LineServiceInline` — услуги линии - `LineTHSCoefficientInline` — коэффициенты THS **Кнопка \"Пересчитать THS\":** - Пересчитывает THS для всех ТС во всех контейнерах этой линии - Используется после изменения коэффициентов --- ## 📊 СТАТУСЫ ### Статусы контейнера/ТС | Код | Название | Описание | |-----|----------|----------| | `FLOATING` | В пути | Контейнер в море | | `IN_PORT` | В порту | Контейнер прибыл, ожидает разгрузки | | `UNLOAD", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "### Статусы контейнера/ТС | Код | Название | Описание | |-----|----------|----------| | `FLOATING` | В пути | Контейнер в море | | `IN_PORT` | В порту | Контейнер прибыл, ожидает разгрузки | | `UNLOADED` | Разгружен | Контейнер разгружен, ТС на складе | | `TRANSFERRED` | Передан | ТС передано клиенту | ### Статусы инвойса | Код | Название | |-----|----------| | `DRAFT` | Черновик | | `ISSUED` | Выставлен | | `PARTIALLY_PAID` | Частично оплачен | | `PAID` | Оплачен | | `OVERDUE` | Просрочен | | `CANCELLED` | Отменен | --- ## 🛠️ ПОЛЕЗНЫЕ КОМАНДЫ ### На сервере ```bash # Подключение ssh root@176.118.198.78 cd /var/www/www-root/data/www/logist2 source .venv/bin/activate # Перезапуск сервисов systemctl restart gunicorn systemctl restart daphne # Миграции python manage.py migrate # Статика python manage.py collectstatic --noinput # Синхронизация фото python manage.py sync_photos_gdrive --no-photos # Права на media файлы ./fix_media_permissions.sh ``` ### Локально (PowerShell) ```powershell # Запуск dev сервера .\\START_ME.bat # Деплой .\\deploy.ps1 # Миграции python manage.py makemigrations python manage.py migrate ``` --- ## ⚠️ ВАЖНЫЕ НЮАНСЫ ### 1. Не пересчитывать старые данные При внедр", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": " Запуск dev сервера .\\START_ME.bat # Деплой .\\deploy.ps1 # Миграции python manage.py makemigrations python manage.py migrate ``` --- ## ⚠️ ВАЖНЫЕ НЮАНСЫ ### 1. Не пересчитывать старые данные При внедрении изменений НЕ НУЖНО пересчитывать цены/услуги для уже существующих ТС и контейнеров. Изменения касаются только новых данных. ### 2. PowerShell ограничения - Не работает `&&` — использовать `;` - Кириллица в SSH командах может ломаться - Для сложных операций использовать `deploy.ps1` ### 3. Профили настроек - Локально по умолчанию используется `settings.py` (InMemory Channels). - Для продакшна используется связка `settings_base.py` + `settings_prod.py` (Redis Channels, ASGI включен). ### 4. Кэширование Django При изменении услуг ТС нужно сбрасывать prefetch кэш: ```python if hasattr(self, '_prefetched_objects_cache'): self._prefetched_objects_cache.pop('car_services', None) ``` ### 5. Email через Brevo - Бесплатно: 300 писем/день - SMTP: smtp-relay.brevo.com - Настройки в `.env` на сервере ### 6. Коэффициенты THS по умолчанию Если для типа ТС не указан коэффициент в `LineTHSCoefficient`, используется значение 1.0. --- ## 📝 ТИПИЧНЫЕ СЦЕНАРИИ ИСПОЛЬЗОВАНИЯ ### Создание нового контейне", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "ере ### 6. Коэффициенты THS по умолчанию Если для типа ТС не указан коэффициент в `LineTHSCoefficient`, используется значение 1.0. --- ## 📝 ТИПИЧНЫЕ СЦЕНАРИИ ИСПОЛЬЗОВАНИЯ ### Создание нового контейнера 1. Указать номер контейнера 2. Выбрать линию → система подготовит коэффициенты THS 3. Указать сумму THS и плательщика (LINE/WAREHOUSE) 4. Выбрать склад → услуги склада будут добавлены автоматически 5. Добавить ТС через инлайн → каждому ТС создадутся услуги 6. При сохранении → THS распределится по всем ТС ### Изменение даты разгрузки 1. Указать дату разгрузки в контейнере 2. При сохранении → дата автоматически установится всем ТС 3. Пересчитаются платные дни и стоимость хранения 4. Обновятся связанные инвойсы 5. Клиентам отправится email-уведомление ### Изменение коэффициентов THS 1. Открыть карточку линии 2. Изменить коэффициенты в инлайне `LineTHSCoefficientInline` 3. Сохранить линию 4. Нажать кнопку \"Пересчитать THS\" 5. THS пересчитается для всех ТС этой линии ### Выставление инвойса клиенту 1. Создать NewInvoice 2. Выбрать выставителя: Caromoto Lithuania (Company) 3. Выбрать получателя: Клиент 4. Добавить ТС через ManyToMany 5. Сохранить → позиции создадутся автоматически из CarS", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\PROMT_LOGIST2.md", "content": "клиенту 1. Создать NewInvoice 2. Выбрать выставителя: Caromoto Lithuania (Company) 3. Выбрать получателя: Клиент 4. Добавить ТС через ManyToMany 5. Сохранить → позиции создадутся автоматически из CarService 6. Скрытая наценка добавится к ценам услуг --- ## 🔗 СВЯЗАННЫЕ ДОКУМЕНТЫ - `AI_PROJECT_CONTEXT.md` — контекст для AI с деталями деплоя - `LOGIST2_PROGRESS_REPORT.md` — отчёт о проделанной работе - `CREDENTIALS.md` — пароли и секреты (не в git) --- **Конец документа**", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "from django.db import models from django.core.validators import MinValueValidator from .constants import STATUS_COLORS from django.utils import timezone from channels.layers import get_channel_layer from asgiref.sync import async_to_sync from django.db.models import Sum, Q from django.db import transaction from decimal import Decimal import logging from datetime import timedelta # Импортируем оптимизированные менеджеры from .managers import ( OptimizedCarManager, OptimizedContainerManager, OptimizedClientManager, OptimizedWarehouseManager, OptimizedCompanyManager ) logger = logging.getLogger('django') def get_current_user(): \"\"\"Получить текущего пользователя\"\"\" from django.contrib.auth.models import AnonymousUser from django.contrib.auth import get_user try: user = get_user() if user.is_authenticated: return user.username return 'system' except: return 'system' # Базовый менеджер для управления обновлениями class BaseManager(models.Manager): def update_related(self, instance): pass # Новые модели для системы балансов # Справочники class Line(models.Model): name = models.CharField(max_length=100, verbose_name=\"Название линии\") # Единый баланс (новая система) balance = models.Decimal", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "овые модели для системы балансов # Справочники class Line(models.Model): name = models.CharField(max_length=100, verbose_name=\"Название линии\") # Единый баланс (новая система) balance = models.DecimalField(max_digits=15, decimal_places=2, default=0.00, verbose_name=\"Баланс\", help_text=\"Положительный = нам должны, отрицательный = мы должны\") balance_updated_at = models.DateTimeField(auto_now=True, verbose_name=\"Баланс обновлен\") # Услуги и цены ocean_freight_rate = models.DecimalField(max_digits=10, decimal_places=2, default=0.00, verbose_name=\"Стоимость перевозки (за авто)\") documentation_fee = models.DecimalField(max_digits=10, decimal_places=2, default=0.00, verbose_name=\"Стоимость документов\") handling_fee = models.DecimalField(max_digits=10, decimal_places=2, default=0.00, verbose_name=\"Стоимость обработки\") ths_fee = models.DecimalField(max_digits=10, decimal_places=2, default=0.00, verbose_name=\"THS сбор (оплата линиям)\") additional_fees = models.DecimalField(max_digits=10, decimal_places=2, default=0.00, verbose_name=\"Дополнительные сборы\") class Meta: verbose_name = \"Линия\" verbose_name_plural = \"Линии\" def __str__(self): return self.name class LineTHSCoefficient(models.Mod", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "al_places=2, default=0.00, verbose_name=\"Дополнительные сборы\") class Meta: verbose_name = \"Линия\" verbose_name_plural = \"Линии\" def __str__(self): return self.name class LineTHSCoefficient(models.Model): \"\"\"Коэффициент THS для типа ТС у конкретной линии. Используется для распределения общей суммы THS контейнера между ТС пропорционально их \"весу\" (коэффициенту). Пример: Контейнер THS = 500 EUR 3 машины: легковой(1.0) + джип(2.0) + мото(0.5) = сумма весов 3.5 - Легковой: 500 × (1.0/3.5) = 143 EUR - Джип: 500 × (2.0/3.5) = 286 EUR - Мото: 500 × (0.5/3.5) = 71 EUR \"\"\" # Типы ТС дублируем здесь чтобы избежать циклического импорта VEHICLE_TYPE_CHOICES = [ ('SEDAN', 'Легковой'), ('CROSSOVER', 'Кроссовер'), ('SUV', 'Джип'), ('PICKUP', 'Пикап'), ('NEW_CAR', 'Новая машина'), ('MOTO', 'Мотоцикл'), ('BIG_MOTO', 'Большой мотоцикл'), ('ATV', 'Квадроцикл/Багги'), ('BOAT', 'Лодка'), ('RV', 'Автодом (RV)'), ('CONSTRUCTION', 'Стр. техника'), ] line = models.ForeignKey(Line, on_delete=models.CASCADE, related_name='ths_coefficients', verbose_name=\"Линия\") vehicle_type = models.CharField(max_length=20, choices=VEHICLE_TYPE_CHOICES, verbose_name=\"Тип ТС\") coefficient = models.DecimalField(max_digits=5,", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "lated_name='ths_coefficients', verbose_name=\"Линия\") vehicle_type = models.CharField(max_length=20, choices=VEHICLE_TYPE_CHOICES, verbose_name=\"Тип ТС\") coefficient = models.DecimalField(max_digits=5, decimal_places=2, default=1.00, verbose_name=\"Коэффициент\", help_text=\"Вес типа ТС при распределении THS (1.0 = стандарт, 2.0 = двойной, 0.5 = половина)\") class Meta: verbose_name = \"Коэффициент THS для типа ТС\" verbose_name_plural = \"Коэффициенты THS для типов ТС\" unique_together = ['line', 'vehicle_type'] def __str__(self): return f\"{self.line.name} - {self.get_vehicle_type_display()}: ×{self.coefficient}\" class Carrier(models.Model): name = models.CharField(max_length=100, verbose_name=\"Название перевозчика\") short_name = models.CharField(max_length=20, blank=True, null=True, verbose_name=\"Короткое название\") contact_person = models.CharField(max_length=100, blank=True, null=True, verbose_name=\"Контактное лицо\") phone = models.CharField(max_length=20, blank=True, null=True, verbose_name=\"Телефон\") email = models.EmailField(blank=True, null=True, verbose_name=\"Email\") # Единый баланс (новая система) balance = models.DecimalField(max_digits=15, decimal_places=2, default=0.00, verbose", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "e=\"Телефон\") email = models.EmailField(blank=True, null=True, verbose_name=\"Email\") # Единый баланс (новая система) balance = models.DecimalField(max_digits=15, decimal_places=2, default=0.00, verbose_name=\"Баланс\", help_text=\"Положительный = нам должны, отрицательный = мы должны\") balance_updated_at = models.DateTimeField(auto_now=True, verbose_name=\"Баланс обновлен\") # Услуги и цены transport_rate = models.DecimalField(max_digits=10, decimal_places=2, default=0.00, verbose_name=\"Стоимость перевозки (за км)\") loading_fee = models.DecimalField(max_digits=10, decimal_places=2, default=0.00, verbose_name=\"Стоимость погрузки\") unloading_fee = models.DecimalField(max_digits=10, decimal_places=2, default=0.00, verbose_name=\"Стоимость разгрузки\") fuel_surcharge = models.DecimalField(max_digits=10, decimal_places=2, default=0.00, verbose_name=\"Топливная надбавка\") additional_fees = models.DecimalField(max_digits=10, decimal_places=2, default=0.00, verbose_name=\"Дополнительные сборы\") created_at = models.DateTimeField(auto_now_add=True, verbose_name=\"Дата создания\") updated_at = models.DateTimeField(auto_now=True, verbose_name=\"Дата обновления\") objects = OptimizedCompanyManager() class Me", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "at = models.DateTimeField(auto_now_add=True, verbose_name=\"Дата создания\") updated_at = models.DateTimeField(auto_now=True, verbose_name=\"Дата обновления\") objects = OptimizedCompanyManager() class Meta: verbose_name = \"Перевозчик\" verbose_name_plural = \"Перевозчики\" def __str__(self): return self.name class Client(models.Model): name = models.CharField(max_length=100, verbose_name=\"Имя клиента\") email = models.EmailField(blank=True, null=True, verbose_name=\"Email 1\", help_text=\"Основной email для уведомлений о разгрузке контейнеров\") email2 = models.EmailField(blank=True, null=True, verbose_name=\"Email 2\", help_text=\"Дополнительный email для уведомлений\") email3 = models.EmailField(blank=True, null=True, verbose_name=\"Email 3\", help_text=\"Дополнительный email для уведомлений\") email4 = models.EmailField(blank=True, null=True, verbose_name=\"Email 4\", help_text=\"Дополнительный email для уведомлений\") notification_enabled = models.BooleanField(default=True, verbose_name=\"Получать уведомления\", help_text=\"Отправлять email-уведомления о контейнерах\") # Единый баланс (новая система) balance = models.DecimalField(max_digits=15, decimal_places=2, default=0.00, verbose_name=\"Баланс\", help_", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "ения\", help_text=\"Отправлять email-уведомления о контейнерах\") # Единый баланс (новая система) balance = models.DecimalField(max_digits=15, decimal_places=2, default=0.00, verbose_name=\"Баланс\", help_text=\"Положительный = переплата, отрицательный = долг\") balance_updated_at = models.DateTimeField(auto_now=True, verbose_name=\"Баланс обновлен\") objects = OptimizedClientManager() class Meta: verbose_name = \"Клиент\" verbose_name_plural = \"Клиенты\" def __str__(self): return self.name def get_notification_emails(self): \"\"\" Возвращает список всех заполненных email-адресов для уведомлений. Пустые и None значения исключаются. \"\"\" emails = [] for field in [self.email, self.email2, self.email3, self.email4]: if field and field.strip(): emails.append(field.strip()) return emails def has_notification_emails(self): \"\"\"Проверяет, есть ли хотя бы один email для уведомлений\"\"\" return len(self.get_notification_emails()) > 0 @property def balance_status(self): \"\"\"Статус баланса для отображения\"\"\" if self.balance > 0: return \"ПЕРЕПЛАТА\" elif self.balance < 0: return \"ДОЛГ\" return \"БАЛАНС\" @property def balance_color(self): \"\"\"Цвет для отображения баланса\"\"\" if self.balance > 0: return \"#28a745\" # зеле", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": ".balance > 0: return \"ПЕРЕПЛАТА\" elif self.balance < 0: return \"ДОЛГ\" return \"БАЛАНС\" @property def balance_color(self): \"\"\"Цвет для отображения баланса\"\"\" if self.balance > 0: return \"#28a745\" # зеленый для переплаты elif self.balance < 0: return \"#dc3545\" # красный для долга return \"#6c757d\" # серый для нуля class Warehouse(models.Model): name = models.CharField(max_length=100, verbose_name=\"Название склада\") address = models.CharField(max_length=300, blank=True, verbose_name=\"Адрес склада\") # Единый баланс (новая система) balance = models.DecimalField(max_digits=15, decimal_places=2, default=0.00, verbose_name=\"Баланс\", help_text=\"Положительный = нам должны, отрицательный = мы должны\") balance_updated_at = models.DateTimeField(auto_now=True, verbose_name=\"Баланс обновлен\") # Цены на услуги default_unloading_fee = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Цена за разгрузку\") free_days = models.PositiveIntegerField(default=0, verbose_name=\"Бесплатные дни\") # УДАЛЕНО: rate - ставка за хранение теперь берётся из услуги \"Хранение\" (WarehouseService) complex_fee = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Комплекс", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "е дни\") # УДАЛЕНО: rate - ставка за хранение теперь берётся из услуги \"Хранение\" (WarehouseService) complex_fee = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Комплекс\",validators=[MinValueValidator(0)]) delivery_to_warehouse = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Доставка до склада\") loading_on_trawl = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Погрузка на трал\") documents_fee = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Документы\") transfer_fee = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Плата за передачу\") transit_declaration = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Транзитная декл.\") export_declaration = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Экспортная декл.\") additional_expenses = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Доп.расходы\") objects = OptimizedWarehouseManager() class Meta: verbose_name = \"Склад\" verbose_name_plural = \"Склады\" def __str__(self): return self.name # Контейнеры c", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "ces=2, default=0, verbose_name=\"Доп.расходы\") objects = OptimizedWarehouseManager() class Meta: verbose_name = \"Склад\" verbose_name_plural = \"Склады\" def __str__(self): return self.name # Контейнеры class ContainerManager(BaseManager): def update_related(self, instance): cars = instance.container_cars.all() if not cars: return ths_per_car = (instance.ths or 0) / cars.count() for car in cars: car.sync_with_container(instance, ths_per_car) car.save() class Container(models.Model): STATUS_CHOICES = [ ('FLOATING', 'В пути'), ('IN_PORT', 'В порту'), ('UNLOADED', 'Разгружен'), ('TRANSFERRED', 'Передан'), ] def get_status_color(self): return STATUS_COLORS.get(self.status, '#3a8c3d') # Темнее зелёного по умолчанию CUSTOMS_PROCEDURE_CHOICES = ( ('TRANSIT', 'Транзит'), ('IMPORT', 'Импорт'), ('REEXPORT', 'Реэкспорт'), ('EXPORT', 'Экспорт'), ) number = models.CharField(max_length=100, unique=True, verbose_name=\"Номер контейнера\") status = models.CharField(max_length=50, choices=STATUS_CHOICES, default='FLOATING', verbose_name=\"Статус\") line = models.ForeignKey('Line', on_delete=models.SET_NULL, null=True, blank=True, verbose_name=\"Морская линия\") eta = models.DateField(null=True, blank=True, v", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "ault='FLOATING', verbose_name=\"Статус\") line = models.ForeignKey('Line', on_delete=models.SET_NULL, null=True, blank=True, verbose_name=\"Морская линия\") eta = models.DateField(null=True, blank=True, verbose_name=\"ETA\") client = models.ForeignKey('Client', on_delete=models.SET_NULL, null=True, blank=True, verbose_name=\"Клиент\") customs_procedure = models.CharField(max_length=20, choices=CUSTOMS_PROCEDURE_CHOICES, null=True, blank=True, verbose_name=\"Таможенная процедура\") THS_PAYER_CHOICES = [ ('LINE', 'Напрямую линии'), ('WAREHOUSE', 'Через склад'), ] ths = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Оплата линиям\", validators=[MinValueValidator(0)]) ths_payer = models.CharField(max_length=20, choices=THS_PAYER_CHOICES, default='LINE', verbose_name=\"Оплата THS через\", help_text=\"От чьего имени записать расход THS в карточках ТС: напрямую линии или через склад\") sklad = models.DecimalField(max_digits=10, decimal_places=2, default=160, verbose_name=\"Оплата складу\", validators=[MinValueValidator(0)]) dekl = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Декларация\", validators=[MinValueValidator(0", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "e_name=\"Оплата складу\", validators=[MinValueValidator(0)]) dekl = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Декларация\", validators=[MinValueValidator(0)]) proft = models.DecimalField(max_digits=10, decimal_places=2, default=20, verbose_name=\"Наценка\", validators=[MinValueValidator(0)]) warehouse = models.ForeignKey('Warehouse', on_delete=models.SET_NULL, null=True, blank=True, verbose_name=\"Склад\") planned_unload_date = models.DateField(null=True, blank=True, verbose_name=\"Будем разгружать\", help_text=\"Укажите когда планируете разгружать контейнер (клиенты получат уведомление)\") unload_date = models.DateField(null=True, blank=True, verbose_name=\"Дата разгрузки\") unloaded_status_at = models.DateTimeField( null=True, blank=True, verbose_name=\"Статус 'Разгружен' с\", help_text=\"Когда контейнер получил статус 'Разгружен' (для задержки синхронизации фото)\" ) free_days = models.PositiveIntegerField(default=0, verbose_name=\"Бесплатные дни\") days = models.PositiveIntegerField(default=0, verbose_name=\"Платные дни\") rate = models.DecimalField(max_digits=10, decimal_places=2, default=5, verbose_name=\"Ставка\", validators=[MinValueValidator(0)]) s", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": " = models.PositiveIntegerField(default=0, verbose_name=\"Платные дни\") rate = models.DecimalField(max_digits=10, decimal_places=2, default=5, verbose_name=\"Ставка\", validators=[MinValueValidator(0)]) storage_cost = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Складирование\") notes = models.CharField(max_length=200, blank=True, verbose_name=\"Примечания\") # Google Drive integration google_drive_folder_url = models.URLField(max_length=500, blank=True, verbose_name=\"Google Drive папка\", help_text=\"Прямая ссылка на папку с фотографиями контейнера в Google Drive\") objects = OptimizedContainerManager() # Сохраняем старый менеджер для совместимости legacy_objects = ContainerManager() def update_days_and_storage(self): if self.status == 'UNLOADED' and self.unload_date: total_days = (timezone.now().date() - self.unload_date).days + 1 self.days = max(0, total_days - self.free_days) self.storage_cost = self.days * (self.rate or 0) else: self.days = 0 self.storage_cost = 0 def sync_cars(self): self.update_days_and_storage() Container.objects.update_related(self) def save(self, *args, **kwargs): if self.status == 'UNLOADED' and (not self.warehouse or not self.unlo", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "st = 0 def sync_cars(self): self.update_days_and_storage() Container.objects.update_related(self) def save(self, *args, **kwargs): if self.status == 'UNLOADED' and (not self.warehouse or not self.unload_date): raise ValueError(\"Для статуса 'Разгружен' обязательны поля 'Склад' и 'Дата разгрузки'\") super().save(*args, **kwargs) def sync_cars_after_warehouse_change(self): \"\"\" Применяет новый склад ко всем авто контейнера: - ставит warehouse - жёстко перезаписывает все складские поля дефолтами нового склада - дата разгрузки ВСЕГДА наследуется из контейнера (принудительно) - пересчитывает хранение и суммы \"\"\" # Проверяем, что у экземпляра есть первичный ключ if not self.pk: return for car in self.container_cars.all(): car.warehouse = self.warehouse car.apply_warehouse_defaults(force=True) # перезаписать rate/free_days и прочее # Дата разгрузки ВСЕГДА наследуется из контейнера (принудительно) if self.unload_date: car.unload_date = self.unload_date logger.debug(f\"Car {car.vin}: forced unload_date={self.unload_date} from container {self.number}\") car.update_days_and_storage() car.calculate_total_price() car.save() def sync_cars_after_edit(self): \"\"\" Обновляет поля машин после изменения кон", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "date={self.unload_date} from container {self.number}\") car.update_days_and_storage() car.calculate_total_price() car.save() def sync_cars_after_edit(self): \"\"\" Обновляет поля машин после изменения контейнера: — проставляет склад/клиента, если у авто они пустые, — дата разгрузки ВСЕГДА берется из контейнера (принудительное наследование), — подтягивает дефолты склада (rate/free_days/и т.д.) при пустых/дефолтных значениях, — пересчитывает хранение и цены. \"\"\" # Проверяем, что у экземпляра есть первичный ключ if not self.pk: return from .models import Car # если файл общий, импорт не обязателен for car in self.container_cars.all(): changed = False # базовые связки if not car.warehouse and self.warehouse: car.warehouse = self.warehouse changed = True if not car.client and self.client: car.client = self.client changed = True # Дата разгрузки ВСЕГДА наследуется из контейнера (принудительно) if self.unload_date: if car.unload_date != self.unload_date: car.unload_date = self.unload_date changed = True logger.info(f\"Car {car.vin}: forced unload_date update to {self.unload_date} from container {self.number}\") # подтянуть дефолты со склада (перезаписать только пустые/дефолтные) if car.warehous", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": " = True logger.info(f\"Car {car.vin}: forced unload_date update to {self.unload_date} from container {self.number}\") # подтянуть дефолты со склада (перезаписать только пустые/дефолтные) if car.warehouse: before_rate = car.rate before_free = car.free_days car.apply_warehouse_defaults(override_on_defaults=True) changed = changed or (car.rate != before_rate or car.free_days != before_free) # пересчёт car.update_days_and_storage() car.calculate_total_price() if changed: car.save() # сохранит и отправит WS-обновление, если у тебя это в save() else: # всё равно сохраним, если изменилась стоимость/дни из-за новой даты car.save(update_fields=['storage_cost', 'days', 'total_price']) def check_and_update_status_from_cars(self): \"\"\"Проверяет статус всех автомобилей в контейнере и обновляет статус контейнера\"\"\" if not self.pk: return cars = self.container_cars.all() if not cars.exists(): return # Проверяем, все ли автомобили имеют статус \"Передан\" all_transferred = all(car.status == 'TRANSFERRED' for car in cars) if all_transferred and self.status != 'TRANSFERRED': self.status = 'TRANSFERRED' self.save(update_fields=['status']) logger.info(f\"Container {self.number} status automatically changed ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "or car in cars) if all_transferred and self.status != 'TRANSFERRED': self.status = 'TRANSFERRED' self.save(update_fields=['status']) logger.info(f\"Container {self.number} status automatically changed to TRANSFERRED\") def __str__(self): return self.number class Meta: verbose_name = \"Контейнер\" verbose_name_plural = \"Контейнеры\" indexes = [ models.Index(fields=['status']), models.Index(fields=['client', 'status']), models.Index(fields=['warehouse', 'status']), models.Index(fields=['line']), models.Index(fields=['eta']), models.Index(fields=['unload_date']), ] # Автомобили class CarManager(BaseManager): pass class Car(models.Model): # Типы транспортных средств (расширенный список) VEHICLE_TYPE_CHOICES = [ ('SEDAN', 'Легковой'), ('CROSSOVER', 'Кроссовер'), ('SUV', 'Джип'), ('PICKUP', 'Пикап'), ('NEW_CAR', 'Новая машина'), ('MOTO', 'Мотоцикл'), ('BIG_MOTO', 'Большой мотоцикл'), ('ATV', 'Квадроцикл/Багги'), ('BOAT', 'Лодка'), ('RV', 'Автодом (RV)'), ('CONSTRUCTION', 'Стр. техника'), ] year = models.PositiveIntegerField(verbose_name=\"Год выпуска\") brand = models.CharField(max_length=50, verbose_name=\"Марка\") vehicle_type = models.CharField(max_length=20, choices=VEHICLE_TYPE_CHOICES, defa", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": " models.PositiveIntegerField(verbose_name=\"Год выпуска\") brand = models.CharField(max_length=50, verbose_name=\"Марка\") vehicle_type = models.CharField(max_length=20, choices=VEHICLE_TYPE_CHOICES, default='SEDAN', verbose_name=\"Тип ТС\") vin = models.CharField(max_length=17, unique=True, verbose_name=\"VIN\") client = models.ForeignKey('Client', on_delete=models.SET_NULL, null=True, blank=True, verbose_name=\"Клиент\") status = models.CharField(max_length=20, choices=Container.STATUS_CHOICES, verbose_name=\"Статус\") warehouse = models.ForeignKey('Warehouse', on_delete=models.SET_NULL, null=True, blank=True, verbose_name=\"Склад\") line = models.ForeignKey('Line', on_delete=models.SET_NULL, null=True, blank=True, verbose_name=\"Линия\") carrier = models.ForeignKey('Carrier', on_delete=models.SET_NULL, null=True, blank=True, verbose_name=\"Перевозчик\") unload_date = models.DateField(null=True, blank=True, verbose_name=\"Дата разгрузки\") transfer_date = models.DateField(null=True, blank=True, verbose_name=\"Дата передачи\") has_title = models.BooleanField(default=False, verbose_name=\"Т\") title_notes = models.CharField(max_length=200, blank=True, verbose_name=\"Примечания к тайтлу\") total_price = mode", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "name=\"Дата передачи\") has_title = models.BooleanField(default=False, verbose_name=\"Т\") title_notes = models.CharField(max_length=200, blank=True, verbose_name=\"Примечания к тайтлу\") total_price = models.DecimalField(max_digits=10, decimal_places=2, default=0.00, verbose_name=\"Цена\") # УДАЛЕНО: current_price - теперь используется только total_price storage_cost = models.DecimalField(max_digits=10, decimal_places=2, default=0.00, verbose_name=\"Складирование\") days = models.PositiveIntegerField(default=0, verbose_name=\"Платные дни\") container = models.ForeignKey('Container', on_delete=models.CASCADE, related_name=\"container_cars\", null=True, blank=True, verbose_name=\"Контейнер\") # Расходы ths = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Оплата линиям\", validators=[MinValueValidator(0)]) unload_fee = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Цена за разгрузку\", validators=[MinValueValidator(0)]) delivery_fee = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Доставка до склада\", validators=[MinValueValidator(0)]) loading_fee = models.DecimalField(max_d", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "delivery_fee = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Доставка до склада\", validators=[MinValueValidator(0)]) loading_fee = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Погрузка на трал\", validators=[MinValueValidator(0)]) docs_fee = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Документы\", validators=[MinValueValidator(0)]) transfer_fee = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Плата за передачу\", validators=[MinValueValidator(0)]) transit_declaration = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Транзитная декл.\", validators=[MinValueValidator(0)]) export_declaration = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Экспортная декл.\", validators=[MinValueValidator(0)]) extra_costs = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Доп.расходы\", validators=[MinValueValidator(0)]) dekl = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbos", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "ts=10, decimal_places=2, null=True, blank=True, verbose_name=\"Доп.расходы\", validators=[MinValueValidator(0)]) dekl = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Декларация\", validators=[MinValueValidator(0)]) proft = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('20.00'), null=True, blank=True, verbose_name=\"Наценка\", validators=[MinValueValidator(0)]) hide_markup_in = models.ForeignKey( 'CarService', on_delete=models.SET_NULL, null=True, blank=True, related_name='cars_with_hidden_markup', verbose_name=\"Скрыть наценку в услуге\", help_text=\"Выберите услугу, в которую добавить наценку (вместо отдельной строки в инвойсе)\" ) free_days = models.PositiveIntegerField(default=0, verbose_name=\"Бесплатные дни\") rate = models.DecimalField(max_digits=10, decimal_places=2, default=5, verbose_name=\"Ставка за сутки\", validators=[MinValueValidator(0)]) complex_fee = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Комплекс\", validators=[MinValueValidator(0)]) price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Цена\", validators=[MinValueValida", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "nk=True, verbose_name=\"Комплекс\", validators=[MinValueValidator(0)]) price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Цена\", validators=[MinValueValidator(0)]) auction_fee = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Аукционный сбор\", validators=[MinValueValidator(0)]) transport_usa = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Транспорт США\", validators=[MinValueValidator(0)]) ocean_freight = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Океанский фрахт\", validators=[MinValueValidator(0)]) transport_kz = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Транспорт КЗ\", validators=[MinValueValidator(0)]) broker_fee = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Брокерский сбор\", validators=[MinValueValidator(0)]) additional_expenses = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Дополнительные расходы\", validators=[MinValueValidator(0)]) objects = OptimizedCarManager() # С", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "nal_expenses = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Дополнительные расходы\", validators=[MinValueValidator(0)]) objects = OptimizedCarManager() # Сохраняем старый менеджер для совместимости legacy_objects = CarManager() def get_status_color(self): return STATUS_COLORS.get(self.status, '#3a8c3d') def apply_warehouse_defaults(self, force: bool = False): \"\"\" Копирует дефолты со склада в авто из кастомных услуг. force=True — перезаписывает ВСЕ соответствующие поля значениями склада. force=False — перезаписывает только если поле пустое или равно дефолту модели. \"\"\" if not self.warehouse: return from decimal import Decimal # Получаем кастомные услуги склада warehouse_services = WarehouseService.objects.filter(warehouse=self.warehouse, is_active=True) # Маппинг названий услуг на поля автомобиля service_mapping = { 'Цена за разгрузку': 'unload_fee', 'Доставка до склада': 'delivery_fee', 'Погрузка на трал': 'loading_fee', 'Документы': 'docs_fee', 'Плата за передачу': 'transfer_fee', 'Транзитная декл.': 'transit_declaration', 'Экспортная декл.': 'export_declaration', 'Доп.расходы': 'extra_costs', 'Комплекс': 'complex_fee', 'Ставка за сутки", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "ee', 'Плата за передачу': 'transfer_fee', 'Транзитная декл.': 'transit_declaration', 'Экспортная декл.': 'export_declaration', 'Доп.расходы': 'extra_costs', 'Комплекс': 'complex_fee', 'Ставка за сутки': 'rate', 'Бесплатные дни': 'free_days', } for service in warehouse_services: car_field = service_mapping.get(service.name) if car_field: wh_val = service.default_price or 0 cur_val = getattr(self, car_field, None) if force: setattr(self, car_field, wh_val) else: if cur_val is None: setattr(self, car_field, wh_val) else: try: cur = Decimal(str(cur_val)) if cur == 0: setattr(self, car_field, wh_val) else: model_default = self._meta.get_field(car_field).default mdl = Decimal(str(model_default or 0)) if cur == mdl: setattr(self, car_field, wh_val) except Exception: setattr(self, car_field, wh_val) def warehouse_details(self): \"\"\"Возвращает дефолтные цены на услуги из склада из кастомных услуг.\"\"\" if not self.warehouse: return {\"message\": \"Склад не назначен\"} # Получаем кастомные услуги склада warehouse_services = WarehouseService.objects.filter(warehouse=self.warehouse, is_active=True) details = {\"Название\": self.warehouse.name} for service in warehouse_services: details[service.name] = ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "а warehouse_services = WarehouseService.objects.filter(warehouse=self.warehouse, is_active=True) details = {\"Название\": self.warehouse.name} for service in warehouse_services: details[service.name] = str(service.default_price) return details def set_initial_warehouse_values(self): \"\"\"Подтягивает дефолты со склада при создании авто. Если текущее значение = модельному дефолту (например, rate=5) или 0 — берём значение со склада. \"\"\" if not self.warehouse: return initializing = self._state.adding def _override(cur_val, field_name, wh_val): if cur_val is None: return wh_val if initializing: # перетираем, если 0 или равно модельному дефолту try: cur = Decimal(str(cur_val)) if cur == 0: return wh_val model_default = self._meta.get_field(field_name).default mdl = Decimal(str(model_default or 0)) if cur == mdl: return wh_val except Exception: return wh_val return cur_val # ключевые поля (rate удалён - ставка теперь берётся из услуги \"Хранение\") self.free_days = _override(self.free_days, 'free_days', self.warehouse.free_days or 0) # заодно остальные складские услуги, если нужно self.unload_fee = _override(self.unload_fee, 'unload_fee', self.warehouse.default_unloading_fee or 0) self.delivery", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "ays', self.warehouse.free_days or 0) # заодно остальные складские услуги, если нужно self.unload_fee = _override(self.unload_fee, 'unload_fee', self.warehouse.default_unloading_fee or 0) self.delivery_fee = _override(self.delivery_fee, 'delivery_fee', self.warehouse.delivery_to_warehouse or 0) self.loading_fee = _override(self.loading_fee, 'loading_fee', self.warehouse.loading_on_trawl or 0) self.docs_fee = _override(self.docs_fee, 'docs_fee', self.warehouse.documents_fee or 0) self.transfer_fee = _override(self.transfer_fee, 'transfer_fee', self.warehouse.transfer_fee or 0) self.transit_declaration = _override(self.transit_declaration, 'transit_declaration', self.warehouse.transit_declaration or 0) self.export_declaration = _override(self.export_declaration, 'export_declaration', self.warehouse.export_declaration or 0) self.extra_costs = _override(self.extra_costs, 'extra_costs', self.warehouse.additional_expenses or 0) self.complex_fee = _override(self.complex_fee, 'complex_fee', self.warehouse.complex_fee or 0) def calculate_total_price(self): \"\"\"Пересчитывает цену используя систему услуг CarService. Цена = сумма всех услуг + сумма всех скрытых наценок. ВАЖНО: total_price включа", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "f.warehouse.complex_fee or 0) def calculate_total_price(self): \"\"\"Пересчитывает цену используя систему услуг CarService. Цена = сумма всех услуг + сумма всех скрытых наценок. ВАЖНО: total_price включает скрытую наценку (markup_amount)! Это полная сумма, которую заплатит клиент. \"\"\" from django.db.models import Sum # Сбрасываем кэш related objects чтобы получить актуальные услуги из БД if hasattr(self, '_prefetched_objects_cache'): self._prefetched_objects_cache.pop('car_services', None) # Сначала обновляем дни и цену услуги \"Хранение\" self.update_days_and_storage() # Получаем суммы по поставщикам из CarService (final_price = базовая цена БЕЗ наценки) line_total = self.get_services_total_by_provider('LINE') carrier_total = self.get_services_total_by_provider('CARRIER') warehouse_total = self.get_warehouse_services_total() # Включает услугу \"Хранение\" company_total = self.get_services_total_by_provider('COMPANY') # Сумма всех скрытых наценок distributed_markup = self.car_services.aggregate(total=Sum('markup_amount'))['total'] or Decimal('0') # Общая сумма = услуги + скрытые наценки self.total_price = line_total + warehouse_total + carrier_total + company_total + distributed_markup re", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "te(total=Sum('markup_amount'))['total'] or Decimal('0') # Общая сумма = услуги + скрытые наценки self.total_price = line_total + warehouse_total + carrier_total + company_total + distributed_markup return self.total_price def update_days_and_storage(self): \"\"\"Обновляет платные дни и стоимость хранения для автомобиля. Цена за день берётся из услуги \"Хранение\" в списке услуг склада. Стоимость = платные_дни × цена_за_день \"\"\" if not self.unload_date or not self.warehouse: self.days = 0 self.storage_cost = Decimal('0.00') self._update_storage_service_price() return # Бесплатные дни из настроек склада free_days = int(self.warehouse.free_days or 0) end_date = self.transfer_date if self.status == 'TRANSFERRED' and self.transfer_date else timezone.now().date() total_days = (end_date - self.unload_date).days + 1 self.days = max(0, total_days - free_days) # Получаем ставку из услуги \"Хранение\" daily_rate = self._get_storage_daily_rate() self.storage_cost = Decimal(str(self.days)) * daily_rate # Обновляем цену услуги \"Хранение\" в CarService self._update_storage_service_price() def _get_storage_daily_rate(self): \"\"\"Получает ставку хранения за день из услуги 'Хранение' склада.\"\"\" if not self.wa", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "Обновляем цену услуги \"Хранение\" в CarService self._update_storage_service_price() def _get_storage_daily_rate(self): \"\"\"Получает ставку хранения за день из услуги 'Хранение' склада.\"\"\" if not self.warehouse: return Decimal('0.00') try: storage_service = WarehouseService.objects.filter( warehouse=self.warehouse, name='Хранение', is_active=True ).first() if storage_service: return Decimal(str(storage_service.default_price or 0)) except Exception: pass return Decimal('0.00') def _update_storage_service_price(self): \"\"\"Обновляет цену услуги 'Хранение' в CarService. Цена = платные_дни × ставка_за_день (из WarehouseService) ВАЖНО: markup_amount НЕ обновляется автоматически! Наценка устанавливается только при создании услуги (из default_markup) или вручную пользователем в админке. \"\"\" if not self.pk or not self.warehouse: return try: # Находим услугу \"Хранение\" для этого склада storage_service = WarehouseService.objects.filter( warehouse=self.warehouse, name='Хранение', is_active=True ).first() if storage_service: days = Decimal(str(self.days)) # Стоимость = платные_дни × цена_за_день storage_price = days * Decimal(str(storage_service.default_price or 0)) # Обновляем ТОЛЬКО цену в CarSer", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "t() if storage_service: days = Decimal(str(self.days)) # Стоимость = платные_дни × цена_за_день storage_price = days * Decimal(str(storage_service.default_price or 0)) # Обновляем ТОЛЬКО цену в CarService (markup_amount не трогаем!) # Наценка устанавливается при создании услуги или вручную в админке from core.models import CarService CarService.objects.filter( car=self, service_type='WAREHOUSE', service_id=storage_service.id ).update(custom_price=storage_price) # Сбрасываем prefetch кэш чтобы получить актуальные данные if hasattr(self, '_prefetched_objects_cache'): self._prefetched_objects_cache.pop('car_services', None) except Exception: pass # Игнорируем ошибки - модель может быть ещё не сохранена def sync_with_container(self, container, ths_per_car): \"\"\"Синхронизирует данные автомобиля с контейнером.\"\"\" self.status = container.status self.warehouse = container.warehouse self.unload_date = container.unload_date self.transfer_date = timezone.now().date() if container.status == 'TRANSFERRED' else None self.ths = ths_per_car self.dekl = container.dekl self.proft = container.proft self.set_initial_warehouse_values() self.update_days_and_storage() self.calculate_total_price() WAREHOUS", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "ERRED' else None self.ths = ths_per_car self.dekl = container.dekl self.proft = container.proft self.set_initial_warehouse_values() self.update_days_and_storage() self.calculate_total_price() WAREHOUSE_FEE_FIELDS = ( 'unload_fee', # цена за разгрузку 'delivery_fee', # доставка до склада 'loading_fee', # погрузка на трал 'docs_fee', # документы 'transfer_fee', # плата за передачу 'transit_declaration', # транзитная декл. 'export_declaration', # экспортная декл. 'extra_costs', # доп.расходы 'complex_fee', # комплекс ) def warehouse_payment_amount(self) -> Decimal: \"\"\"Сколько должны складу за услуги (без учёта хранения) - использует новую систему услуг.\"\"\" return self.get_warehouse_services_total() @property def warehouse_payment(self) -> Decimal: # удобное свойство, если где-то понадобится return self.warehouse_payment_amount() def get_line_services(self): \"\"\"Получает услуги линии для этого автомобиля\"\"\" if not self.line or not self.pk: return self.car_services.none() # Получаем ID услуг линии line_service_ids = LineService.objects.only('id').filter(line=self.line).values_list('id', flat=True) return self.car_services.filter(service_type='LINE', service_id__in=line_service_ids) def g", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": " линии line_service_ids = LineService.objects.only('id').filter(line=self.line).values_list('id', flat=True) return self.car_services.filter(service_type='LINE', service_id__in=line_service_ids) def get_carrier_services(self): \"\"\"Получает услуги перевозчика для этого автомобиля\"\"\" if not self.carrier or not self.pk: return self.car_services.none() # Получаем ID услуг перевозчика carrier_service_ids = CarrierService.objects.only('id').filter(carrier=self.carrier).values_list('id', flat=True) return self.car_services.filter(service_type='CARRIER', service_id__in=carrier_service_ids) def get_company_services(self): \"\"\"Получает услуги компаний для этого автомобиля\"\"\" if not self.pk: return self.car_services.none() return self.car_services.filter(service_type='COMPANY') def get_warehouse_services(self): \"\"\"Получает все услуги складов для этого автомобиля (включая услуги от других складов)\"\"\" if not self.pk: return self.car_services.none() # Получаем ВСЕ услуги складов, привязанные к этому автомобилю return self.car_services.filter(service_type='WAREHOUSE') def get_services_total_by_provider(self, provider_type): \"\"\"Получает общую стоимость услуг по типу поставщика. Для склада: стоимость", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "втомобилю return self.car_services.filter(service_type='WAREHOUSE') def get_services_total_by_provider(self, provider_type): \"\"\"Получает общую стоимость услуг по типу поставщика. Для склада: стоимость хранения уже включена в услугу \"Хранение\" (CarService). \"\"\" total = Decimal('0.00') if provider_type == 'LINE' and self.line: services = self.get_line_services() elif provider_type == 'CARRIER' and self.carrier: services = self.get_carrier_services() elif provider_type == 'COMPANY': services = self.get_company_services() elif provider_type == 'WAREHOUSE' and self.warehouse: services = self.get_warehouse_services() else: return total for service in services: total += Decimal(str(service.final_price)) return total def get_warehouse_services_total(self): \"\"\"Получает стоимость только услуг склада (без хранения)\"\"\" if not self.warehouse: return Decimal('0.00') services = self.get_warehouse_services() total = Decimal('0.00') for service in services: total += Decimal(str(service.final_price)) return total def calculate_storage_cost(self): \"\"\"Рассчитывает стоимость хранения на складе. Ставка берётся из услуги \"Хранение\" в списке услуг склада. \"\"\" if not self.warehouse or not self.unload_date:", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "turn total def calculate_storage_cost(self): \"\"\"Рассчитывает стоимость хранения на складе. Ставка берётся из услуги \"Хранение\" в списке услуг склада. \"\"\" if not self.warehouse or not self.unload_date: return Decimal('0.00') # Получаем ставку из услуги \"Хранение\" и бесплатные дни со склада daily_rate = self._get_storage_daily_rate() free_days = self.warehouse.free_days or 0 # Рассчитываем общее количество дней хранения # Включаем день разгрузки и день забора авто end_date = self.transfer_date if self.status == 'TRANSFERRED' and self.transfer_date else timezone.now().date() total_days = (end_date - self.unload_date).days + 1 # Рассчитываем платные дни (общие дни минус бесплатные) chargeable_days = max(0, total_days - free_days) # Рассчитываем стоимость storage_cost = daily_rate * chargeable_days return storage_cost def get_rates_by_provider(self, provider_type): \"\"\"Получает ставки по типу поставщика\"\"\" rates = [] if provider_type == 'LINE' and self.line: services = self.get_line_services() elif provider_type == 'CARRIER' and self.carrier: services = self.get_carrier_services() elif provider_type == 'WAREHOUSE' and self.warehouse: services = self.get_warehouse_services() else: return ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "() elif provider_type == 'CARRIER' and self.carrier: services = self.get_carrier_services() elif provider_type == 'WAREHOUSE' and self.warehouse: services = self.get_warehouse_services() else: return rates # Пока возвращаем пустой список (когда добавим service_type, изменим логику) return rates def get_parameters_by_provider(self, provider_type): \"\"\"Получает параметры расчета по типу поставщика\"\"\" parameters = [] if provider_type == 'LINE' and self.line: services = self.get_line_services() elif provider_type == 'CARRIER' and self.carrier: services = self.get_carrier_services() elif provider_type == 'WAREHOUSE' and self.warehouse: services = self.get_warehouse_services() else: return parameters # Пока возвращаем пустой список (когда добавим service_type, изменим логику) return parameters def save(self, *args, **kwargs): # подхватить данные с контейнера ДО копирования дефолтов # Проверяем, что у контейнера есть первичный ключ if not self.warehouse and self.container and self.container.pk and self.container.warehouse: self.warehouse = self.container.warehouse # Дата разгрузки ВСЕГДА берется из контейнера (принудительное наследование) if self.container and self.container.pk and self.co", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": " and self.container.warehouse: self.warehouse = self.container.warehouse # Дата разгрузки ВСЕГДА берется из контейнера (принудительное наследование) if self.container and self.container.pk and self.container.unload_date: self.unload_date = self.container.unload_date if self.transfer_date and self.status != 'TRANSFERRED': self.status = 'TRANSFERRED' # на создании — тянем дефолты склада (в т.ч. rate/free_days) ДО первого save() if self.pk is None and self.warehouse: try: self.set_initial_warehouse_values() except Exception as e: logger.error(f\"Failed to set initial warehouse values for car {self.vin}: {e}\") if self.status == 'TRANSFERRED' and not self.transfer_date: from django.utils import timezone self.transfer_date = timezone.now().date() # Сохраняем объект сначала, чтобы получить pk super().save(*args, **kwargs) # пересчёт ПОСЛЕ сохранения, когда у объекта уже есть pk try: old_total_price = self.total_price self.calculate_total_price() # Сохраняем еще раз с пересчитанной ценой, только если цена изменилась if self.total_price != old_total_price: super().save(update_fields=['total_price']) except Exception as e: logger.error(f\"Failed to calculate total price for car {self.vin}: {e}", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "о если цена изменилась if self.total_price != old_total_price: super().save(update_fields=['total_price']) except Exception as e: logger.error(f\"Failed to calculate total price for car {self.vin}: {e}\") # Обновляем связанные объекты только если у автомобиля есть первичный ключ if self.pk: try: Car.objects.update_related(self) except Exception as e: logger.error(f\"Failed to update related objects for car {self.id}: {e}\") # Проверяем и обновляем статус контейнера, если все автомобили переданы if self.container and self.container.pk: try: self.container.check_and_update_status_from_cars() except Exception as e: logger.error(f\"Failed to check container status for car {self.id}: {e}\") def _notify(): try: channel_layer = get_channel_layer() async_to_sync(channel_layer.group_send)( \"updates\", { \"type\": \"data_update\", \"data\": { \"model\": \"Car\", \"id\": self.id, \"status\": self.status, \"storage_cost\": str(self.storage_cost), \"days\": self.days, \"price\": str(self.total_price), }, }, ) except Exception as e: logger.error(f\"Failed to send WebSocket notification for car {self.id}: {e}\") transaction.on_commit(_notify) def __str__(self): return f\"{self.brand} ({self.vin})\" class Meta: verbose_name = \"", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "n as e: logger.error(f\"Failed to send WebSocket notification for car {self.id}: {e}\") transaction.on_commit(_notify) def __str__(self): return f\"{self.brand} ({self.vin})\" class Meta: verbose_name = \"Автомобиль\" verbose_name_plural = \"Автомобили\" indexes = [ models.Index(fields=['vin']), models.Index(fields=['status']), models.Index(fields=['unload_date', 'transfer_date']), # Дополнительные индексы для оптимизации запросов models.Index(fields=['client', 'status']), models.Index(fields=['warehouse', 'status']), models.Index(fields=['line']), models.Index(fields=['carrier']), models.Index(fields=['container']), models.Index(fields=['unload_date']), models.Index(fields=['transfer_date']), ] class Company(models.Model): \"\"\"Модель для логистической компании Caromoto Lithuania\"\"\" name = models.CharField(max_length=100, default=\"Caromoto Lithuania\", verbose_name=\"Название компании\") # Единый баланс (новая система) balance = models.DecimalField(max_digits=15, decimal_places=2, default=0.00, verbose_name=\"Баланс\", help_text=\"Положительный = нам должны, отрицательный = мы должны\") balance_updated_at = models.DateTimeField(auto_now=True, verbose_name=\"Баланс обновлен\") # Метаданные created_at", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "rbose_name=\"Баланс\", help_text=\"Положительный = нам должны, отрицательный = мы должны\") balance_updated_at = models.DateTimeField(auto_now=True, verbose_name=\"Баланс обновлен\") # Метаданные created_at = models.DateTimeField(auto_now_add=True, verbose_name=\"Дата создания\") updated_at = models.DateTimeField(auto_now=True, verbose_name=\"Дата обновления\") objects = OptimizedCompanyManager() class Meta: verbose_name = \"Компания\" verbose_name_plural = \"Компании\" def __str__(self): return self.name class CompanyService(models.Model): \"\"\"Услуги компаний\"\"\" company = models.ForeignKey(Company, on_delete=models.CASCADE, related_name='services', verbose_name=\"Компания\") name = models.CharField(max_length=200, verbose_name=\"Название услуги\") description = models.TextField(blank=True, verbose_name=\"Описание\") default_price = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Цена по умолчанию\") default_markup = models.DecimalField( max_digits=10, decimal_places=2, default=0, verbose_name=\"Наценка по умолчанию\", help_text=\"Скрытая наценка, которая будет автоматически добавлена при создании услуги для авто\" ) is_active = models.BooleanField(default=True, verbose_name=\"А", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "=0, verbose_name=\"Наценка по умолчанию\", help_text=\"Скрытая наценка, которая будет автоматически добавлена при создании услуги для авто\" ) is_active = models.BooleanField(default=True, verbose_name=\"Активна\") add_by_default = models.BooleanField( default=False, verbose_name=\"Добавлять по умолчанию\", help_text=\"Автоматически добавлять эту услугу при создании автомобиля для этой компании\" ) def __str__(self): return f\"{self.company.name} - {self.name}\" class Meta: verbose_name = \"Услуга компании\" verbose_name_plural = \"Услуги компаний\" # Модели для системы услуг class LineService(models.Model): \"\"\"Услуги морских линий\"\"\" line = models.ForeignKey(Line, on_delete=models.CASCADE, related_name='services', verbose_name=\"Линия\") name = models.CharField(max_length=200, verbose_name=\"Название услуги\") description = models.TextField(blank=True, verbose_name=\"Описание\") default_price = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Цена по умолчанию\") default_markup = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Наценка по умолчанию\", help_text=\"Скрытая наценка, которая будет автоматически добавлена при создании услуги для авто\") ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "= models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Наценка по умолчанию\", help_text=\"Скрытая наценка, которая будет автоматически добавлена при создании услуги для авто\") is_active = models.BooleanField(default=True, verbose_name=\"Активна\") add_by_default = models.BooleanField( default=False, verbose_name=\"Добавлять по умолчанию\", help_text=\"Автоматически добавлять эту услугу при создании автомобиля для этой линии\" ) def __str__(self): return f\"{self.line.name} - {self.name}\" class Meta: verbose_name = \"Услуга линии\" verbose_name_plural = \"Услуги линий\" class CarrierService(models.Model): \"\"\"Услуги перевозчиков\"\"\" carrier = models.ForeignKey(Carrier, on_delete=models.CASCADE, related_name='services', verbose_name=\"Перевозчик\") name = models.CharField(max_length=200, verbose_name=\"Название услуги\") description = models.TextField(blank=True, verbose_name=\"Описание\") default_price = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Цена по умолчанию\") default_markup = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Наценка по умолчанию\", help_text=\"Скрытая наценка, которая будет автоматически добавл", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "Цена по умолчанию\") default_markup = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Наценка по умолчанию\", help_text=\"Скрытая наценка, которая будет автоматически добавлена при создании услуги для авто\") is_active = models.BooleanField(default=True, verbose_name=\"Активна\") add_by_default = models.BooleanField( default=False, verbose_name=\"Добавлять по умолчанию\", help_text=\"Автоматически добавлять эту услугу при создании автомобиля для этого перевозчика\" ) def __str__(self): return f\"{self.carrier.name} - {self.name}\" class Meta: verbose_name = \"Услуга перевозчика\" verbose_name_plural = \"Услуги перевозчиков\" class WarehouseService(models.Model): \"\"\"Услуги складов\"\"\" warehouse = models.ForeignKey(Warehouse, on_delete=models.CASCADE, related_name='services', verbose_name=\"Склад\") name = models.CharField(max_length=200, verbose_name=\"Название услуги\") description = models.TextField(blank=True, verbose_name=\"Описание\") default_price = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Цена по умолчанию\") default_markup = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Наценка по умолчанию\", help_tex", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "digits=10, decimal_places=2, default=0, verbose_name=\"Цена по умолчанию\") default_markup = models.DecimalField(max_digits=10, decimal_places=2, default=0, verbose_name=\"Наценка по умолчанию\", help_text=\"Скрытая наценка, которая будет автоматически добавлена при создании услуги для авто\") is_active = models.BooleanField(default=True, verbose_name=\"Активна\") add_by_default = models.BooleanField(default=False, verbose_name=\"Добавлять по умолчанию\", help_text=\"Автоматически добавлять эту услугу при создании автомобиля на этом складе\") def __str__(self): return f\"{self.warehouse.name} - {self.name}\" class Meta: verbose_name = \"Услуга склада\" verbose_name_plural = \"Услуги складов\" class DeletedCarService(models.Model): \"\"\"Отслеживание удаленных пользователем услуг для конкретного автомобиля\"\"\" car = models.ForeignKey(Car, on_delete=models.CASCADE, related_name='deleted_services', verbose_name=\"Автомобиль\") service_type = models.CharField(max_length=20, choices=[ ('LINE', 'Линия'), ('CARRIER', 'Перевозчик'), ('WAREHOUSE', 'Склад'), ('COMPANY', 'Компания'), ], verbose_name=\"Тип поставщика\") service_id = models.PositiveIntegerField(verbose_name=\"ID услуги\") deleted_at = models.DateTimeField", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": ", 'Перевозчик'), ('WAREHOUSE', 'Склад'), ('COMPANY', 'Компания'), ], verbose_name=\"Тип поставщика\") service_id = models.PositiveIntegerField(verbose_name=\"ID услуги\") deleted_at = models.DateTimeField(auto_now_add=True, verbose_name=\"Дата удаления\") class Meta: unique_together = ['car', 'service_type', 'service_id'] verbose_name = \"Удаленная услуга автомобиля\" verbose_name_plural = \"Удаленные услуги автомобилей\" class CarService(models.Model): \"\"\"Связь автомобиля с услугами и их ценами\"\"\" SERVICE_TYPES = [ ('LINE', 'Линия'), ('CARRIER', 'Перевозчик'), ('WAREHOUSE', 'Склад'), ('COMPANY', 'Компания'), ] car = models.ForeignKey(Car, on_delete=models.CASCADE, related_name='car_services', verbose_name=\"Автомобиль\") service_type = models.CharField(max_length=20, choices=SERVICE_TYPES, verbose_name=\"Тип поставщика\") service_id = models.PositiveIntegerField(verbose_name=\"ID услуги\") custom_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True, verbose_name=\"Индивидуальная цена\") markup_amount = models.DecimalField( max_digits=10, decimal_places=2, default=0, verbose_name=\"Скрытая наценка\", help_text=\"Сумма наценки, которая будет добавлена к цене услуги в инвойс", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "уальная цена\") markup_amount = models.DecimalField( max_digits=10, decimal_places=2, default=0, verbose_name=\"Скрытая наценка\", help_text=\"Сумма наценки, которая будет добавлена к цене услуги в инвойсе (скрыто от клиента)\" ) quantity = models.PositiveIntegerField(default=1, verbose_name=\"Количество\") notes = models.TextField(blank=True, verbose_name=\"Примечания\") created_at = models.DateTimeField(auto_now_add=True, verbose_name=\"Дата создания\") updated_at = models.DateTimeField(auto_now=True, verbose_name=\"Дата обновления\") def __str__(self): return f\"{self.car.vin} - {self.get_service_name()}: {self.final_price}\" def get_service_name(self): \"\"\"Получает название услуги\"\"\" if self.service_type == 'LINE': try: service = LineService.objects.get(id=self.service_id) return service.name except LineService.DoesNotExist: return \"Услуга не найдена\" elif self.service_type == 'CARRIER': try: service = CarrierService.objects.get(id=self.service_id) return service.name except CarrierService.DoesNotExist: return \"Услуга не найдена\" elif self.service_type == 'WAREHOUSE': try: service = WarehouseService.objects.get(id=self.service_id) return service.name except WarehouseService.DoesNotExist: retur", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "Exist: return \"Услуга не найдена\" elif self.service_type == 'WAREHOUSE': try: service = WarehouseService.objects.get(id=self.service_id) return service.name except WarehouseService.DoesNotExist: return \"Услуга не найдена\" elif self.service_type == 'COMPANY': try: service = CompanyService.objects.get(id=self.service_id) return service.name except CompanyService.DoesNotExist: return \"Услуга не найдена\" return \"Неизвестная услуга\" def get_default_price(self): \"\"\"Получает цену по умолчанию\"\"\" if self.service_type == 'LINE': try: service = LineService.objects.get(id=self.service_id) return service.default_price except LineService.DoesNotExist: return 0 elif self.service_type == 'CARRIER': try: service = CarrierService.objects.get(id=self.service_id) return service.default_price except CarrierService.DoesNotExist: return 0 elif self.service_type == 'WAREHOUSE': try: service = WarehouseService.objects.get(id=self.service_id) return service.default_price except WarehouseService.DoesNotExist: return 0 elif self.service_type == 'COMPANY': try: service = CompanyService.objects.get(id=self.service_id) return service.default_price except CompanyService.DoesNotExist: return 0 return 0 @property ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "eturn 0 elif self.service_type == 'COMPANY': try: service = CompanyService.objects.get(id=self.service_id) return service.default_price except CompanyService.DoesNotExist: return 0 return 0 @property def final_price(self): \"\"\"Итоговая цена с учетом количества (БЕЗ скрытой наценки - для внутреннего учёта)\"\"\" # Используем custom_price если он задан (даже если 0), иначе default_price price = self.custom_price if self.custom_price is not None else self.get_default_price() return price * self.quantity @property def invoice_price(self): \"\"\"Цена для инвойса (С учётом скрытой наценки)\"\"\" # Используем custom_price если он задан (даже если 0), иначе default_price base_price = self.custom_price if self.custom_price is not None else self.get_default_price() markup = self.markup_amount or Decimal('0') return (base_price + markup) * self.quantity def get_total_distributed_markup(self): \"\"\"Возвращает сумму распределённой наценки для этого авто\"\"\" if not self.car_id: return Decimal('0') return CarService.objects.filter(car_id=self.car_id).aggregate( total=models.Sum('markup_amount') )['total'] or Decimal('0') class Meta: verbose_name = \"Услуга автомобиля\" verbose_name_plural = \"Услуги автомобилей\"", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "ice.objects.filter(car_id=self.car_id).aggregate( total=models.Sum('markup_amount') )['total'] or Decimal('0') class Meta: verbose_name = \"Услуга автомобиля\" verbose_name_plural = \"Услуги автомобилей\" unique_together = ('car', 'service_type', 'service_id') indexes = [ models.Index(fields=['car', 'service_type']), models.Index(fields=['service_type', 'service_id']), models.Index(fields=['car']), ] # Сигналы для автоматического пересчета текущей цены при изменении услуг from django.db.models.signals import post_save, post_delete from django.dispatch import receiver @receiver(post_save, sender=CarService) def recalculate_car_price_on_service_save(sender, instance, **kwargs): \"\"\"Пересчитывает текущую цену автомобиля при сохранении услуги\"\"\" # Защита от рекурсии - пропускаем если идёт создание услуг if getattr(instance.car, '_creating_services', False): return try: instance.car.calculate_total_price() # Используем update() вместо save() чтобы не триггерить сигналы Car.objects.filter(id=instance.car.id).update( total_price=instance.car.total_price ) except Exception as e: print(f\"Ошибка пересчета цены при сохранении услуги: {e}\") @receiver(post_delete, sender=CarService) def recalculate_", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "ance.car.id).update( total_price=instance.car.total_price ) except Exception as e: print(f\"Ошибка пересчета цены при сохранении услуги: {e}\") @receiver(post_delete, sender=CarService) def recalculate_car_price_on_service_delete(sender, instance, **kwargs): \"\"\"Пересчитывает текущую цену автомобиля при удалении услуги\"\"\" # Защита от рекурсии - пропускаем если идёт создание услуг if getattr(instance.car, '_creating_services', False): return try: instance.car.calculate_total_price() # Используем update() вместо save() чтобы не триггерить сигналы Car.objects.filter(id=instance.car.id).update( total_price=instance.car.total_price ) except Exception as e: print(f\"Ошибка пересчета цены при удалении услуги: {e}\") @receiver(post_save, sender=Car) def recalculate_car_price_on_car_save(sender, instance, **kwargs): \"\"\"Пересчитывает текущую цену автомобиля при изменении полей, влияющих на расчет\"\"\" # Защита от рекурсии if getattr(instance, '_recalculating_price', False): return if getattr(instance, '_creating_services', False): return try: # Пропускаем для новых объектов if hasattr(instance, '_state') and instance._state.adding: return # Пропускаем если это update_fields=['total_price'] - означа", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": "'_creating_services', False): return try: # Пропускаем для новых объектов if hasattr(instance, '_state') and instance._state.adding: return # Пропускаем если это update_fields=['total_price'] - означает что цена уже пересчитана update_fields = kwargs.get('update_fields') if update_fields and 'total_price' in update_fields: return # Устанавливаем флаг защиты от рекурсии instance._recalculating_price = True try: instance.calculate_total_price() # Используем update() вместо save() чтобы не триггерить сигналы Car.objects.filter(id=instance.id).update( total_price=instance.total_price ) finally: instance._recalculating_price = False except Exception as e: print(f\"Ошибка пересчета цены при изменении автомобиля: {e}\") # ============================================================================== # 🎉 НОВАЯ СИСТЕМА ИНВОЙСОВ И ПЛАТЕЖЕЙ # ============================================================================== # Импортируем новые модели, чтобы Django их видел from .models_billing import ( NewInvoice, InvoiceItem, Transaction, SimpleBalanceMixin ) # ============================================================================== # 🌐 МОДЕЛИ ДЛЯ КЛИЕНТСКОГО САЙТА # ========================", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models.py", "content": " NewInvoice, InvoiceItem, Transaction, SimpleBalanceMixin ) # ============================================================================== # 🌐 МОДЕЛИ ДЛЯ КЛИЕНТСКОГО САЙТА # ============================================================================== # Импортируем модели для клиентского портала from .models_website import ( ClientUser, CarPhoto, ContainerPhoto, AIChat, NewsPost, ContactMessage, TrackingRequest )", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "from django.contrib import admin # Импортируем админку для клиентского сайта (упрощённая версия - фото только в карточке контейнера) from .admin_website import ( ClientUserAdmin, AIChatAdmin, NewsPostAdmin, ContactMessageAdmin, TrackingRequestAdmin ) from .models_website import ContainerPhoto from django.utils import timezone from django.urls import reverse from django.utils.html import format_html from django.utils.safestring import mark_safe from django.http import HttpResponseRedirect from django.shortcuts import render from django.core.exceptions import ValidationError from django.db import models from django import forms from decimal import Decimal from .models import Client, Warehouse, Car, Container, Line, Company, Carrier, LineService, CarrierService, WarehouseService, CompanyService, CarService, DeletedCarService from .forms import LineForm, CarrierForm, WarehouseForm from .admin_filters import MultiStatusFilter, MultiWarehouseFilter, ClientAutocompleteFilter # Inline формы для управления услугами прямо в карточках контрагентов class WarehouseServiceInline(admin.TabularInline): model = WarehouseService extra = 1 fields = ('name', 'description', 'default_price', 'default_ma", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "я управления услугами прямо в карточках контрагентов class WarehouseServiceInline(admin.TabularInline): model = WarehouseService extra = 1 fields = ('name', 'description', 'default_price', 'default_markup', 'is_active', 'add_by_default') verbose_name = \"Услуга склада\" verbose_name_plural = \"Услуги склада\" def get_formset(self, request, obj=None, **kwargs): formset = super().get_formset(request, obj, **kwargs) formset.form.base_fields['description'].widget.attrs.update({'rows': 1}) return formset class LineServiceInline(admin.TabularInline): model = LineService extra = 1 fields = ('name', 'description', 'default_price', 'default_markup', 'is_active', 'add_by_default') verbose_name = \"Услуга линии\" verbose_name_plural = \"Услуги линии\" def get_formset(self, request, obj=None, **kwargs): formset = super().get_formset(request, obj, **kwargs) formset.form.base_fields['description'].widget.attrs.update({'rows': 1}) return formset class LineTHSCoefficientInline(admin.TabularInline): \"\"\"Inline для настройки коэффициентов THS для каждого типа ТС Коэффициент определяет \"вес\" типа ТС при распределении THS: - 1.0 = стандартный (легковой) - 2.0 = двойной (джип, RV) - 0.5 = половина (мотоцикл) \"\"", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "для настройки коэффициентов THS для каждого типа ТС Коэффициент определяет \"вес\" типа ТС при распределении THS: - 1.0 = стандартный (легковой) - 2.0 = двойной (джип, RV) - 0.5 = половина (мотоцикл) \"\"\" from .models import LineTHSCoefficient model = LineTHSCoefficient extra = 0 fields = ('vehicle_type', 'coefficient') verbose_name = \"Коэффициент THS для типа ТС\" verbose_name_plural = \"Коэффициенты THS для типов ТС\" def get_extra(self, request, obj=None, **kwargs): \"\"\"Если нет записей - показываем все 11 типов для заполнения\"\"\" if obj and obj.ths_coefficients.exists(): return 0 return 11 # Количество типов ТС class CarrierServiceInline(admin.TabularInline): model = CarrierService extra = 1 fields = ('name', 'description', 'default_price', 'default_markup', 'is_active', 'add_by_default') verbose_name = \"Услуга перевозчика\" verbose_name_plural = \"Услуги перевозчика\" def get_formset(self, request, obj=None, **kwargs): formset = super().get_formset(request, obj, **kwargs) formset.form.base_fields['description'].widget.attrs.update({'rows': 1}) return formset class CompanyServiceInline(admin.TabularInline): model = CompanyService extra = 1 fields = ('name', 'description', 'default_price',", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ields['description'].widget.attrs.update({'rows': 1}) return formset class CompanyServiceInline(admin.TabularInline): model = CompanyService extra = 1 fields = ('name', 'description', 'default_price', 'default_markup', 'is_active', 'add_by_default') verbose_name = \"Услуга компании\" verbose_name_plural = \"Услуги компании\" def get_formset(self, request, obj=None, **kwargs): formset = super().get_formset(request, obj, **kwargs) formset.form.base_fields['description'].widget.attrs.update({'rows': 1}) return formset # Форма для CarServiceInline class CarServiceInlineForm(forms.ModelForm): # Добавляем поле для выбора услуги warehouse_service = forms.ModelChoiceField( queryset=WarehouseService.objects.select_related('warehouse').filter(is_active=True), required=False, label=\"Услуга склада\", help_text=\"Выберите услугу склада\" ) line_service = forms.ModelChoiceField( queryset=LineService.objects.select_related('line').filter(is_active=True), required=False, label=\"Услуга линии\", help_text=\"Выберите услугу линии\" ) carrier_service = forms.ModelChoiceField( queryset=CarrierService.objects.select_related('carrier').filter(is_active=True), required=False, label=\"Услуга перевозчика\", help_text=\"", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "рите услугу линии\" ) carrier_service = forms.ModelChoiceField( queryset=CarrierService.objects.select_related('carrier').filter(is_active=True), required=False, label=\"Услуга перевозчика\", help_text=\"Выберите услугу перевозчика\" ) company_service = forms.ModelChoiceField( queryset=CompanyService.objects.select_related('company').filter(is_active=True), required=False, label=\"Услуга компании\", help_text=\"Выберите услугу компании\" ) class Meta: model = CarService fields = '__all__' def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) # Если редактируем существующую запись, устанавливаем значения if self.instance and self.instance.pk: if self.instance.service_type == 'WAREHOUSE': try: self.fields['warehouse_service'].initial = self.instance.service_id except: pass elif self.instance.service_type == 'LINE': try: self.fields['line_service'].initial = self.instance.service_id except: pass elif self.instance.service_type == 'CARRIER': try: self.fields['carrier_service'].initial = self.instance.service_id except: pass elif self.instance.service_type == 'COMPANY': try: self.fields['company_service'].initial = self.instance.service_id except: pass def save(self, commit=True", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ial = self.instance.service_id except: pass elif self.instance.service_type == 'COMPANY': try: self.fields['company_service'].initial = self.instance.service_id except: pass def save(self, commit=True): instance = super().save(commit=False) # Устанавливаем service_id в зависимости от выбранного типа if instance.service_type == 'WAREHOUSE' and self.cleaned_data.get('warehouse_service'): instance.service_id = self.cleaned_data['warehouse_service'].id elif instance.service_type == 'LINE' and self.cleaned_data.get('line_service'): instance.service_id = self.cleaned_data['line_service'].id elif instance.service_type == 'CARRIER' and self.cleaned_data.get('carrier_service'): instance.service_id = self.cleaned_data['carrier_service'].id elif instance.service_type == 'COMPANY' and self.cleaned_data.get('company_service'): instance.service_id = self.cleaned_data['company_service'].id if commit: instance.save() return instance # Inline для управления дополнительными услугами автомобиля class CarServiceInline(admin.TabularInline): model = CarService form = CarServiceInlineForm extra = 1 can_delete = True fields = ('service_type', 'warehouse_service', 'line_service', 'carrier_service', 'servic", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ServiceInline(admin.TabularInline): model = CarService form = CarServiceInlineForm extra = 1 can_delete = True fields = ('service_type', 'warehouse_service', 'line_service', 'carrier_service', 'service_display', 'warehouse_display', 'custom_price', 'markup_amount', 'quantity', 'final_price_display', 'invoice_price_display', 'notes') readonly_fields = ('service_display', 'warehouse_display', 'final_price_display', 'invoice_price_display') verbose_name = \"Дополнительная услуга\" verbose_name_plural = \"Дополнительные услуги (от других складов/компаний)\" def service_display(self, obj): \"\"\"Отображает название услуги\"\"\" if obj and obj.pk: return obj.get_service_name() return \"-\" service_display.short_description = \"Услуга\" def warehouse_display(self, obj): \"\"\"Отображает склад/компанию для услуги\"\"\" if not obj or not obj.pk: return \"-\" if obj.service_type == 'WAREHOUSE': try: service = WarehouseService.objects.select_related('warehouse').get(id=obj.service_id) return service.warehouse.name except WarehouseService.DoesNotExist: return \"Склад не найден\" elif obj.service_type == 'LINE': try: service = LineService.objects.select_related('line').get(id=obj.service_id) return service.line.name e", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ept WarehouseService.DoesNotExist: return \"Склад не найден\" elif obj.service_type == 'LINE': try: service = LineService.objects.select_related('line').get(id=obj.service_id) return service.line.name except LineService.DoesNotExist: return \"Линия не найдена\" elif obj.service_type == 'CARRIER': try: service = CarrierService.objects.select_related('carrier').get(id=obj.service_id) return service.carrier.name except CarrierService.DoesNotExist: return \"Перевозчик не найден\" return \"-\" warehouse_display.short_description = \"Компания/Склад\" def final_price_display(self, obj): \"\"\"Отображает итоговую цену (без скрытой наценки)\"\"\" if obj and obj.pk: return f\"{obj.final_price:.2f}\" return \"0.00\" final_price_display.short_description = \"Итого\" def invoice_price_display(self, obj): \"\"\"Отображает цену для инвойса (с учётом скрытой наценки)\"\"\" if obj and obj.pk: return f\"{obj.invoice_price:.2f}\" return \"0.00\" invoice_price_display.short_description = \"В инвойсе\" def get_formset(self, request, obj=None, **kwargs): formset = super().get_formset(request, obj, **kwargs) # Добавляем пояснения formset.form.base_fields['service_type'].help_text = 'Выберите тип поставщика' formset.form.base_fields['cust", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ne, **kwargs): formset = super().get_formset(request, obj, **kwargs) # Добавляем пояснения formset.form.base_fields['service_type'].help_text = 'Выберите тип поставщика' formset.form.base_fields['custom_price'].help_text = 'Оставьте пустым для использования цены по умолчанию' formset.form.base_fields['quantity'].help_text = 'Количество услуг' return formset import json import logging from django.db.models import Q from django.contrib.admin import SimpleListFilter logger = logging.getLogger('django') CONTAINER_STATUS_COLORS = { 'В пути': '#2772a8', # Темнее синего 'В порту': '#8B0000', # Тёмно-красный 'Разгружен': '#239f58', # Темнее зелёного 'Передан': '#78458c', # Темнее фиолетового } class CarInline(admin.TabularInline): model = Car extra = 1 can_delete = True show_change_link = True # Ссылка на редактирование отдельной машины fields = ('year', 'brand', 'vehicle_type', 'vin', 'client', 'total_price', 'has_title') # добавили vehicle_type readonly_fields = ('total_price',) def get_formset(self, request, obj=None, **kwargs): formset = super().get_formset(request, obj, **kwargs) for field in formset.form.base_fields.values(): field.help_text = '' return formset class ContainerPhotoIn", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "set(self, request, obj=None, **kwargs): formset = super().get_formset(request, obj, **kwargs) for field in formset.form.base_fields.values(): field.help_text = '' return formset class ContainerPhotoInline(admin.TabularInline): \"\"\" Inline для отображения фотографий контейнера прямо в карточке контейнера. Фотографии загружаются автоматически с Google Drive. \"\"\" model = ContainerPhoto extra = 0 # Не показываем пустые формы для добавления - фото загружаются автоматически can_delete = True max_num = 100 # Ограничение для производительности fields = ('thumbnail_preview', 'photo', 'photo_type', 'is_public') readonly_fields = ('thumbnail_preview',) verbose_name = \"Фотография\" verbose_name_plural = \"📷 Фотографии контейнера\" def thumbnail_preview(self, obj): \"\"\"Миниатюра фотографии\"\"\" if obj.thumbnail: return format_html( '<a href=\"{}\" target=\"_blank\"><img src=\"{}\" style=\"max-width: 80px; max-height: 80px; border-radius: 4px; cursor: pointer;\" /></a>', obj.photo.url if obj.photo else '#', obj.thumbnail.url ) elif obj.photo: return format_html( '<a href=\"{}\" target=\"_blank\"><img src=\"{}\" style=\"max-width: 80px; max-height: 80px; border-radius: 4px; cursor: pointer;\" /></a>', obj.photo.url, ob", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "umbnail.url ) elif obj.photo: return format_html( '<a href=\"{}\" target=\"_blank\"><img src=\"{}\" style=\"max-width: 80px; max-height: 80px; border-radius: 4px; cursor: pointer;\" /></a>', obj.photo.url, obj.photo.url ) return '-' thumbnail_preview.short_description = 'Превью' def get_queryset(self, request): \"\"\"Оптимизируем запрос - загружаем только нужные поля\"\"\" return super().get_queryset(request).only('id', 'container', 'photo', 'thumbnail', 'photo_type', 'is_public') # CarServiceInline удален class ContainerAdmin(admin.ModelAdmin): change_form_template = 'admin/core/container/change_form.html' list_display = ('number', 'colored_status', 'eta', 'planned_unload_date', 'unload_date', 'line', 'warehouse', 'photos_count_display') list_display_links = ('number',) # Делаем номер контейнера кликабельным list_filter = (MultiStatusFilter, ClientAutocompleteFilter, MultiWarehouseFilter) search_fields = ('number',) ordering = ['-unload_date', '-id'] # Сначала по дате разгрузки (новые сверху), потом по ID inlines = [CarInline, ContainerPhotoInline] # Фотографии под списком машин fieldsets = ( ('Основные данные', { 'classes': ('collapse',), 'fields': ( ('number', 'status', 'line', 'warehouse'), ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "м по ID inlines = [CarInline, ContainerPhotoInline] # Фотографии под списком машин fieldsets = ( ('Основные данные', { 'classes': ('collapse',), 'fields': ( ('number', 'status', 'line', 'warehouse'), ('ths', 'ths_payer'), ('eta', 'planned_unload_date', 'unload_date'), 'google_drive_folder_url', ) }), ) readonly_fields = ('days', 'storage_cost') actions = ['set_status_floating', 'set_status_in_port', 'set_status_unloaded', 'set_status_transferred', 'check_container_status', 'bulk_update_container_statuses', 'sync_photos_from_gdrive', 'resend_planned_notifications', 'resend_unload_notifications'] class Media: css = {'all': ('css/logist2_custom_admin.css',)} js = ('js/htmx.min.js',) def get_queryset(self, request): qs = super().get_queryset(request) return qs.select_related('line', 'client', 'warehouse').prefetch_related('container_cars') def save_model(self, request, obj, form, change): import time start_time = time.time() logger.info(f\"[TIMING] Container save_model started for {obj.number}\") # Если это новый объект и у него еще нет pk, сохраняем его if not change and not obj.pk: super().save_model(request, obj, form, change) elif change: # Для существующих объектов сохраняем как обы", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "er}\") # Если это новый объект и у него еще нет pk, сохраняем его if not change and not obj.pk: super().save_model(request, obj, form, change) elif change: # Для существующих объектов сохраняем как обычно super().save_model(request, obj, form, change) logger.info(f\"[TIMING] Container saved in {time.time() - start_time:.2f}s\") # Если изменили склад — разнесём новый склад во все авто if change and form and 'warehouse' in getattr(form, 'changed_data', []): try: logger.info(f\"Warehouse changed for container {obj.id}, syncing cars...\") obj.sync_cars_after_warehouse_change() logger.info(f\"Successfully synced warehouse for {obj.container_cars.count()} cars\") except Exception as e: logger.error(f\"Failed to sync cars after warehouse change for container {obj.id}: {e}\") # Если изменили статус — обновить статус у ВСЕХ автомобилей в контейнере if change and form and 'status' in getattr(form, 'changed_data', []): try: logger.info(f\"Status changed for container {obj.id} to {obj.status}, bulk updating all cars...\") updated_count = obj.container_cars.update(status=obj.status) logger.info(f\"✅ Updated status to '{obj.status}' for {updated_count} cars in container {obj.number}\") except Exception as e:", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": " all cars...\") updated_count = obj.container_cars.update(status=obj.status) logger.info(f\"✅ Updated status to '{obj.status}' for {updated_count} cars in container {obj.number}\") except Exception as e: logger.error(f\"Failed to update car statuses for container {obj.id}: {e}\") # Если изменили дату разгрузки — обновить дату у ВСЕХ автомобилей в контейнере if change and form and 'unload_date' in getattr(form, 'changed_data', []): try: from django.db.models.signals import post_save, post_delete from core.signals import update_related_on_car_save, create_car_services_on_car_save, recalculate_car_price_on_service_save, recalculate_car_price_on_service_delete logger.info(f\"Unload date changed for container {obj.id} to {obj.unload_date}, bulk updating all cars...\") # Обновляем контейнер из БД, чтобы быть уверенными в актуальности данных obj.refresh_from_db() # Временно отключаем ВСЕ сигналы для оптимизации post_save.disconnect(update_related_on_car_save, sender=Car) post_save.disconnect(create_car_services_on_car_save, sender=Car) post_save.disconnect(recalculate_car_price_on_service_save, sender=CarService) post_delete.disconnect(recalculate_car_price_on_service_delete, sender=CarService) ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "car_services_on_car_save, sender=Car) post_save.disconnect(recalculate_car_price_on_service_save, sender=CarService) post_delete.disconnect(recalculate_car_price_on_service_delete, sender=CarService) cars_to_update = [] affected_invoices = set() for car in obj.container_cars.select_related('warehouse').all(): # Обновляем дату разгрузки у ВСЕХ автомобилей car.unload_date = obj.unload_date car.update_days_and_storage() car.calculate_total_price() cars_to_update.append(car) # Собираем инвойсы для обновления (только новая система) for invoice in car.newinvoice_set.all(): affected_invoices.add(invoice) # Массовое обновление одним запросом if cars_to_update: Car.objects.bulk_update( cars_to_update, ['unload_date', 'days', 'storage_cost', 'total_price'], batch_size=50 ) logger.info(f\"✅ Bulk updated {len(cars_to_update)} cars in container {obj.number}\") # Включаем сигналы обратно post_save.connect(update_related_on_car_save, sender=Car) post_save.connect(create_car_services_on_car_save, sender=Car) post_save.connect(recalculate_car_price_on_service_save, sender=CarService) post_delete.connect(recalculate_car_price_on_service_delete, sender=CarService) # Обновляем все затронутые инвойсы одн", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "=Car) post_save.connect(recalculate_car_price_on_service_save, sender=CarService) post_delete.connect(recalculate_car_price_on_service_delete, sender=CarService) # Обновляем все затронутые инвойсы одним пакетом if affected_invoices: logger.info(f\"Updating {len(affected_invoices)} affected invoices...\") for invoice in affected_invoices: try: if hasattr(invoice, 'regenerate_items_from_cars'): # NewInvoice invoice.regenerate_items_from_cars() else: # InvoiceOLD invoice.update_total_amount() except Exception as e: logger.error(f\"Error updating invoice {invoice.id}: {e}\") logger.info(f\"✅ Updated {len(affected_invoices)} invoices\") except Exception as e: logger.error(f\"Failed to update cars after unload_date change for container {obj.id}: {e}\") # Убедимся, что сигналы включены даже в случае ошибки try: from django.db.models.signals import post_save, post_delete from core.signals import update_related_on_car_save, create_car_services_on_car_save, recalculate_car_price_on_service_save, recalculate_car_price_on_service_delete post_save.connect(update_related_on_car_save, sender=Car) post_save.connect(create_car_services_on_car_save, sender=Car) post_save.connect(recalculate_car_price_on_ser", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "late_car_price_on_service_delete post_save.connect(update_related_on_car_save, sender=Car) post_save.connect(create_car_services_on_car_save, sender=Car) post_save.connect(recalculate_car_price_on_service_save, sender=CarService) post_delete.connect(recalculate_car_price_on_service_delete, sender=CarService) except: pass # Проверяем изменения связанные с THS: линия, сумма THS, плательщик THS, склад # Склад включён потому что при ths_payer='WAREHOUSE' THS записывается как услуга склада changed_data = getattr(form, 'changed_data', []) if form else [] ths_related_changed = any(field in changed_data for field in ['line', 'ths', 'ths_payer', 'warehouse']) # Для нового контейнера - создаём THS если указаны line и ths # Для существующего - только если изменились поля THS или склад should_create_ths = (not change and obj.line and obj.ths) or (change and ths_related_changed) # если создаём новый контейнер с THS или изменили THS поля — обновить услуги THS if should_create_ths: line_start = time.time() try: from django.db.models.signals import post_save, post_delete from core.signals import update_related_on_car_save, create_car_services_on_car_save, create_ths_services_for_container, recalcu", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "time() try: from django.db.models.signals import post_save, post_delete from core.signals import update_related_on_car_save, create_car_services_on_car_save, create_ths_services_for_container, recalculate_invoices_on_car_service_save, recalculate_invoices_on_car_service_delete from core.models import recalculate_car_price_on_service_save, recalculate_car_price_on_service_delete, LineService, WarehouseService from core.models_billing import NewInvoice logger.info(f\"[TIMING] THS-related change started for container {obj.id}, line: {obj.line}, ths: {obj.ths}, ths_payer: {obj.ths_payer}\") # Временно отключаем ВСЕ сигналы чтобы избежать рекурсии и каскадных обновлений post_save.disconnect(update_related_on_car_save, sender=Car) post_save.disconnect(create_car_services_on_car_save, sender=Car) post_save.disconnect(recalculate_car_price_on_service_save, sender=CarService) post_delete.disconnect(recalculate_car_price_on_service_delete, sender=CarService) post_save.disconnect(recalculate_invoices_on_car_service_save, sender=CarService) post_delete.disconnect(recalculate_invoices_on_car_service_delete, sender=CarService) try: # 1. Если изменилась линия - обновляем линию у всех авто if 'line'", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "es_on_car_service_save, sender=CarService) post_delete.disconnect(recalculate_invoices_on_car_service_delete, sender=CarService) try: # 1. Если изменилась линия - обновляем линию у всех авто if 'line' in changed_data: car_ids = list(obj.container_cars.values_list('id', flat=True)) updated_count = obj.container_cars.update(line=obj.line) logger.info(f\"[TIMING] Line updated for {updated_count} cars\") # 2. Создаём услуги THS с пропорциональным распределением if obj.line and obj.ths: created_count = create_ths_services_for_container(obj) logger.info(f\"[TIMING] Created {created_count} THS services with proportional distribution\") else: # Если линии нет или THS = 0, удаляем старые услуги THS car_ids = list(obj.container_cars.values_list('id', flat=True)) # Удаляем услуги THS от линий deleted_line = CarService.objects.filter( car_id__in=car_ids, service_type='LINE' ).filter( service_id__in=LineService.objects.filter(name__icontains='THS').values_list('id', flat=True) ).delete() # Удаляем услуги THS от складов deleted_wh = CarService.objects.filter( car_id__in=car_ids, service_type='WAREHOUSE' ).filter( service_id__in=WarehouseService.objects.filter(name__icontains='THS').values_list('id',", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ги THS от складов deleted_wh = CarService.objects.filter( car_id__in=car_ids, service_type='WAREHOUSE' ).filter( service_id__in=WarehouseService.objects.filter(name__icontains='THS').values_list('id', flat=True) ).delete() logger.info(f\"[TIMING] Deleted {deleted_line[0]} line THS services and {deleted_wh[0]} warehouse THS services\") # 3. Пересчитываем цены для всех авто (BULK) cars_to_update = [] affected_invoices = set() for car in obj.container_cars.select_related('warehouse').all(): car.update_days_and_storage() car.calculate_total_price() cars_to_update.append(car) # Собираем связанные инвойсы for invoice in NewInvoice.objects.filter(cars=car, status__in=['DRAFT', 'ISSUED', 'PARTIALLY_PAID', 'OVERDUE']): affected_invoices.add(invoice) if cars_to_update: Car.objects.bulk_update( cars_to_update, ['days', 'storage_cost', 'total_price'], batch_size=50 ) logger.info(f\"[TIMING] Recalculated prices for {len(cars_to_update)} cars\") # 4. Обновляем связанные инвойсы if affected_invoices: logger.info(f\"[TIMING] Updating {len(affected_invoices)} affected invoices...\") for invoice in affected_invoices: try: invoice.regenerate_items_from_cars() except Exception as e: logger.error(f\"Error upd", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ger.info(f\"[TIMING] Updating {len(affected_invoices)} affected invoices...\") for invoice in affected_invoices: try: invoice.regenerate_items_from_cars() except Exception as e: logger.error(f\"Error updating invoice {invoice.number}: {e}\") logger.info(f\"[TIMING] Invoices updated\") logger.info(f\"[TIMING] THS-related change completed in {time.time() - line_start:.2f}s\") finally: # Включаем сигналы обратно post_save.connect(update_related_on_car_save, sender=Car) post_save.connect(create_car_services_on_car_save, sender=Car) post_save.connect(recalculate_car_price_on_service_save, sender=CarService) post_delete.connect(recalculate_car_price_on_service_delete, sender=CarService) post_save.connect(recalculate_invoices_on_car_service_save, sender=CarService) post_delete.connect(recalculate_invoices_on_car_service_delete, sender=CarService) except Exception as e: logger.error(f\"Failed to update cars after line change for container {obj.id}: {e}\", exc_info=True) def save_formset(self, request, form, formset, change): import time formset_start = time.time() logger.info(f\"[TIMING] save_formset started for {formset.model.__name__}\") instances = formset.save(commit=False) logger.info(f\"[TIMING] ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "orm, formset, change): import time formset_start = time.time() logger.info(f\"[TIMING] save_formset started for {formset.model.__name__}\") instances = formset.save(commit=False) logger.info(f\"[TIMING] formset.save(commit=False) took {time.time() - formset_start:.2f}s\") parent = form.instance # контейнер # Проверяем, что у родительского объекта есть первичный ключ if not parent.pk: logger.error(\"Parent container doesn't have a primary key - saving parent first\") # Сохраняем родительский объект сначала parent.save() logger.info(f\"Saved parent container {parent.pk}\") # Пропускаем если нет изменённых инстансов и нет удалённых объектов if not instances and not formset.deleted_objects: logger.info(f\"[TIMING] No changes in formset, skipping. Total: {time.time() - formset_start:.2f}s\") formset.save_m2m() return logger.info(f\"[TIMING] Processing {len(instances)} changed instances\") for obj in instances: if isinstance(obj, Car): # привязываем к контейнеру if not obj.container_id: obj.container = parent # статус всегда как у контейнера obj.status = parent.status # склад/клиент/линия по контейнеру, если не заданы if not obj.warehouse_id and parent.warehouse_id: obj.warehouse = parent.warehouse ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "parent # статус всегда как у контейнера obj.status = parent.status # склад/клиент/линия по контейнеру, если не заданы if not obj.warehouse_id and parent.warehouse_id: obj.warehouse = parent.warehouse if not obj.client_id and parent.client_id: obj.client = parent.client if not obj.line_id and parent.line_id: obj.line = parent.line # Дата разгрузки ВСЕГДА берется из контейнера (наследуется принудительно) if parent.unload_date: obj.unload_date = parent.unload_date logger.debug(f\"Car {obj.vin}: inherited unload_date={obj.unload_date} from container {parent.number}\") creating = obj.pk is None if creating and obj.warehouse_id: # подтянуть дефолты склада (rate/free_days и пр.) ДО первого save() obj.set_initial_warehouse_values() # пересчёт перед сохранением obj.update_days_and_storage() # Сохраняем объект - сигнал post_save обработает calculate_total_price obj.save() logger.debug(f\"Saved Car {obj.vin} (creating={creating}, has_title={obj.has_title})\") # Для новых машин принудительно создаём услуги склада с наценкой if creating and obj.warehouse_id: from core.models import WarehouseService, CarService from decimal import Decimal warehouse_services = WarehouseService.objects.filter( warehou", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "слуги склада с наценкой if creating and obj.warehouse_id: from core.models import WarehouseService, CarService from decimal import Decimal warehouse_services = WarehouseService.objects.filter( warehouse=obj.warehouse, is_active=True, add_by_default=True ) for service in warehouse_services: # Проверяем, нет ли уже такой услуги if not CarService.objects.filter(car=obj, service_type='WAREHOUSE', service_id=service.id).exists(): # Для \"Хранение\" рассчитываем цену и наценку × количество дней if service.name == 'Хранение': days = Decimal(str(obj.days or 0)) custom_price = days * Decimal(str(service.default_price or 0)) default_markup = days * Decimal(str(service.default_markup or 0)) else: custom_price = service.default_price default_markup = service.default_markup or Decimal('0') CarService.objects.create( car=obj, service_type='WAREHOUSE', service_id=service.id, custom_price=custom_price, markup_amount=default_markup ) logger.info(f\"🏭 [FORMSET] Создана услуга склада '{service.name}' для {obj.vin} (цена: {custom_price}, наценка: {default_markup})\") else: obj.save() # Удаляем объекты, помеченные на удаление deleted_cars = [o for o in formset.deleted_objects if isinstance(o, Car)] logger.", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "bj.vin} (цена: {custom_price}, наценка: {default_markup})\") else: obj.save() # Удаляем объекты, помеченные на удаление deleted_cars = [o for o in formset.deleted_objects if isinstance(o, Car)] logger.info(f\"[FORMSET] deleted_objects count: {len(formset.deleted_objects)}, deleted_cars: {len(deleted_cars)}\") for o in formset.deleted_objects: try: # Сначала удаляем связанные CarService if isinstance(o, Car): o.car_services.all().delete() o.delete() logger.info(f\"[FORMSET] Deleted object: {o}\") except Exception as e: logger.error(f\"Error deleting object {o}: {e}\") formset.save_m2m() # После любых изменений в ТС (добавление/изменение/удаление) - пересчитываем THS # Условие: есть line, есть ths, и (есть изменённые машины или удалённые машины) cars_changed = bool(instances) or bool(deleted_cars) logger.info(f\"[FORMSET] instances count: {len(instances)}, cars_changed: {cars_changed}\") logger.info(f\"[FORMSET] parent.line: {parent.line}, parent.ths: {parent.ths}\") # ВСЕГДА пересчитываем THS если есть line и ths (даже без явных изменений) if parent.line and parent.ths: try: from core.signals import create_ths_services_for_container from django.db import transaction # Принудительно обновляем д", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": " есть line и ths (даже без явных изменений) if parent.line and parent.ths: try: from core.signals import create_ths_services_for_container from django.db import transaction # Принудительно обновляем данные контейнера из БД parent.refresh_from_db() logger.info(f\"[FORMSET] Starting THS recalculation for container {parent.number}\") # Используем savepoint для безопасного пересчёта with transaction.atomic(): # Пересчитываем THS для ВСЕХ машин в контейнере cars_in_container = list(parent.container_cars.all()) logger.info(f\"[FORMSET] Found {len(cars_in_container)} cars in container\") if cars_in_container: created = create_ths_services_for_container(parent) logger.info(f\"[FORMSET] Created/updated {created} THS services for container {parent.number}\") # Пересчитываем цены ВСЕХ машин в контейнере после обновления THS for car in cars_in_container: car.refresh_from_db() # Обновляем данные машины из БД car.calculate_total_price() car.save(update_fields=['total_price', 'storage_cost', 'days']) logger.info(f\"[FORMSET] Recalculated price for car {car.vin}: {car.total_price}\") logger.info(f\"[FORMSET] Recalculated prices for all {len(cars_in_container)} cars\") else: logger.info(f\"[FORMSET] No cars l", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "r.info(f\"[FORMSET] Recalculated price for car {car.vin}: {car.total_price}\") logger.info(f\"[FORMSET] Recalculated prices for all {len(cars_in_container)} cars\") else: logger.info(f\"[FORMSET] No cars left in container {parent.number}\") except Exception as e: logger.error(f\"Failed to create THS services in formset for container {parent.id}: {e}\", exc_info=True) def get_form(self, request, obj=None, **kwargs): form = super().get_form(request, obj, **kwargs) for field in form.base_fields.values(): field.help_text = '' return form def colored_status(self, obj): color = obj.get_status_color() return format_html( '<span style=\"background-color: {}; color: white; padding: 4px 8px; border-radius: 4px;\">{}</span>', color, obj.get_status_display() ) colored_status.short_description = 'Статус' def photos_count_display(self, obj): \"\"\"Отображает количество фотографий контейнера\"\"\" count = obj.photos.count() if count > 0: return format_html( '<span style=\"background-color: #4285f4; color: white; padding: 2px 8px; border-radius: 10px;\">📷 {}</span>', count ) return '-' photos_count_display.short_description = 'Фото' def set_status_floating(self, request, queryset): updated = queryset.update(status=", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ing: 2px 8px; border-radius: 10px;\">📷 {}</span>', count ) return '-' photos_count_display.short_description = 'Фото' def set_status_floating(self, request, queryset): updated = queryset.update(status='FLOATING') for obj in queryset: obj.update_days_and_storage() obj.sync_cars() obj.save(update_fields=['days', 'storage_cost']) # Обновляем статус у всех авто в контейнере obj.container_cars.update(status='FLOATING') self.message_user(request, f\"Статус изменён на 'В пути' для {updated} контейнеров и их авто.\") set_status_floating.short_description = \"Изменить статус на В пути\" def set_status_in_port(self, request, queryset): updated = queryset.update(status='IN_PORT') for obj in queryset: obj.update_days_and_storage() obj.sync_cars() obj.save(update_fields=['days', 'storage_cost']) # Обновляем статус у всех авто в контейнере obj.container_cars.update(status='IN_PORT') self.message_user(request, f\"Статус изменён на 'В порту' для {updated} контейнеров и их авто.\") set_status_in_port.short_description = \"Изменить статус на В порту\" def set_status_unloaded(self, request, queryset): updated = 0 for obj in queryset: if obj.warehouse and obj.unload_date: obj.status = 'UNLOADED' obj.update_day", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "scription = \"Изменить статус на В порту\" def set_status_unloaded(self, request, queryset): updated = 0 for obj in queryset: if obj.warehouse and obj.unload_date: obj.status = 'UNLOADED' obj.update_days_and_storage() obj.sync_cars() obj.save(update_fields=['status', 'days', 'storage_cost']) # Обновляем статус у всех авто в контейнере obj.container_cars.update(status='UNLOADED') updated += 1 else: self.message_user(request, f\"Контейнер {obj.number} не обновлён: требуются поля 'Склад' и 'Дата разгрузки'.\", level='warning') self.message_user(request, f\"Статус изменён на 'Разгружен' для {updated} контейнеров и их авто.\") set_status_unloaded.short_description = \"Изменить статус на Разгружен\" def set_status_transferred(self, request, queryset): updated = queryset.update(status='TRANSFERRED') for obj in queryset: obj.update_days_and_storage() obj.sync_cars() obj.save(update_fields=['days', 'storage_cost']) # Обновляем статус у всех авто в контейнере obj.container_cars.update(status='TRANSFERRED') self.message_user(request, f\"Статус изменён на 'Передан' для {updated} контейнеров и их авто.\") set_status_transferred.short_description = \"Изменить статус на Передан\" def check_container_status(s", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "D') self.message_user(request, f\"Статус изменён на 'Передан' для {updated} контейнеров и их авто.\") set_status_transferred.short_description = \"Изменить статус на Передан\" def check_container_status(self, request, queryset): \"\"\"Проверяет и обновляет статус контейнеров на основе статуса автомобилей\"\"\" updated_count = 0 for obj in queryset: try: old_status = obj.status obj.check_and_update_status_from_cars() if obj.status != old_status: updated_count += 1 except Exception as e: logger.error(f\"Failed to check status for container {obj.number}: {e}\") if updated_count > 0: self.message_user(request, f\"Статус автоматически обновлён для {updated_count} контейнеров.\") else: self.message_user(request, \"Статус контейнеров не требует обновления.\") check_container_status.short_description = \"Проверить статус контейнера\" def bulk_update_container_statuses(self, request, queryset): \"\"\"Массовое обновление статусов контейнеров на основе статуса автомобилей\"\"\" updated_count = 0 skipped_count = 0 error_count = 0 for container in queryset: try: cars = container.container_cars.all() if not cars.exists(): skipped_count += 1 continue # Проверяем, все ли автомобили переданы all_transferred = all(car.stat", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "count = 0 for container in queryset: try: cars = container.container_cars.all() if not cars.exists(): skipped_count += 1 continue # Проверяем, все ли автомобили переданы all_transferred = all(car.status == 'TRANSFERRED' for car in cars) transferred_cars_count = sum(1 for car in cars if car.status == 'TRANSFERRED') total_cars_count = cars.count() if all_transferred and container.status != 'TRANSFERRED': old_status = container.status container.status = 'TRANSFERRED' container.save(update_fields=['status']) logger.info(f\"Container {container.number} status updated from {old_status} to TRANSFERRED\") updated_count += 1 else: skipped_count += 1 except Exception as e: logger.error(f\"Failed to update container {container.number}: {e}\") error_count += 1 # Формируем сообщение для пользователя messages = [] if updated_count > 0: messages.append(f\"Обновлено контейнеров: {updated_count}\") if skipped_count > 0: messages.append(f\"Пропущено контейнеров: {skipped_count}\") if error_count > 0: messages.append(f\"Ошибок: {error_count}\") if messages: self.message_user(request, \"; \".join(messages)) else: self.message_user(request, \"Нет контейнеров для обновления.\") bulk_update_container_statuses.short_de", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ppend(f\"Ошибок: {error_count}\") if messages: self.message_user(request, \"; \".join(messages)) else: self.message_user(request, \"Нет контейнеров для обновления.\") bulk_update_container_statuses.short_description = \"Массовое обновление статусов контейнеров\" def sync_photos_from_gdrive(self, request, queryset): \"\"\"Синхронизирует фотографии с Google Drive для выбранных контейнеров\"\"\" from .google_drive_sync import GoogleDriveSync total_photos = 0 success_count = 0 error_count = 0 for container in queryset: try: # Пробуем найти папку контейнера в обеих основных папках container_number = container.number photos_added = 0 # Проверяем обе папки (выгруженные и в контейнере) for folder_type, folder_id in [ ('unloaded', '1711SSTZ3_YgUcZfNrgNzhscbmlHXlsKb'), ('in_container', '11poTWYYG3uKTuGTYDWS2m8uA52mlzP6f') ]: # Получаем папки месяцев month_folders = GoogleDriveSync.get_public_folder_files(folder_id) for month_folder in month_folders: if not month_folder.get('is_folder'): continue # Получаем папки контейнеров в этом месяце container_folders = GoogleDriveSync.get_public_folder_files(month_folder['id']) for container_folder in container_folders: if container_folder['name'] == container_number", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "пки контейнеров в этом месяце container_folders = GoogleDriveSync.get_public_folder_files(month_folder['id']) for container_folder in container_folders: if container_folder['name'] == container_number: # Нашли папку контейнера! photo_type = 'UNLOADING' if folder_type == 'unloaded' else 'GENERAL' count = GoogleDriveSync.sync_container_folder( container_number, container_folder['id'], photo_type ) photos_added += count if photos_added > 0: success_count += 1 total_photos += photos_added logger.info(f\"Контейнер {container_number}: добавлено {photos_added} фото\") else: logger.warning(f\"Контейнер {container_number}: папка не найдена на Google Drive\") except Exception as e: error_count += 1 logger.error(f\"Ошибка синхронизации контейнера {container.number}: {e}\") # Сообщение пользователю if total_photos > 0: self.message_user( request, f\"Синхронизация завершена! Добавлено {total_photos} фото для {success_count} контейнеров. Ошибок: {error_count}\", level='SUCCESS' ) else: self.message_user( request, f\"Фотографии не найдены. Проверьте наличие папок контейнеров на Google Drive. Ошибок: {error_count}\", level='WARNING' ) sync_photos_from_gdrive.short_description = \"📥 Загрузить фото с Google Dr", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "quest, f\"Фотографии не найдены. Проверьте наличие папок контейнеров на Google Drive. Ошибок: {error_count}\", level='WARNING' ) sync_photos_from_gdrive.short_description = \"📥 Загрузить фото с Google Drive\" def resend_planned_notifications(self, request, queryset): \"\"\"Повторно отправляет уведомления клиентам о планируемой дате разгрузки\"\"\" from core.services.email_service import ContainerNotificationService total_sent = 0 total_failed = 0 containers_processed = 0 for container in queryset: if not container.planned_unload_date: self.message_user( request, f\"Контейнер {container.number}: не указана планируемая дата разгрузки\", level='WARNING' ) continue sent, failed = ContainerNotificationService.send_planned_to_all_clients(container, user=request.user) total_sent += sent total_failed += failed if sent > 0: containers_processed += 1 if total_sent > 0: self.message_user( request, f\"✅ Отправлено {total_sent} уведомлений о планируемой разгрузке для {containers_processed} контейнеров. Ошибок: {total_failed}\", level='SUCCESS' ) elif total_failed > 0: self.message_user( request, f\"❌ Не удалось отправить уведомления. Ошибок: {total_failed}. Проверьте email клиентов.\", level='ERROR' ) else: se", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "{total_failed}\", level='SUCCESS' ) elif total_failed > 0: self.message_user( request, f\"❌ Не удалось отправить уведомления. Ошибок: {total_failed}. Проверьте email клиентов.\", level='ERROR' ) else: self.message_user( request, \"Нет клиентов с email для отправки уведомлений (или уведомления уже были отправлены)\", level='WARNING' ) resend_planned_notifications.short_description = \"📧 Повторить уведомление о планируемой разгрузке\" def resend_unload_notifications(self, request, queryset): \"\"\"Повторно отправляет уведомления клиентам о разгрузке контейнера\"\"\" from core.services.email_service import ContainerNotificationService total_sent = 0 total_failed = 0 containers_processed = 0 for container in queryset: if not container.unload_date: self.message_user( request, f\"Контейнер {container.number}: не указана дата разгрузки\", level='WARNING' ) continue sent, failed = ContainerNotificationService.send_unload_to_all_clients(container, user=request.user) total_sent += sent total_failed += failed if sent > 0: containers_processed += 1 if total_sent > 0: self.message_user( request, f\"✅ Отправлено {total_sent} уведомлений о разгрузке для {containers_processed} контейнеров. Ошибок: {total_failed}\"", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "f sent > 0: containers_processed += 1 if total_sent > 0: self.message_user( request, f\"✅ Отправлено {total_sent} уведомлений о разгрузке для {containers_processed} контейнеров. Ошибок: {total_failed}\", level='SUCCESS' ) elif total_failed > 0: self.message_user( request, f\"❌ Не удалось отправить уведомления. Ошибок: {total_failed}. Проверьте email клиентов.\", level='ERROR' ) else: self.message_user( request, \"Нет клиентов с email для отправки уведомлений (или уведомления уже были отправлены)\", level='WARNING' ) resend_unload_notifications.short_description = \"📧 Повторить уведомление о разгрузке\" def change_view(self, request, object_id, form_url='', extra_context=None): \"\"\"Переопределяем change_view для передачи данных фотографий в шаблон\"\"\" extra_context = extra_context or {} if object_id: obj = self.get_object(request, object_id) if obj: # Только считаем фото - быстрый COUNT запрос # Сами данные фото загружаются через AJAX при клике extra_context['photos_count'] = obj.photos.count() extra_context['container_id'] = object_id return super().change_view(request, object_id, form_url, extra_context) def get_changelist(self, request, **kwargs): \"\"\"Добавляет фильтрацию по умолчанию для с", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "xtra_context['container_id'] = object_id return super().change_view(request, object_id, form_url, extra_context) def get_changelist(self, request, **kwargs): \"\"\"Добавляет фильтрацию по умолчанию для статусов 'В порту' и 'Разгружен'\"\"\" # Если нет параметров фильтрации, добавляем фильтр по умолчанию if not request.GET.get('status_multi'): # Создаем копию GET параметров get_params = request.GET.copy() get_params.setlist('status_multi', ['IN_PORT', 'UNLOADED']) request.GET = get_params return super().get_changelist(request, **kwargs) @admin.register(Car) class CarAdmin(admin.ModelAdmin): change_form_template = 'admin/core/car/change_form.html' list_display = ( 'vin', 'brand', 'vehicle_type', 'year_display', 'client', 'colored_status', 'container_display', 'warehouse', 'line', 'unload_date_display', 'days_display', 'storage_cost_display', 'total_price_display', 'has_title' ) list_editable = ('has_title',) list_filter = (MultiStatusFilter, ClientAutocompleteFilter, MultiWarehouseFilter) search_fields = ('vin', 'brand') # ОПТИМИЗАЦИЯ: Предзагрузка связанных объектов для list view list_select_related = ('client', 'warehouse', 'line', 'carrier', 'container') list_prefetch_related = ('car_se", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ch_fields = ('vin', 'brand') # ОПТИМИЗАЦИЯ: Предзагрузка связанных объектов для list view list_select_related = ('client', 'warehouse', 'line', 'carrier', 'container') list_prefetch_related = ('car_services',) readonly_fields = ( 'default_warehouse_prices_display', 'total_price', 'storage_cost', 'days', 'warehouse_payment_display', 'free_days_display', 'rate_display', 'services_summary_display', 'warehouse_services_display', 'line_services_display', 'carrier_services_display', 'company_services_display' ) # inlines = [] # Услуги управляются через разделы ниже fieldsets = ( ('Основные данные', { 'fields': ( ('year', 'brand', 'vehicle_type', 'vin', 'client', 'status'), ('unload_date', 'transfer_date'), ('has_title', 'title_notes'), ) }), ('Линии', { 'classes': ('collapse',), 'fields': ( 'line', 'line_services_display', ) }), ('Склад', { 'classes': ('collapse',), 'fields': ( 'warehouse', 'warehouse_services_display', ) }), ('Перевозчик', { 'classes': ('collapse',), 'fields': ( 'carrier', 'carrier_services_display', ) }), ('Услуги', { 'classes': ('collapse',), 'fields': ( 'company_services_display', ) }), ('Финансы', { 'fields': ( 'services_summary_display', ) }), ) actions = ['set_sta", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "'carrier_services_display', ) }), ('Услуги', { 'classes': ('collapse',), 'fields': ( 'company_services_display', ) }), ('Финансы', { 'fields': ( 'services_summary_display', ) }), ) actions = ['set_status_floating', 'set_status_in_port', 'set_status_unloaded', 'set_status_transferred', 'set_transferred_today', 'set_title_with_us'] def set_transferred_today(self, request, queryset): \"\"\"Устанавливает статус 'Передан' и дату передачи на сегодня\"\"\" from django.utils import timezone today = timezone.now().date() updated = 0 for car in queryset: car.status = 'TRANSFERRED' car.transfer_date = today car.save() updated += 1 self.message_user(request, f\"Статус изменён на 'Передан' для {updated} автомобилей. Дата передачи: {today}\") set_transferred_today.short_description = \"Передан сегодня\" def default_warehouse_prices_display(self, obj): details = obj.warehouse_details() if \"message\" in details: return details[\"message\"] html = '<table style=\"width:100%; border:1px solid #ddd; border-collapse:collapse;\">' html += '<tr><th style=\"border:1px solid #ddd; padding:8px;\">Поле</th><th style=\"border:1px solid #ddd; padding:8px;\">Цена</th></tr>' for key, value in details.items(): html += f'<tr><td st", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "llapse;\">' html += '<tr><th style=\"border:1px solid #ddd; padding:8px;\">Поле</th><th style=\"border:1px solid #ddd; padding:8px;\">Цена</th></tr>' for key, value in details.items(): html += f'<tr><td style=\"border:1px solid #ddd; padding:8px;\">{key}</td><td style=\"border:1px solid #ddd; padding:8px;\">{value}</td></tr>' html += '</table>' return format_html(html) default_warehouse_prices_display.short_description = \"Дефолтные цены на услуги склада\" # --- NEW: renderer для поля \"Оплата складу\" --- def warehouse_payment_display(self, obj): return f\"{obj.warehouse_payment_amount():.2f}\" warehouse_payment_display.short_description = 'Оплата складу' def services_summary_display(self, obj): \"\"\"Отображает сводку по всем услугам с наценкой Caromoto Lithuania\"\"\" from decimal import Decimal from core.models import CarService from django.db.models import Sum # Обновляем дни и стоимость хранения перед отображением obj.update_days_and_storage() # Разделяем услуги: линии (все + THS из склада), склад (без THS), перевозчик, компании line_total = Decimal('0.00') # Все услуги линий + THS (даже если через склад) warehouse_total = Decimal('0.00') # Услуги склада (без THS) carrier_total = obj.get_services", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ез THS), перевозчик, компании line_total = Decimal('0.00') # Все услуги линий + THS (даже если через склад) warehouse_total = Decimal('0.00') # Услуги склада (без THS) carrier_total = obj.get_services_total_by_provider('CARRIER') company_total = obj.get_services_total_by_provider('COMPANY') # Получаем все услуги и разделяем по категориям # THS всегда считается услугой линии, даже если оплачивается через склад for service in obj.car_services.all(): service_name = service.get_service_name().upper() price = Decimal(str(service.final_price)) if service.service_type == 'LINE' or 'THS' in service_name: line_total += price # Все услуги линий + THS из склада elif service.service_type == 'WAREHOUSE': warehouse_total += price # Услуги склада без THS # Платные дни для отображения paid_days = obj.days or 0 # Сумма распределённых наценок (из услуг) distributed_markup = obj.car_services.aggregate(total=Sum('markup_amount'))['total'] or Decimal('0') # Наценка из поля proft (если не распределена) proft_amount = obj.proft or Decimal('0.00') # Общая наценка = только распределённая (proft больше не используется) total_markup = distributed_markup # Базовые суммы (без наценки) base_total = line_total +", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "t_amount = obj.proft or Decimal('0.00') # Общая наценка = только распределённая (proft больше не используется) total_markup = distributed_markup # Базовые суммы (без наценки) base_total = line_total + warehouse_total + carrier_total + company_total html = ['<div style=\"margin-top:15px; background:#f8f9fa; padding:15px; border-radius:8px; border:1px solid #dee2e6;\">'] html.append('<h3 style=\"margin-top:0; color:#495057;\">Сводка по услугам</h3>') html.append('<div style=\"display:grid; grid-template-columns:1fr 1fr 1fr 1fr 1fr; gap:15px; margin-bottom:20px;\">') # Услуги линий (THS, Отправка в Грузию и т.д.) - с детализацией html.append('<div style=\"background:white; padding:10px; border-radius:5px; border:1px solid #dee2e6;\">') html.append('<strong>Услуги линий:</strong><br>') # Показываем каждую услугу линии (включая THS из склада) line_services_list = [] for service in obj.car_services.all(): service_name = service.get_service_name() # THS считается услугой линии даже если оплачивается через склад if service.service_type == 'LINE' or 'THS' in service_name.upper(): price = Decimal(str(service.final_price)) line_services_list.append((service_name, price)) for name, price in line_servi", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "через склад if service.service_type == 'LINE' or 'THS' in service_name.upper(): price = Decimal(str(service.final_price)) line_services_list.append((service_name, price)) for name, price in line_services_list: html.append(f'<span style=\"font-size:13px; color:#6c757d;\">{name}: {price:.2f}</span><br>') html.append(f'<span style=\"font-size:18px; color:#007bff; font-weight:bold;\">Итого: {line_total:.2f}</span>') html.append('</div>') # Склад (без THS) - с детализацией услуг html.append('<div style=\"background:white; padding:10px; border-radius:5px; border:1px solid #dee2e6;\">') html.append('<strong>Услуги склада:</strong><br>') # Показываем каждую услугу склада (кроме THS) warehouse_services_list = [] for service in obj.car_services.filter(service_type='WAREHOUSE'): service_name = service.get_service_name() if 'THS' not in service_name.upper(): # Используем final_price который учитывает default_price если custom_price не задан price = Decimal(str(service.final_price)) warehouse_services_list.append((service_name, price)) for name, price in warehouse_services_list: html.append(f'<span style=\"font-size:13px; color:#6c757d;\">{name}: {price:.2f}</span><br>') if obj.warehouse: free_days = o", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "st.append((service_name, price)) for name, price in warehouse_services_list: html.append(f'<span style=\"font-size:13px; color:#6c757d;\">{name}: {price:.2f}</span><br>') if obj.warehouse: free_days = obj.warehouse.free_days or 0 html.append(f'<span style=\"font-size:12px; color:#adb5bd;\">Беспл. дней: {free_days}, Плат. дней: {paid_days}</span><br>') html.append(f'<span style=\"font-size:18px; color:#28a745; font-weight:bold;\">Итого: {warehouse_total:.2f}</span>') html.append('</div>') # Перевозчик html.append('<div style=\"background:white; padding:10px; border-radius:5px; border:1px solid #dee2e6;\">') html.append('<strong>Перевозчик:</strong><br>') html.append(f'<span style=\"font-size:18px; color:#ffc107;\">{carrier_total:.2f}</span>') html.append('</div>') # Компании html.append('<div style=\"background:white; padding:10px; border-radius:5px; border:1px solid #dee2e6;\">') html.append('<strong>Услуги компаний:</strong><br>') company_services_list = [] for service in obj.car_services.filter(service_type='COMPANY'): try: company_service = CompanyService.objects.select_related('company').get(id=service.service_id) price = Decimal(str(service.final_price)) company_services_list.append((comp", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "service_type='COMPANY'): try: company_service = CompanyService.objects.select_related('company').get(id=service.service_id) price = Decimal(str(service.final_price)) company_services_list.append((company_service.company.name, company_service.name, price)) except Exception: continue for company_name, name, price in company_services_list: html.append(f'<span style=\"font-size:13px; color:#6c757d;\">{company_name}: {name}: {price:.2f}</span><br>') html.append(f'<span style=\"font-size:18px; color:#6f42c1; font-weight:bold;\">Итого: {company_total:.2f}</span>') html.append('</div>') # Наценка - показываем распределённую сумму html.append('<div style=\"background:#fffde7; padding:10px; border-radius:5px; border:1px solid #ffc107;\">') html.append('<strong style=\"color:#ff8f00;\">Скрытая наценка:</strong><br>') html.append(f'<span style=\"font-size:18px; font-weight:bold; color:#ff8f00;\">{distributed_markup:.2f}</span>') if distributed_markup > 0: html.append(f'<br><span style=\"font-size:11px; color:#666;\">(распределена по услугам)</span>') else: html.append(f'<br><span style=\"font-size:11px; color:#666;\">(введите в жёлтых полях)</span>') html.append('</div>') html.append('</div>') # Общий итог ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": ":#666;\">(распределена по услугам)</span>') else: html.append(f'<br><span style=\"font-size:11px; color:#666;\">(введите в жёлтых полях)</span>') html.append('</div>') html.append('</div>') # Общий итог total_with_markup = base_total + total_markup html.append('<div style=\"background:white; padding:15px; border-radius:5px; border:2px solid #6c757d;\">') html.append('<strong style=\"color:#6c757d;\">Итого к оплате:</strong><br>') html.append(f'<span style=\"font-size:20px; font-weight:bold; color:#495057;\">{total_with_markup:.2f} EUR</span>') html.append('</div>') html.append('</div>') return format_html(''.join(html)) services_summary_display.short_description = 'Сводка по услугам' def colored_status(self, obj): color = obj.get_status_color() return format_html( '<span style=\"background-color: {}; color: white; padding: 4px 8px; border-radius: 4px;\">{}</span>', color, obj.get_status_display() ) colored_status.short_description = 'Статус' def container_display(self, obj): \"\"\"Отображает номер контейнера с кликабельной ссылкой и стилизацией по статусу машины\"\"\" if not obj.container: return '-' # Используем статус машины для определения цвета (как у статуса) color = obj.get_status_color() # С", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "онтейнера с кликабельной ссылкой и стилизацией по статусу машины\"\"\" if not obj.container: return '-' # Используем статус машины для определения цвета (как у статуса) color = obj.get_status_color() # Создаем ссылку на контейнер container_url = f'/admin/core/container/{obj.container.id}/change/' return format_html( '<a href=\"{}\" target=\"_blank\" style=\"text-decoration: none;\"><span style=\"background-color: {}; color: white; padding: 4px 8px; border-radius: 4px;\">{}</span></a>', container_url, color, obj.container.number ) container_display.short_description = 'Контейнер' container_display.admin_order_field = 'container__number' def year_display(self, obj): return obj.year year_display.short_description = 'Год' year_display.admin_order_field = 'year' def unload_date_display(self, obj): return obj.unload_date unload_date_display.short_description = 'Дата разгрузки' unload_date_display.admin_order_field = 'unload_date' def transfer_date_display(self, obj): return obj.transfer_date transfer_date_display.short_description = 'Передан' transfer_date_display.admin_order_field = 'transfer_date' def storage_cost_display(self, obj): \"\"\"Показывает стоимость хранения, рассчитанную на основе полей ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ate_display.short_description = 'Передан' transfer_date_display.admin_order_field = 'transfer_date' def storage_cost_display(self, obj): \"\"\"Показывает стоимость хранения, рассчитанную на основе полей склада\"\"\" try: storage_cost = obj.calculate_storage_cost() return f\"{storage_cost:.2f}\" except Exception as e: print(f\"Ошибка расчета стоимости хранения: {e}\") return f\"{obj.storage_cost:.2f}\" # Fallback на старое поле storage_cost_display.short_description = 'Хран' storage_cost_display.admin_order_field = 'storage_cost' def days_display(self, obj): \"\"\"Показывает платные дни с учетом бесплатных дней из склада\"\"\" if obj.warehouse and obj.unload_date: # Рассчитываем общее количество дней хранения end_date = obj.transfer_date if obj.status == 'TRANSFERRED' and obj.transfer_date else timezone.now().date() total_days = (end_date - obj.unload_date).days + 1 free_days = obj.warehouse.free_days or 0 chargeable_days = max(0, total_days - free_days) return f\"{chargeable_days} (из {total_days})\" return obj.days if hasattr(obj, 'days') else 0 days_display.short_description = 'Плат.дн.' days_display.admin_order_field = 'days' def total_price_display(self, obj): # Для не переданных авто рассчитываем", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "rn obj.days if hasattr(obj, 'days') else 0 days_display.short_description = 'Плат.дн.' days_display.admin_order_field = 'days' def total_price_display(self, obj): # Для не переданных авто рассчитываем цену динамически if obj.status != 'TRANSFERRED': from decimal import Decimal from django.db.models import Sum from core.models import CarService # Обновляем платные дни obj.update_days_and_storage() # Рассчитываем сумму услуг (final_price = базовая цена) base_total = Decimal('0.00') for cs in CarService.objects.filter(car=obj): base_total += Decimal(str(cs.final_price)) # Добавляем распределённую наценку из CarService distributed_markup = CarService.objects.filter(car=obj).aggregate( total=Sum('markup_amount') )['total'] or Decimal('0.00') total = base_total + distributed_markup return f\"{total:.2f}\" return f\"{obj.total_price:.2f}\" total_price_display.short_description = 'Цена' total_price_display.admin_order_field = 'total_price' # УДАЛЕНО: current_price_display - теперь используется только total_price def free_days_display(self, obj): \"\"\"Показывает бесплатные дни из склада\"\"\" if obj.warehouse: return obj.warehouse.free_days return obj.free_days # Fallback на старое поле free_days_di", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ько total_price def free_days_display(self, obj): \"\"\"Показывает бесплатные дни из склада\"\"\" if obj.warehouse: return obj.warehouse.free_days return obj.free_days # Fallback на старое поле free_days_display.short_description = 'FREE' free_days_display.admin_order_field = 'free_days' def rate_display(self, obj): \"\"\"Показывает ставку за сутки из услуги 'Хранение' склада\"\"\" if obj.warehouse: daily_rate = obj._get_storage_daily_rate() return f\"{daily_rate:.2f}\" return \"0.00\" rate_display.short_description = 'Ставка/день' def set_status_floating(self, request, queryset): updated = queryset.update(status='FLOATING') for obj in queryset: obj.update_days_and_storage() obj.save(update_fields=['days', 'storage_cost', 'total_price']) self.message_user(request, f\"Статус изменён на 'В пути' для {updated} автомобилей.\") set_status_floating.short_description = \"Изменить статус на В пути\" def set_status_in_port(self, request, queryset): updated = queryset.update(status='IN_PORT') for obj in queryset: obj.update_days_and_storage() obj.save(update_fields=['days', 'storage_cost', 'total_price']) self.message_user(request, f\"Статус изменён на 'В порту' для {updated} автомобилей.\") set_status_in_port.sh", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "bj.update_days_and_storage() obj.save(update_fields=['days', 'storage_cost', 'total_price']) self.message_user(request, f\"Статус изменён на 'В порту' для {updated} автомобилей.\") set_status_in_port.short_description = \"Изменить статус на В порту\" def set_status_unloaded(self, request, queryset): updated = 0 for obj in queryset: if obj.warehouse and obj.unload_date: obj.status = 'UNLOADED' obj.update_days_and_storage() obj.save(update_fields=['status', 'days', 'storage_cost', 'total_price']) updated += 1 else: self.message_user(request, f\"Автомобиль {obj.vin} не обновлён: требуются поля 'Склад' и 'Дата разгрузки'.\", level='warning') self.message_user(request, f\"Статус изменён на 'Разгружен' для {updated} автомобилей.\") set_status_unloaded.short_description = \"Изменить статус на Разгружен\" def set_status_transferred(self, request, queryset): updated = queryset.update(status='TRANSFERRED') for obj in queryset: if obj.status == 'TRANSFERRED' and not obj.transfer_date: obj.transfer_date = timezone.now().date() obj.update_days_and_storage() obj.save(update_fields=['transfer_date', 'days', 'storage_cost', 'total_price']) self.message_user(request, f\"Статус изменён на 'Передан' для {update", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "imezone.now().date() obj.update_days_and_storage() obj.save(update_fields=['transfer_date', 'days', 'storage_cost', 'total_price']) self.message_user(request, f\"Статус изменён на 'Передан' для {updated} автомобилей.\") set_status_transferred.short_description = \"Изменить статус на Передан\" def set_title_with_us(self, request, queryset): logger.info(f\"Setting has_title=True for {queryset.count()} cars\") updated = queryset.update(has_title=True) for obj in queryset: logger.debug(f\"Updating car {obj.vin} with has_title=True\") obj.save() self.message_user(request, f\"Тайтл установлен как 'У нас' для {updated} автомобилей.\") set_title_with_us.short_description = \"Тайтл у нас\" class Media: css = { 'all': ( 'css/logist2_custom_admin.css', 'style', # Добавляем inline стили ) } js = ('js/htmx.min.js', 'js/logist2_htmx.js') def get_queryset(self, request): qs = super().get_queryset(request) return qs.select_related('client', 'warehouse', 'container') def save_model(self, request, obj, form, change): \"\"\"Сохраняет модель с обработкой полей услуг\"\"\" super().save_model(request, obj, form, change) # Сначала обрабатываем удаление услуг removed_services = set() for key, value in request.POST.items():", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "): \"\"\"Сохраняет модель с обработкой полей услуг\"\"\" super().save_model(request, obj, form, change) # Сначала обрабатываем удаление услуг removed_services = set() for key, value in request.POST.items(): if key.startswith('remove_warehouse_service_') and value == '1': service_id = key.replace('remove_warehouse_service_', '') removed_services.add(f'warehouse_{service_id}') try: deleted_count = CarService.objects.filter( car=obj, service_type='WAREHOUSE', service_id=service_id ).delete() # Добавляем в черный список DeletedCarService.objects.get_or_create( car=obj, service_type='WAREHOUSE', service_id=service_id ) print(f\"Deleted warehouse service {service_id}: {deleted_count}\") except Exception as e: print(f\"Error deleting warehouse service {service_id}: {e}\") elif key.startswith('remove_line_service_') and value == '1': service_id = key.replace('remove_line_service_', '') removed_services.add(f'line_{service_id}') try: deleted_count = CarService.objects.filter( car=obj, service_type='LINE', service_id=service_id ).delete() # Добавляем в черный список DeletedCarService.objects.get_or_create( car=obj, service_type='LINE', service_id=service_id ) print(f\"Deleted line service {service_id}:", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": ", service_id=service_id ).delete() # Добавляем в черный список DeletedCarService.objects.get_or_create( car=obj, service_type='LINE', service_id=service_id ) print(f\"Deleted line service {service_id}: {deleted_count}\") except Exception as e: print(f\"Error deleting line service {service_id}: {e}\") elif key.startswith('remove_carrier_service_') and value == '1': service_id = key.replace('remove_carrier_service_', '') removed_services.add(f'carrier_{service_id}') try: deleted_count = CarService.objects.filter( car=obj, service_type='CARRIER', service_id=service_id ).delete() # Добавляем в черный список DeletedCarService.objects.get_or_create( car=obj, service_type='CARRIER', service_id=service_id ) print(f\"Deleted carrier service {service_id}: {deleted_count}\") except Exception as e: print(f\"Error deleting carrier service {service_id}: {e}\") elif key.startswith('remove_company_service_') and value == '1': service_id = key.replace('remove_company_service_', '') removed_services.add(f'company_{service_id}') try: deleted_count = CarService.objects.filter( car=obj, service_type='COMPANY', service_id=service_id ).delete() # Добавляем в черный список DeletedCarService.objects.get_or_create(", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ny_{service_id}') try: deleted_count = CarService.objects.filter( car=obj, service_type='COMPANY', service_id=service_id ).delete() # Добавляем в черный список DeletedCarService.objects.get_or_create( car=obj, service_type='COMPANY', service_id=service_id ) print(f\"Deleted company service {service_id}: {deleted_count}\") except Exception as e: print(f\"Error deleting company service {service_id}: {e}\") print(f\"Removed services: {removed_services}\") # Обрабатываем поля услуг склада # Сначала обновляем ВСЕ существующие услуги склада existing_warehouse_car_services = CarService.objects.filter( car=obj, service_type='WAREHOUSE' ) for car_service in existing_warehouse_car_services: # Проверяем, не была ли услуга удалена if f'warehouse_{car_service.service_id}' in removed_services: continue field_name = f'warehouse_service_{car_service.service_id}' value = request.POST.get(field_name) if value: try: car_service.custom_price = float(value) except (ValueError, TypeError): pass # Сохраняем скрытую наценку markup_field = f'markup_warehouse_service_{car_service.service_id}' markup_value = request.POST.get(markup_field, '0') try: car_service.markup_amount = float(markup_value) if markup_value el", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ю наценку markup_field = f'markup_warehouse_service_{car_service.service_id}' markup_value = request.POST.get(markup_field, '0') try: car_service.markup_amount = float(markup_value) if markup_value else 0 except (ValueError, TypeError): car_service.markup_amount = 0 car_service.save() # Затем создаём новые услуги из справочника (если нужно) if obj.warehouse: warehouse_services = WarehouseService.objects.filter( warehouse=obj.warehouse, is_active=True, default_price__gt=0 ).only('id', 'default_price') existing_car_service_ids = set(existing_warehouse_car_services.values_list('service_id', flat=True)) # Получаем черный список удаленных услуг deleted_services = DeletedCarService.objects.filter( car=obj, service_type='WAREHOUSE' ).values_list('service_id', flat=True) for service in warehouse_services: # Проверяем, не была ли услуга удалена if f'warehouse_{service.id}' in removed_services: continue # Проверяем черный список if service.id in deleted_services: continue # Если услуги еще нет в CarService, создаем её автоматически if service.id not in existing_car_service_ids: field_name = f'warehouse_service_{service.id}' value = request.POST.get(field_name) or service.default_price # Полу", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": " CarService, создаем её автоматически if service.id not in existing_car_service_ids: field_name = f'warehouse_service_{service.id}' value = request.POST.get(field_name) or service.default_price # Получаем default_markup из услуги default_markup = getattr(service, 'default_markup', 0) or 0 CarService.objects.create( car=obj, service_type='WAREHOUSE', service_id=service.id, custom_price=float(value), markup_amount=float(default_markup) ) # Обрабатываем поля услуг линии # Сначала обновляем ВСЕ существующие услуги линии (включая THS) existing_line_car_services = CarService.objects.filter( car=obj, service_type='LINE' ) for car_service in existing_line_car_services: # Проверяем, не была ли услуга удалена if f'line_{car_service.service_id}' in removed_services: continue field_name = f'line_service_{car_service.service_id}' value = request.POST.get(field_name) if value: try: car_service.custom_price = float(value) except (ValueError, TypeError): pass # Сохраняем скрытую наценку markup_field = f'markup_line_service_{car_service.service_id}' markup_value = request.POST.get(markup_field, '0') try: car_service.markup_amount = float(markup_value) if markup_value else 0 except (ValueError, Type", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": " f'markup_line_service_{car_service.service_id}' markup_value = request.POST.get(markup_field, '0') try: car_service.markup_amount = float(markup_value) if markup_value else 0 except (ValueError, TypeError): car_service.markup_amount = 0 car_service.save() # Затем создаём новые услуги из справочника (если нужно) if obj.line: line_services = LineService.objects.filter( line=obj.line, is_active=True, default_price__gt=0 ).only('id', 'default_price') existing_car_service_ids = set(existing_line_car_services.values_list('service_id', flat=True)) # Получаем черный список удаленных услуг deleted_services = DeletedCarService.objects.filter( car=obj, service_type='LINE' ).values_list('service_id', flat=True) for service in line_services: # Проверяем, не была ли услуга удалена if f'line_{service.id}' in removed_services: continue # Проверяем черный список if service.id in deleted_services: continue # Если услуги еще нет в CarService, создаем её автоматически if service.id not in existing_car_service_ids: field_name = f'line_service_{service.id}' value = request.POST.get(field_name) or service.default_price # Получаем default_markup из услуги default_markup = getattr(service, 'default_markup", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "rvice_ids: field_name = f'line_service_{service.id}' value = request.POST.get(field_name) or service.default_price # Получаем default_markup из услуги default_markup = getattr(service, 'default_markup', 0) or 0 CarService.objects.create( car=obj, service_type='LINE', service_id=service.id, custom_price=float(value), markup_amount=float(default_markup) ) # Обрабатываем поля услуг перевозчика # Сначала обновляем ВСЕ существующие услуги перевозчика existing_carrier_car_services = CarService.objects.filter( car=obj, service_type='CARRIER' ) for car_service in existing_carrier_car_services: # Проверяем, не была ли услуга удалена if f'carrier_{car_service.service_id}' in removed_services: continue field_name = f'carrier_service_{car_service.service_id}' value = request.POST.get(field_name) if value: try: car_service.custom_price = float(value) except (ValueError, TypeError): pass # Сохраняем скрытую наценку markup_field = f'markup_carrier_service_{car_service.service_id}' markup_value = request.POST.get(markup_field, '0') try: car_service.markup_amount = float(markup_value) if markup_value else 0 except (ValueError, TypeError): car_service.markup_amount = 0 car_service.save() # Затем соз", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "est.POST.get(markup_field, '0') try: car_service.markup_amount = float(markup_value) if markup_value else 0 except (ValueError, TypeError): car_service.markup_amount = 0 car_service.save() # Затем создаём новые услуги из справочника (если нужно) if obj.carrier: carrier_services = CarrierService.objects.filter( carrier=obj.carrier, is_active=True, default_price__gt=0 ).only('id', 'default_price') existing_car_service_ids = set(existing_carrier_car_services.values_list('service_id', flat=True)) # Получаем черный список удаленных услуг deleted_services = DeletedCarService.objects.filter( car=obj, service_type='CARRIER' ).values_list('service_id', flat=True) for service in carrier_services: # Проверяем, не была ли услуга удалена if f'carrier_{service.id}' in removed_services: continue # Проверяем черный список if service.id in deleted_services: continue # Если услуги еще нет в CarService, создаем её автоматически if service.id not in existing_car_service_ids: field_name = f'carrier_service_{service.id}' value = request.POST.get(field_name) or service.default_price # Получаем default_markup из услуги default_markup = getattr(service, 'default_markup', 0) or 0 CarService.objects.create( ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "_{service.id}' value = request.POST.get(field_name) or service.default_price # Получаем default_markup из услуги default_markup = getattr(service, 'default_markup', 0) or 0 CarService.objects.create( car=obj, service_type='CARRIER', service_id=service.id, custom_price=float(value), markup_amount=float(default_markup) ) # Обрабатываем услуги компаний existing_company_car_services = CarService.objects.filter( car=obj, service_type='COMPANY' ) for car_service in existing_company_car_services: if f'company_{car_service.service_id}' in removed_services: continue field_name = f'company_service_{car_service.service_id}' value = request.POST.get(field_name) if value: try: car_service.custom_price = float(value) except (ValueError, TypeError): pass markup_field = f'markup_company_service_{car_service.service_id}' markup_value = request.POST.get(markup_field, '0') try: car_service.markup_amount = float(markup_value) if markup_value else 0 except (ValueError, TypeError): car_service.markup_amount = 0 car_service.save() # Пересчитываем стоимость хранения и дни при смене склада if change and form and 'warehouse' in getattr(form, 'changed_data', []): print(f\"Склад изменился для автомобиля {obj.v", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": " = 0 car_service.save() # Пересчитываем стоимость хранения и дни при смене склада if change and form and 'warehouse' in getattr(form, 'changed_data', []): print(f\"Склад изменился для автомобиля {obj.vin}, пересчитываем стоимость хранения\") try: # Обновляем поля на основе нового склада obj.update_days_and_storage() obj.calculate_total_price() # Сохраняем обновленные поля obj.save(update_fields=['storage_cost', 'days', 'total_price']) print(f\"Обновлены поля: storage_cost={obj.storage_cost}, days={obj.days}\") except Exception as e: print(f\"Ошибка при пересчете стоимости хранения: {e}\") def warehouse_services_display(self, obj): \"\"\"Отображает редактируемые поля для услуг всех складов\"\"\" try: # Получаем ВСЕ услуги склада, которые уже связаны с автомобилем (от любых складов) car_services = CarService.objects.filter( car=obj, service_type='WAREHOUSE' ).select_related('car') html = '<div style=\"margin: 10px 0; display: flex; flex-wrap: wrap; gap: 10px;\">' if car_services: for car_service in car_services: try: # Получаем детали услуги и склада service = WarehouseService.objects.select_related('warehouse').get(id=car_service.service_id) current_value = car_service.custom_price or service.def", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "r_services: try: # Получаем детали услуги и склада service = WarehouseService.objects.select_related('warehouse').get(id=car_service.service_id) current_value = car_service.custom_price or service.default_price markup_value = car_service.markup_amount or 0 warehouse_name = service.warehouse.name # Подсветка: основной склад - зеленый, другие - желтый bg_color = \"#e8f5e9\" if (obj.warehouse and service.warehouse.id == obj.warehouse.id) else \"#fff9e6\" html += f''' <div style=\"border: 1px solid #ddd; padding: 10px; background: {bg_color}; position: relative; min-width: 220px;\"> <button type=\"button\" onclick=\"removeService({service.id}, 'warehouse')\" style=\"position: absolute; top: 5px; right: 5px; background: #dc3545; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; cursor: pointer; font-size: 12px;\">×</button> <div style=\"font-size: 11px; color: #666; margin-bottom: 3px;\">📦 {warehouse_name}</div> <strong>{service.name}</strong><br> <div style=\"display: flex; gap: 5px; align-items: center; margin-top: 5px;\"> <input type=\"number\" name=\"warehouse_service_{service.id}\" value=\"{current_value}\" step=\"0.01\" style=\"width: 80px;\" title=\"Цена услуги\"> <span style=\"color", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "5px; align-items: center; margin-top: 5px;\"> <input type=\"number\" name=\"warehouse_service_{service.id}\" value=\"{current_value}\" step=\"0.01\" style=\"width: 80px;\" title=\"Цена услуги\"> <span style=\"color: #28a745; font-weight: bold;\">+</span> <input type=\"number\" name=\"markup_warehouse_service_{service.id}\" value=\"{markup_value}\" step=\"0.01\" style=\"width: 60px; background: #fffde7; border-color: #ffc107;\" title=\"Скрытая наценка\" placeholder=\"0\"> </div> <input type=\"hidden\" name=\"remove_warehouse_service_{service.id}\" id=\"remove_warehouse_service_{service.id}\" value=\"\"> </div> ''' except Exception as e: continue html += '</div>' # Кнопка для добавления услуг - теперь всегда доступна html += f''' <div style=\"margin-top: 10px;\"> <button type=\"button\" class=\"add-service-btn\" onclick=\"openModal('warehouseServicesModal', 'warehouse')\" title=\"Добавить услуги любого склада\"> + </button> <span style=\"margin-left: 5px; color: #666;\">Добавить услуги склада</span> </div> ''' # Добавляем JavaScript для удаления услуг html += ''' <script> function removeService(serviceId, serviceType) { const serviceDiv = event.target.closest('div'); serviceDiv.style.display = 'none'; const hiddenField = document.g", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "я удаления услуг html += ''' <script> function removeService(serviceId, serviceType) { const serviceDiv = event.target.closest('div'); serviceDiv.style.display = 'none'; const hiddenField = document.getElementById('remove_' + serviceType + '_service_' + serviceId); hiddenField.value = '1'; console.log('Removed service:', serviceType, serviceId, 'Field value:', hiddenField.value); } </script> ''' return mark_safe(html) except Exception as e: return f\"Ошибка загрузки услуг: {e}\" warehouse_services_display.short_description = \"Услуги склада\" def line_services_display(self, obj): \"\"\"Отображает редактируемые поля для услуг линии\"\"\" if not obj.line: return \"Линия не выбрана\" try: # Получаем услуги линии, которые уже связаны с автомобилем car_services = CarService.objects.filter( car=obj, service_type='LINE' ) html = '<div style=\"margin: 10px 0; display: flex; flex-wrap: wrap; gap: 10px;\">' for car_service in car_services: try: # Получаем детали услуги service = LineService.objects.get(id=car_service.service_id) current_value = car_service.custom_price or service.default_price markup_value = car_service.markup_amount or 0 html += f''' <div style=\"border: 1px solid #ddd; padding: 10px; bac", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "_service.service_id) current_value = car_service.custom_price or service.default_price markup_value = car_service.markup_amount or 0 html += f''' <div style=\"border: 1px solid #ddd; padding: 10px; background: #e3f2fd; position: relative; min-width: 200px;\"> <button type=\"button\" onclick=\"removeService({service.id}, 'line')\" style=\"position: absolute; top: 5px; right: 5px; background: #dc3545; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; cursor: pointer; font-size: 12px;\">×</button> <strong>{service.name}</strong><br> <div style=\"display: flex; gap: 5px; align-items: center; margin-top: 5px;\"> <input type=\"number\" name=\"line_service_{service.id}\" value=\"{current_value}\" step=\"0.01\" style=\"width: 80px;\" title=\"Цена услуги\"> <span style=\"color: #28a745; font-weight: bold;\">+</span> <input type=\"number\" name=\"markup_line_service_{service.id}\" value=\"{markup_value}\" step=\"0.01\" style=\"width: 60px; background: #fffde7; border-color: #ffc107;\" title=\"Скрытая наценка\" placeholder=\"0\"> </div> <input type=\"hidden\" name=\"remove_line_service_{service.id}\" id=\"remove_line_service_{service.id}\" value=\"\"> </div> ''' except: continue html += '</div>' # Добавляем кнопк", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "нка\" placeholder=\"0\"> </div> <input type=\"hidden\" name=\"remove_line_service_{service.id}\" id=\"remove_line_service_{service.id}\" value=\"\"> </div> ''' except: continue html += '</div>' # Добавляем кнопку для добавления новых услуг if obj.line: html += f''' <div style=\"margin-top: 10px;\"> <button type=\"button\" class=\"add-service-btn\" onclick=\"openModal('lineServicesModal', 'line')\" title=\"Добавить услуги линии\"> + </button> <span style=\"margin-left: 5px; color: #666;\">Добавить услуги линии</span> </div> ''' if not car_services: html += '<div style=\"margin-top: 8px; color: #6c757d;\">Услуги еще не добавлены. Используйте кнопку “+”.</div>' return mark_safe(html) except Exception as e: return f\"Ошибка загрузки услуг: {e}\" line_services_display.short_description = \"Услуги линии\" def carrier_services_display(self, obj): \"\"\"Отображает редактируемые поля для услуг перевозчика\"\"\" if not obj.carrier: return \"Перевозчик не выбран\" try: # Получаем услуги перевозчика, которые уже связаны с автомобилем car_services = CarService.objects.filter( car=obj, service_type='CARRIER' ) html = '<div style=\"margin: 10px 0; display: flex; flex-wrap: wrap; gap: 10px;\">' for car_service in car_services: try: # П", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": " car_services = CarService.objects.filter( car=obj, service_type='CARRIER' ) html = '<div style=\"margin: 10px 0; display: flex; flex-wrap: wrap; gap: 10px;\">' for car_service in car_services: try: # Получаем детали услуги service = CarrierService.objects.get(id=car_service.service_id) current_value = car_service.custom_price or service.default_price markup_value = car_service.markup_amount or 0 html += f''' <div style=\"border: 1px solid #ddd; padding: 10px; background: #fff3e0; position: relative; min-width: 200px;\"> <button type=\"button\" onclick=\"removeService({service.id}, 'carrier')\" style=\"position: absolute; top: 5px; right: 5px; background: #dc3545; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; cursor: pointer; font-size: 12px;\">×</button> <strong>{service.name}</strong><br> <div style=\"display: flex; gap: 5px; align-items: center; margin-top: 5px;\"> <input type=\"number\" name=\"carrier_service_{service.id}\" value=\"{current_value}\" step=\"0.01\" style=\"width: 80px;\" title=\"Цена услуги\"> <span style=\"color: #28a745; font-weight: bold;\">+</span> <input type=\"number\" name=\"markup_carrier_service_{service.id}\" value=\"{markup_value}\" step=\"0.01\" style=\"wid", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "dth: 80px;\" title=\"Цена услуги\"> <span style=\"color: #28a745; font-weight: bold;\">+</span> <input type=\"number\" name=\"markup_carrier_service_{service.id}\" value=\"{markup_value}\" step=\"0.01\" style=\"width: 60px; background: #fffde7; border-color: #ffc107;\" title=\"Скрытая наценка\" placeholder=\"0\"> </div> <input type=\"hidden\" name=\"remove_carrier_service_{service.id}\" id=\"remove_carrier_service_{service.id}\" value=\"\"> </div> ''' except: continue html += '</div>' # Добавляем кнопку для добавления новых услуг if obj.carrier: html += f''' <div style=\"margin-top: 10px;\"> <button type=\"button\" class=\"add-service-btn\" onclick=\"openModal('carrierServicesModal', 'carrier')\" title=\"Добавить услуги перевозчика\"> + </button> <span style=\"margin-left: 5px; color: #666;\">Добавить услуги перевозчика</span> </div> ''' if not car_services: html += '<div style=\"margin-top: 8px; color: #6c757d;\">Услуги еще не добавлены. Используйте кнопку “+”.</div>' return mark_safe(html) except Exception as e: return f\"Ошибка загрузки услуг: {e}\" carrier_services_display.short_description = \"Услуги перевозчика\" def company_services_display(self, obj): \"\"\"Отображает редактируемые поля для услуг компаний\"\"\" try: car_ser", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ибка загрузки услуг: {e}\" carrier_services_display.short_description = \"Услуги перевозчика\" def company_services_display(self, obj): \"\"\"Отображает редактируемые поля для услуг компаний\"\"\" try: car_services = CarService.objects.filter( car=obj, service_type='COMPANY' ) html = '<div style=\"margin: 10px 0; display: flex; flex-wrap: wrap; gap: 10px;\">' if car_services: for car_service in car_services: try: service = CompanyService.objects.select_related('company').get(id=car_service.service_id) current_value = car_service.custom_price if car_service.custom_price is not None else service.default_price markup_value = car_service.markup_amount or 0 html += f''' <div style=\"border: 1px solid #ddd; padding: 10px; background: #f3e8ff; position: relative; min-width: 240px;\"> <button type=\"button\" onclick=\"removeService({service.id}, 'company')\" style=\"position: absolute; top: 5px; right: 5px; background: #dc3545; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; cursor: pointer; font-size: 12px;\">×</button> <div style=\"font-size: 11px; color: #666; margin-bottom: 3px;\">🏢 {service.company.name}</div> <strong>{service.name}</strong><br> <div style=\"display: flex; gap: 5", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ointer; font-size: 12px;\">×</button> <div style=\"font-size: 11px; color: #666; margin-bottom: 3px;\">🏢 {service.company.name}</div> <strong>{service.name}</strong><br> <div style=\"display: flex; gap: 5px; align-items: center; margin-top: 5px;\"> <input type=\"number\" name=\"company_service_{service.id}\" value=\"{current_value}\" step=\"0.01\" style=\"width: 80px;\" title=\"Цена услуги\"> <span style=\"color: #28a745; font-weight: bold;\">+</span> <input type=\"number\" name=\"markup_company_service_{service.id}\" value=\"{markup_value}\" step=\"0.01\" style=\"width: 60px; background: #fffde7; border-color: #ffc107;\" title=\"Скрытая наценка\" placeholder=\"0\"> </div> <input type=\"hidden\" name=\"remove_company_service_{service.id}\" id=\"remove_company_service_{service.id}\" value=\"\"> </div> ''' except Exception: continue html += '</div>' html += f''' <div style=\"margin-top: 10px;\"> <button type=\"button\" class=\"add-service-btn\" onclick=\"openModal('companyServicesModal', 'company')\" title=\"Добавить услуги компании\"> + </button> <span style=\"margin-left: 5px; color: #666;\">Добавить услуги компании</span> </div> ''' return mark_safe(html) except Exception as e: return f\"Ошибка загрузки услуг: {e}\" company_services_d", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": " </button> <span style=\"margin-left: 5px; color: #666;\">Добавить услуги компании</span> </div> ''' return mark_safe(html) except Exception as e: return f\"Ошибка загрузки услуг: {e}\" company_services_display.short_description = \"Услуги компаний\" def get_changelist(self, request, **kwargs): \"\"\"Добавляет фильтрацию по умолчанию для статусов 'В порту' и 'Разгружен'\"\"\" # Если нет параметров фильтрации, добавляем фильтр по умолчанию if not request.GET.get('status_multi'): # Создаем копию GET параметров get_params = request.GET.copy() get_params.setlist('status_multi', ['IN_PORT', 'UNLOADED']) request.GET = get_params return super().get_changelist(request, **kwargs) # WarehouseServiceInline удален - используется кастомный раздел \"Управление услугами\" # Временно отключаем старый админ # @admin.register(Warehouse) # class WarehouseAdmin(admin.ModelAdmin): @admin.register(Warehouse) class WarehouseAdmin(admin.ModelAdmin): list_display = ('name', 'address', 'free_days', 'balance_display') search_fields = ('name', 'address') readonly_fields = ('balance',) exclude = ( 'default_unloading_fee', 'delivery_to_warehouse', 'loading_on_trawl', 'documents_fee', 'transfer_fee', 'transit_declaration', 'e", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "fields = ('name', 'address') readonly_fields = ('balance',) exclude = ( 'default_unloading_fee', 'delivery_to_warehouse', 'loading_on_trawl', 'documents_fee', 'transfer_fee', 'transit_declaration', 'export_declaration', 'additional_expenses', 'complex_fee' ) inlines = [WarehouseServiceInline] fieldsets = ( ('Основные данные', { 'fields': ('name', 'address') }), ('Настройки хранения', { 'fields': ('free_days',), 'description': 'Бесплатные дни хранения. Ставка за сутки берётся из услуги \"Хранение\" в списке услуг склада.' }), ('Баланс', { 'fields': ('balance',), 'description': 'Баланс склада' }), ) def balance_display(self, obj): \"\"\"Показывает баланс склада\"\"\" try: balance = obj.balance or 0 color = '#28a745' if balance >= 0 else '#dc3545' sign = '+' if balance >= 0 else '' return format_html( '<span style=\"color:{}; font-weight:bold;\">{} {:.2f}</span>', color, sign, balance ) except: return '-' balance_display.short_description = 'Баланс' def balance_summary_display(self, obj): \"\"\"Показывает сводку по балансу склада\"\"\" try: balance = obj.balance or 0 html = f\"\"\" <div style=\"background:#f8f9fa; padding:15px; border-radius:8px; border:1px solid #dee2e6;\"> <h3 style=\"margin-top:0; color", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "вает сводку по балансу склада\"\"\" try: balance = obj.balance or 0 html = f\"\"\" <div style=\"background:#f8f9fa; padding:15px; border-radius:8px; border:1px solid #dee2e6;\"> <h3 style=\"margin-top:0; color:#495057;\">Баланс склада</h3> <div style=\"background:white; padding:10px; border-radius:5px; border:1px solid #dee2e6;\"> <strong>Баланс:</strong><br> <span style=\"font-size:18px; color:{'#28a745' if balance >= 0 else '#dc3545'};\">{balance:.2f}</span> </div> </div> <div style=\"background:white; padding:15px; border-radius:5px; border:2px solid {'#28a745' if total_balance >= 0 else '#dc3545'};\"> <strong style=\"color:{'#28a745' if total_balance >= 0 else '#dc3545'};\">Общий баланс:</strong><br> <span style=\"font-size:24px; font-weight:bold; color:{'#28a745' if total_balance >= 0 else '#dc3545'};\">{total_balance:.2f}</span> </div> </div> \"\"\" return format_html(html) except Exception as e: return format_html(f'<p style=\"color:#dc3545;\">Ошибка загрузки баланса: {e}</p>') balance_summary_display.short_description = 'Сводка по балансу' def balance_transactions_display(self, obj): \"\"\"Показывает платежи склада\"\"\" try: # Получаем все платежи для склада payments = Payment.objects.filter( models.Q(f", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "hort_description = 'Сводка по балансу' def balance_transactions_display(self, obj): \"\"\"Показывает платежи склада\"\"\" try: # Получаем все платежи для склада payments = Payment.objects.filter( models.Q(from_warehouse=obj) | models.Q(to_warehouse=obj) ).order_by('-date', '-id')[:20] # Последние 20 платежей if not payments.exists(): return format_html('<p style=\"color:#6c757d;\">Нет платежей</p>') html = ['<div style=\"margin-top:15px;\">'] html.append('<h4 style=\"margin-bottom:10px; color:#495057;\">Последние платежи</h4>') html.append('<table style=\"width:100%; border-collapse:collapse; font-size:12px;\">') html.append('<tr style=\"background-color:#f8f9fa;\">') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Дата</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Тип</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Сумма</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Отправитель</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Получатель</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "x; text-align:left;\">Отправитель</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Получатель</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Описание</th>') html.append('</tr>') for payment in payments: amount_color = '#28a745' if payment.to_warehouse == obj else '#dc3545' html.append('<tr>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{payment.date.strftime(\"%d.%m.%Y\")}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{payment.payment_type}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px; color:{amount_color}; font-weight:bold;\">{payment.amount:.2f}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{payment.sender}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{payment.recipient}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{payment.description or \"-\"}</td>') html.append('</tr>') html.append('</table>') html.append('</div>') return format_html(''.join(html)) except Exception as e: return format_html(f'<p style=\"color:#dc3545;\">Ошибка загрузки платежей: {e}</p>') ba", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "nd('</tr>') html.append('</table>') html.append('</div>') return format_html(''.join(html)) except Exception as e: return format_html(f'<p style=\"color:#dc3545;\">Ошибка загрузки платежей: {e}</p>') balance_transactions_display.short_description = 'Платежи' def reset_warehouse_balance(self, request, queryset): \"\"\"Обнуляет балансы выбранных складов\"\"\" from django.contrib import messages try: for warehouse in queryset: warehouse.balance = 0 warehouse.save() messages.success(request, f'Балансы {queryset.count()} складов успешно обнулены') except Exception as e: messages.error(request, f'Ошибка при обнулении балансов: {e}') reset_warehouse_balance.short_description = 'Обнулить балансы выбранных складов' def change_view(self, request, object_id, form_url='', extra_context=None): \"\"\"Переопределяем change_view для обработки услуг\"\"\" extra_context = extra_context or {} if object_id: obj = self.get_object(request, object_id) if request.method == 'POST': # Обрабатываем существующие услуги for key, value in request.POST.items(): if key.startswith('service_name_'): service_id = key.replace('service_name_', '') # Проверяем, что это действительно ID услуги (число) if service_id.isdigit(): try: se", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": ", value in request.POST.items(): if key.startswith('service_name_'): service_id = key.replace('service_name_', '') # Проверяем, что это действительно ID услуги (число) if service_id.isdigit(): try: service = WarehouseService.objects.get(id=service_id, warehouse=obj) service.name = value service.save() except WarehouseService.DoesNotExist: pass elif key.startswith('service_price_'): service_id = key.replace('service_price_', '') # Проверяем, что это действительно ID услуги (число) if service_id.isdigit(): try: service = WarehouseService.objects.get(id=service_id, warehouse=obj) service.default_price = float(value) if value else 0 service.save() except (WarehouseService.DoesNotExist, ValueError): pass elif key.startswith('delete_service_'): service_id = key.replace('delete_service_', '') try: service = WarehouseService.objects.get(id=service_id, warehouse=obj) service.delete() except WarehouseService.DoesNotExist: pass # Обрабатываем старые поля услуг old_fields_mapping = { 'service_price_complex': 'complex_fee', 'service_price_unloading': 'default_unloading_fee', 'service_price_delivery': 'delivery_to_warehouse', 'service_price_loading': 'loading_on_trawl', 'service_price_documents'", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "e_complex': 'complex_fee', 'service_price_unloading': 'default_unloading_fee', 'service_price_delivery': 'delivery_to_warehouse', 'service_price_loading': 'loading_on_trawl', 'service_price_documents': 'documents_fee', 'service_price_transfer': 'transfer_fee', 'service_price_transit': 'transit_declaration', 'service_price_export': 'export_declaration', 'service_price_additional': 'additional_expenses', 'service_price_rate': 'rate', } # Сначала проверяем, какие поля нужно обнулить for key, value in request.POST.items(): if key.startswith('clear_field_'): field_name = key.replace('clear_field_', '') setattr(obj, field_name, 0) obj.save() # Затем обновляем значения полей for field_name, model_field in old_fields_mapping.items(): if field_name in request.POST: try: value = float(request.POST[field_name]) if request.POST[field_name] else 0 setattr(obj, model_field, value) obj.save() except ValueError: pass # Обрабатываем новые услуги for key, value in request.POST.items(): if key.startswith('new_service_name_'): index = key.replace('new_service_name_', '') name = value price = request.POST.get(f'new_service_price_{index}', 0) if name: try: WarehouseService.objects.create( warehouse=obj,", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "('new_service_name_'): index = key.replace('new_service_name_', '') name = value price = request.POST.get(f'new_service_price_{index}', 0) if name: try: WarehouseService.objects.create( warehouse=obj, name=name, default_price=float(price) if price else 0 ) except ValueError: pass return super().change_view(request, object_id, form_url, extra_context) # ============================================================================ # СТАРАЯ АДМИНКА INVOICE - УДАЛЕНА # ============================================================================ # Используйте NewInvoiceAdmin из admin_billing.py # ============================================================================ # @admin.register(InvoiceOLD) # Отключено # ============================================================================ # СТАРАЯ АДМИНКА PAYMENT - УДАЛЕНА # ============================================================================ # Используйте TransactionAdmin из admin_billing.py # ============================================================================ # @admin.register(PaymentOLD) # Отключено @admin.register(Client) class ClientAdmin(admin.ModelAdmin): change_form_template = 'admin/client_change.html' list_di", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "======================================= # @admin.register(PaymentOLD) # Отключено @admin.register(Client) class ClientAdmin(admin.ModelAdmin): change_form_template = 'admin/client_change.html' list_display = ('name', 'emails_display', 'notification_enabled', 'new_balance_display', 'balance_status_new') list_filter = ('name', 'notification_enabled') search_fields = ('name', 'email', 'email2', 'email3', 'email4') actions = ['reset_balances', 'recalculate_balance', 'reset_client_balance'] readonly_fields = ('balance', 'balance_updated_at', 'new_invoices_display', 'new_transactions_display') def get_queryset(self, request): \"\"\"ОПТИМИЗАЦИЯ: Используем with_balance_info для предрасчета данных\"\"\" qs = super().get_queryset(request) # Для list view используем оптимизированный менеджер с annotate if 'changelist' in request.path: return qs.with_balance_info() return qs fieldsets = ( ('Основная информация', { 'fields': ('name', 'notification_enabled') }), ('📧 Email-адреса для уведомлений', { 'fields': ('email', 'email2', 'email3', 'email4'), 'description': 'Уведомления о разгрузке контейнеров будут отправлены на все указанные адреса' }), ('💰 Баланс', { 'fields': ('balance', 'balance_updated_at", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ds': ('email', 'email2', 'email3', 'email4'), 'description': 'Уведомления о разгрузке контейнеров будут отправлены на все указанные адреса' }), ('💰 Баланс', { 'fields': ('balance', 'balance_updated_at', 'new_invoices_display', 'new_transactions_display'), 'description': 'Единый баланс клиента с историей транзакций' }), ) def emails_display(self, obj): \"\"\"Отображает количество email-адресов\"\"\" emails = obj.get_notification_emails() count = len(emails) if count == 0: return format_html('<span style=\"color: #999;\">—</span>') elif count == 1: return format_html('<span title=\"{}\">{}</span>', emails[0], emails[0]) else: all_emails = ', '.join(emails) return format_html('<span title=\"{}\">{} (+{})</span>', all_emails, emails[0], count - 1) emails_display.short_description = 'Email' def real_balance_display(self, obj): \"\"\"Показывает инвойс-баланс клиента (инвойсы - платежи)\"\"\" balance = obj.real_balance color = obj.balance_color sign = '' if balance == 0 else ('+' if balance > 0 else '') formatted = f\"{balance:.2f}\" return format_html( '<span style=\"color:{}; font-weight:bold; font-size:14px;\">{} {}</span>', color, sign, formatted ) real_balance_display.short_description = 'Инвойс-баланс (Д", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ted = f\"{balance:.2f}\" return format_html( '<span style=\"color:{}; font-weight:bold; font-size:14px;\">{} {}</span>', color, sign, formatted ) real_balance_display.short_description = 'Инвойс-баланс (Долг/Переплата)' real_balance_display.admin_order_field = '_real_balance_annotated' def balance_status_display(self, obj): \"\"\"Показывает статус баланса цветным бейджем\"\"\" status = obj.balance_status color = obj.balance_color bg_color = color.replace('#', '') return format_html( '<span style=\"background-color:{}; color:white; padding:4px 8px; border-radius:4px; font-size:11px; font-weight:bold;\">{}</span>', color, status ) balance_status_display.short_description = 'Статус' def new_balance_display(self, obj): \"\"\"НОВАЯ СИСТЕМА - единый баланс\"\"\" balance = obj.balance if balance > 0: color = '#28a745' text = f'+{balance:.2f}' elif balance < 0: color = '#dc3545' text = f'{balance:.2f}' else: color = '#6c757d' text = '0.00' return format_html( '<span style=\"color:{}; font-weight:bold; font-size:15px;\">{}</span>', color, text ) new_balance_display.short_description = 'Баланс' new_balance_display.admin_order_field = 'balance' def balance_status_new(self, obj): \"\"\"Статус нового баланса\"\"\" balan", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "15px;\">{}</span>', color, text ) new_balance_display.short_description = 'Баланс' new_balance_display.admin_order_field = 'balance' def balance_status_new(self, obj): \"\"\"Статус нового баланса\"\"\" balance = obj.balance if balance > 0: return format_html('<span style=\"background:#28a745; color:white; padding:3px 8px; border-radius:3px;\">ПЕРЕПЛАТА</span>') elif balance < 0: return format_html('<span style=\"background:#dc3545; color:white; padding:3px 8px; border-radius:3px;\">ДОЛГ</span>') else: return format_html('<span style=\"background:#6c757d; color:white; padding:3px 8px; border-radius:3px;\">OK</span>') balance_status_new.short_description = 'Статус' def new_invoices_display(self, obj): \"\"\"Показывает инвойсы из новой системы\"\"\" from core.models_billing import NewInvoice invoices = NewInvoice.objects.filter(recipient_client=obj).order_by('-date')[:10] if not invoices: return format_html('<p style=\"color:#999;\">Инвойсов еще нет. <a href=\"/admin/core/newinvoice/add/\">Создать первый инвойс</a></p>') html = '<table style=\"width:100%; border-collapse:collapse;\">' html += '<tr style=\"background:#f5f5f5;\"><th style=\"padding:8px;\">Номер</th><th>Дата</th><th>Сумма</th><th>Оплачено</th><th>Ст", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "</a></p>') html = '<table style=\"width:100%; border-collapse:collapse;\">' html += '<tr style=\"background:#f5f5f5;\"><th style=\"padding:8px;\">Номер</th><th>Дата</th><th>Сумма</th><th>Оплачено</th><th>Статус</th></tr>' for inv in invoices: status_color = {'PAID': '#28a745', 'ISSUED': '#007bff', 'OVERDUE': '#dc3545'}.get(inv.status, '#6c757d') html += f'''<tr style=\"border-bottom:1px solid #ddd;\"> <td style=\"padding:8px;\"><a href=\"/admin/core/newinvoice/{inv.pk}/change/\">{inv.number}</a></td> <td style=\"padding:8px;\">{inv.date.strftime(\"%d.%m.%Y\")}</td> <td style=\"padding:8px;\">{inv.total:.2f}</td> <td style=\"padding:8px;\">{inv.paid_amount:.2f}</td> <td style=\"padding:8px;\"><span style=\"background:{status_color}; color:white; padding:2px 6px; border-radius:3px;\">{inv.get_status_display()}</span></td> </tr>''' html += '</table>' return format_html(html) new_invoices_display.short_description = 'Инвойсы' def new_transactions_display(self, obj): \"\"\"Показывает транзакции из новой системы\"\"\" from core.models_billing import Transaction transactions = Transaction.objects.filter( models.Q(from_client=obj) | models.Q(to_client=obj) ).order_by('-date')[:10] if not transactions: return format_htm", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "om core.models_billing import Transaction transactions = Transaction.objects.filter( models.Q(from_client=obj) | models.Q(to_client=obj) ).order_by('-date')[:10] if not transactions: return format_html('<p style=\"color:#999;\">Транзакций еще нет</p>') html = '<table style=\"width:100%; border-collapse:collapse;\">' html += '<tr style=\"background:#f5f5f5;\"><th style=\"padding:8px;\">Номер</th><th>Дата</th><th>Тип</th><th>Сумма</th><th>Направление</th></tr>' for trx in transactions: type_color = {'PAYMENT': '#28a745', 'REFUND': '#dc3545'}.get(trx.type, '#007bff') direction = '↑ Получено' if trx.to_client == obj else '↓ Отправлено' html += f'''<tr style=\"border-bottom:1px solid #ddd;\"> <td style=\"padding:8px;\"><a href=\"/admin/core/transaction/{trx.pk}/change/\">{trx.number}</a></td> <td style=\"padding:8px;\">{trx.date.strftime(\"%d.%m.%Y %H:%M\")}</td> <td style=\"padding:8px;\"><span style=\"background:{type_color}; color:white; padding:2px 6px; border-radius:3px;\">{trx.get_type_display()}</span></td> <td style=\"padding:8px; font-weight:bold;\">{trx.amount:.2f}</td> <td style=\"padding:8px;\">{direction}</td> </tr>''' html += '</table>' return format_html(html) new_transactions_display.short_descri", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "d> <td style=\"padding:8px; font-weight:bold;\">{trx.amount:.2f}</td> <td style=\"padding:8px;\">{direction}</td> </tr>''' html += '</table>' return format_html(html) new_transactions_display.short_description = 'Транзакции' def recalculate_balance(self, request, queryset): \"\"\"Пересчитывает инвойс-баланс для выбранных клиентов\"\"\" from django.contrib import messages count = 0 for client in queryset: try: # Пересчитываем инвойс-баланс клиента client.sync_balance_fields() count += 1 messages.success(request, f'Инвойс-баланс клиента {client.name} пересчитан') except Exception as e: messages.error(request, f'Ошибка при пересчете инвойс-баланса клиента {client.name}: {e}') if count > 0: messages.success(request, f'Успешно пересчитан инвойс-баланс для {count} клиентов') else: messages.warning(request, 'Не удалось пересчитать инвойс-баланс ни для одного клиента') recalculate_balance.short_description = 'Пересчитать инвойс-баланс' def sync_all_balances(self, request, queryset): \"\"\"Синхронизирует поля баланса с инвойс-балансом для выбранных клиентов\"\"\" from django.contrib import messages count = 0 for client in queryset: try: client.sync_balance_fields() count += 1 messages.success(request, f'Ин", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ля баланса с инвойс-балансом для выбранных клиентов\"\"\" from django.contrib import messages count = 0 for client in queryset: try: client.sync_balance_fields() count += 1 messages.success(request, f'Инвойс-баланс клиента {client.name} синхронизирован') except Exception as e: messages.error(request, f'Ошибка при синхронизации инвойс-баланса клиента {client.name}: {e}') if count > 0: messages.success(request, f'Успешно синхронизирован инвойс-баланс для {count} клиентов') else: messages.warning(request, 'Не удалось синхронизировать инвойс-баланс ни для одного клиента') sync_all_balances.short_description = 'Синхронизировать инвойс-балансы' def get_queryset(self, request): \"\"\"Получаем queryset с оптимизацией\"\"\" return Client.objects.with_balance_info() def change_view(self, request, object_id, form_url='', extra_context=None): extra_context = extra_context or {} client = self.get_object(request, object_id) if client: try: summary = client.get_balance_summary() extra_context['balance_summary'] = summary except Exception as e: logger.error(f\"Failed to get balance summary for client {client.name}: {e}\") extra_context['balance_summary_error'] = f\"Ошибка загрузки сводки баланса: {str(e)}\" re", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "'] = summary except Exception as e: logger.error(f\"Failed to get balance summary for client {client.name}: {e}\") extra_context['balance_summary_error'] = f\"Ошибка загрузки сводки баланса: {str(e)}\" return super().change_view(request, object_id, form_url, extra_context) def reset_balances(self, request, queryset): if 'confirm' in request.POST: client_ids = request.POST.getlist('_selected_action') clients = Client.objects.filter(id__in=client_ids) from django.core.management import call_command failed_clients = [] for client in clients: try: call_command('reset_client_balances', client_id=client.id) except Exception as e: logger.error(f\"Failed to reset balance for client {client.name}: {e}\") failed_clients.append(f\"{client.name}: {str(e)}\") if failed_clients: self.message_user(request, f\"Не удалось сбросить балансы для некоторых клиентов: {'; '.join(failed_clients)}\", level='error') else: self.message_user(request, f\"Балансы для {len(clients)} клиентов успешно обнулены\") return HttpResponseRedirect(request.get_full_path()) return render(request, 'admin/confirm_reset_balances.html', { 'clients': queryset, 'action': 'reset_balances', 'action_name': 'Обнулить балансы' }) reset_balances.", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "nseRedirect(request.get_full_path()) return render(request, 'admin/confirm_reset_balances.html', { 'clients': queryset, 'action': 'reset_balances', 'action_name': 'Обнулить балансы' }) reset_balances.short_description = \"Обнулить балансы клиентов\" def reset_client_balance(self, request, queryset): \"\"\"Обнуляет балансы выбранных клиентов\"\"\" from django.contrib import messages try: for client in queryset: client.balance = 0 client.save() messages.success(request, f'Балансы {queryset.count()} клиентов успешно обнулены') except Exception as e: messages.error(request, f'Ошибка при обнулении балансов: {e}') reset_client_balance.short_description = 'Обнулить балансы выбранных клиентов' # ======================================================================== # ПОПОЛНЕНИЕ И УПРАВЛЕНИЕ БАЛАНСОМ КЛИЕНТА # ======================================================================== def get_urls(self): from django.urls import path urls = super().get_urls() custom_urls = [ path('<int:client_id>/topup/', self.admin_site.admin_view(self.topup_balance_view), name='client_topup'), path('<int:client_id>/reset-balance/', self.admin_site.admin_view(self.reset_balance_view), name='client_reset_balance'), p", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": ", self.admin_site.admin_view(self.topup_balance_view), name='client_topup'), path('<int:client_id>/reset-balance/', self.admin_site.admin_view(self.reset_balance_view), name='client_reset_balance'), path('<int:client_id>/recalc-balance/', self.admin_site.admin_view(self.recalc_balance_view), name='client_recalc_balance'), path('<int:client_id>/cars-in-warehouse/', self.admin_site.admin_view(self.cars_in_warehouse_view), name='client_cars_in_warehouse'), ] return custom_urls + urls def topup_balance_view(self, request, client_id): \"\"\"Страница пополнения баланса клиента\"\"\" from django.shortcuts import render, redirect from django.contrib import messages from decimal import Decimal from core.services.billing_service import BillingService client = Client.objects.get(pk=client_id) if request.method == 'POST': try: amount = Decimal(request.POST.get('amount', 0)) method = request.POST.get('method', 'CASH') description = request.POST.get('description', '') if amount <= 0: raise ValueError(\"Сумма должна быть положительной\") trx = BillingService.topup_balance( entity=client, amount=amount, method=method, description=description or f\"Пополнение баланса клиента {client.name}\", created_by=reque", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ма должна быть положительной\") trx = BillingService.topup_balance( entity=client, amount=amount, method=method, description=description or f\"Пополнение баланса клиента {client.name}\", created_by=request.user ) messages.success( request, f'✅ Баланс пополнен! Транзакция: {trx.number}, сумма: {amount}€' ) return redirect('admin:core_client_change', client_id) except Exception as e: messages.error(request, f'❌ Ошибка: {e}') context = { 'client': client, 'opts': self.model._meta, 'title': f'Пополнение баланса - {client.name}', } return render(request, 'admin/client_topup.html', context) def reset_balance_view(self, request, client_id): \"\"\"Обнулить баланс клиента\"\"\" from django.shortcuts import redirect from django.contrib import messages from decimal import Decimal client = Client.objects.get(pk=client_id) old_balance = client.balance client.balance = Decimal('0.00') client.save(update_fields=['balance']) messages.success(request, f'✅ Баланс клиента {client.name} обнулён (был: {old_balance}€)') return redirect('admin:core_client_change', client_id) def recalc_balance_view(self, request, client_id): \"\"\"Пересчитать баланс клиента на основе транзакций\"\"\" from django.shortcuts import redire", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "€)') return redirect('admin:core_client_change', client_id) def recalc_balance_view(self, request, client_id): \"\"\"Пересчитать баланс клиента на основе транзакций\"\"\" from django.shortcuts import redirect from django.contrib import messages from django.db.models import Sum from decimal import Decimal from core.models_billing import Transaction client = Client.objects.get(pk=client_id) old_balance = client.balance # Пополнения (TOPUP) topups = Transaction.objects.filter( to_client=client, type='TOPUP', status='COMPLETED' ).aggregate(Sum('amount'))['amount__sum'] or Decimal('0.00') # Платежи (PAYMENT) payments = Transaction.objects.filter( from_client=client, type='PAYMENT', status='COMPLETED' ).aggregate(Sum('amount'))['amount__sum'] or Decimal('0.00') # Новый баланс new_balance = topups - payments client.balance = new_balance client.save(update_fields=['balance']) messages.success( request, f'✅ Баланс пересчитан: {old_balance}€ → {new_balance}€ (пополнения: {topups}€, платежи: {payments}€)' ) return redirect('admin:core_client_change', client_id) def cars_in_warehouse_view(self, request, client_id): \"\"\"Показывает список всех разгруженных авто клиента на складе\"\"\" from django.shortcut", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "€)' ) return redirect('admin:core_client_change', client_id) def cars_in_warehouse_view(self, request, client_id): \"\"\"Показывает список всех разгруженных авто клиента на складе\"\"\" from django.shortcuts import render from django.http import JsonResponse client = Client.objects.get(pk=client_id) # Получаем все авто клиента со статусом UNLOADED (на складе) cars = Car.objects.filter( client=client, status='UNLOADED' ).select_related('warehouse', 'container').order_by('warehouse__name', '-unload_date') # Группируем по складам warehouses_data = {} for car in cars: wh_name = car.warehouse.name if car.warehouse else 'Без склада' if wh_name not in warehouses_data: warehouses_data[wh_name] = [] warehouses_data[wh_name].append(car) # Формируем текст для копирования text_for_copy = f\"Авто на складе - {client.name}\\n\" text_for_copy += f\"Дата: {timezone.now().strftime('%d.%m.%Y')}\\n\" text_for_copy += \"=\" * 40 + \"\\n\\n\" for wh_name, wh_cars in warehouses_data.items(): text_for_copy += f\"📍 {wh_name} ({len(wh_cars)} авто)\\n\" text_for_copy += \"-\" * 30 + \"\\n\" for car in wh_cars: text_for_copy += f\"• {car.vin} - {car.brand} {car.year}\" if car.unload_date: text_for_copy += f\" (разгр. {car.unload_date.st", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "len(wh_cars)} авто)\\n\" text_for_copy += \"-\" * 30 + \"\\n\" for car in wh_cars: text_for_copy += f\"• {car.vin} - {car.brand} {car.year}\" if car.unload_date: text_for_copy += f\" (разгр. {car.unload_date.strftime('%d.%m.%Y')})\" text_for_copy += \"\\n\" text_for_copy += \"\\n\" text_for_copy += f\"Итого: {cars.count()} авто\" context = { 'client': client, 'cars': cars, 'warehouses_data': warehouses_data, 'text_for_copy': text_for_copy, 'total_count': cars.count(), 'opts': self.model._meta, 'title': f'Авто на складе - {client.name}', } return render(request, 'admin/client_cars_in_warehouse.html', context) @admin.register(Company) class CompanyAdmin(admin.ModelAdmin): change_form_template = 'admin/company_change.html' list_display = ('name', 'balance_display', 'is_main_company', 'created_at', 'updated_at') search_fields = ('name',) readonly_fields = ('created_at', 'updated_at', 'balance') actions = ['reset_company_balance'] inlines = [CompanyServiceInline] fieldsets = ( ('Основная информация', { 'fields': ('name',) }), ('Баланс', { 'fields': ('balance',), 'description': 'Баланс компании' }), ('Системная информация', { 'classes': ('collapse',), 'fields': ('created_at', 'updated_at') }), ) def balanc", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "s': ('name',) }), ('Баланс', { 'fields': ('balance',), 'description': 'Баланс компании' }), ('Системная информация', { 'classes': ('collapse',), 'fields': ('created_at', 'updated_at') }), ) def balance_display(self, obj): \"\"\"Показывает баланс компании\"\"\" try: balance = obj.balance or 0 color = '#28a745' if balance >= 0 else '#dc3545' sign = '+' if balance >= 0 else '' return format_html( '<span style=\"color:{}; font-weight:bold;\">{} {:.2f}</span>', color, sign, balance ) except: return '-' balance_display.short_description = 'Баланс' def is_main_company(self, obj): \"\"\"Показывает, является ли компания главной\"\"\" return obj.name == \"Caromoto Lithuania\" is_main_company.boolean = True is_main_company.short_description = \"Главная компания\" def invoices_display(self, obj): \"\"\"Показывает связанные инвойсы\"\"\" try: # Инвойсы, выставляемые компанией outgoing_invoices = Invoice.objects.filter( from_entity_type='COMPANY', from_entity_id=obj.id ).order_by('-issue_date')[:10] # Инвойсы, получаемые компанией incoming_invoices = Invoice.objects.filter( to_entity_type='COMPANY', to_entity_id=obj.id ).order_by('-issue_date')[:10] html = ['<div style=\"margin-top:15px;\">'] # Исходящие инвойсы html.app", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "омпанией incoming_invoices = Invoice.objects.filter( to_entity_type='COMPANY', to_entity_id=obj.id ).order_by('-issue_date')[:10] html = ['<div style=\"margin-top:15px;\">'] # Исходящие инвойсы html.append('<h4 style=\"margin-bottom:10px; color:#495057;\">Инвойсы, выставляемые компанией</h4>') if outgoing_invoices.exists(): html.append('<table style=\"width:100%; border-collapse:collapse; font-size:12px;\">') html.append('<tr style=\"background-color:#f8f9fa;\">') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Номер</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Кому</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Сумма</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Статус</th>') html.append('</tr>') for invoice in outgoing_invoices: status_color = '#28a745' if invoice.paid else '#dc3545' status_text = 'Оплачен' if invoice.paid else 'Не оплачен' html.append('<tr>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\"><a href=\"/admin/core/invoice/{invoice.id}/change/\">{invoice.number}</a></td>') html.append(f'<td style=\"borde", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ачен' html.append('<tr>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\"><a href=\"/admin/core/invoice/{invoice.id}/change/\">{invoice.number}</a></td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{invoice.to_entity_name}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{invoice.total_amount:.2f}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px; color:{status_color};\">{status_text}</td>') html.append('</tr>') html.append('</table>') else: html.append('<p style=\"color:#6c757d;\">Нет исходящих инвойсов</p>') # Входящие инвойсы html.append('<h4 style=\"margin-top:20px; margin-bottom:10px; color:#495057;\">Инвойсы, получаемые компанией</h4>') if incoming_invoices.exists(): html.append('<table style=\"width:100%; border-collapse:collapse; font-size:12px;\">') html.append('<tr style=\"background-color:#f8f9fa;\">') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Номер</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">От кого</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Сумма</th>') html.append('<th sty", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "d('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">От кого</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Сумма</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Статус</th>') html.append('</tr>') for invoice in incoming_invoices: status_color = '#28a745' if invoice.paid else '#dc3545' status_text = 'Оплачен' if invoice.paid else 'Не оплачен' html.append('<tr>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\"><a href=\"/admin/core/invoice/{invoice.id}/change/\">{invoice.number}</a></td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{invoice.from_entity_name}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{invoice.total_amount:.2f}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px; color:{status_color};\">{status_text}</td>') html.append('</tr>') html.append('</table>') else: html.append('<p style=\"color:#6c757d;\">Нет входящих инвойсов</p>') html.append('</div>') return format_html(''.join(html)) except Exception as e: return format_html(f'<p style=\"color:#dc3545;\">Ошибка загрузки инвойсов: {e}</p>') invoic", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "d;\">Нет входящих инвойсов</p>') html.append('</div>') return format_html(''.join(html)) except Exception as e: return format_html(f'<p style=\"color:#dc3545;\">Ошибка загрузки инвойсов: {e}</p>') invoices_display.short_description = 'Связанные инвойсы' def payments_display(self, obj): \"\"\"Показывает связанные платежи\"\"\" try: # Платежи, где компания является отправителем или получателем payments = Payment.objects.filter( models.Q(from_company=obj) | models.Q(to_company=obj) ).order_by('-date')[:20] if not payments.exists(): return format_html('<p style=\"color:#6c757d;\">Нет связанных платежей</p>') html = ['<div style=\"margin-top:15px;\">'] html.append('<h4 style=\"margin-bottom:10px; color:#495057;\">Последние платежи</h4>') html.append('<table style=\"width:100%; border-collapse:collapse; font-size:12px;\">') html.append('<tr style=\"background-color:#f8f9fa;\">') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Дата</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Тип</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Сумма</th>') html.append('<th style=\"border:1px solid #dee2e6; padd", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": " #dee2e6; padding:8px; text-align:left;\">Тип</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Сумма</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">От кого</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Кому</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Описание</th>') html.append('</tr>') for payment in payments: # Определяем, является ли компания отправителем или получателем if payment.from_company == obj: # Компания отправляет деньги amount_color = '#dc3545' # Красный для исходящих amount_sign = '-' amount_display = f\"{amount_sign}{payment.amount:.2f}\" else: # Компания получает деньги amount_color = '#28a745' # Зеленый для входящих amount_sign = '+' amount_display = f\"{amount_sign}{payment.amount:.2f}\" html.append('<tr>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{payment.date}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{payment.get_payment_type_display()}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px; color:{amount_color}; font-weight:bold;\">{a", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "d style=\"border:1px solid #dee2e6; padding:8px;\">{payment.get_payment_type_display()}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px; color:{amount_color}; font-weight:bold;\">{amount_display}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{payment.sender or \"-\"}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{payment.recipient or \"-\"}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{payment.description or \"-\"}</td>') html.append('</tr>') html.append('</table>') html.append('</div>') return format_html(''.join(html)) except Exception as e: return format_html(f'<p style=\"color:#dc3545;\">Ошибка загрузки платежей: {e}</p>') payments_display.short_description = 'Платежи' def balance_summary_display(self, obj): \"\"\"Показывает сводку по балансу компании\"\"\" try: cash_balance = obj.cash_balance or 0 card_balance = obj.card_balance or 0 invoice_balance = obj.invoice_balance or 0 total_balance = cash_balance + card_balance + invoice_balance html = f\"\"\" <div style=\"background:#f8f9fa; padding:15px; border-radius:8px; border:1px solid #dee2e6;\"> <h3 style=\"margin-top:0; color:#495057;\">Сводка по бала", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "alance + card_balance + invoice_balance html = f\"\"\" <div style=\"background:#f8f9fa; padding:15px; border-radius:8px; border:1px solid #dee2e6;\"> <h3 style=\"margin-top:0; color:#495057;\">Сводка по балансу компании</h3> <div style=\"display:grid; grid-template-columns:1fr 1fr 1fr; gap:15px; margin-bottom:20px;\"> <div style=\"background:white; padding:10px; border-radius:5px; border:1px solid #dee2e6;\"> <strong>Наличный баланс:</strong><br> <span style=\"font-size:18px; color:{'#28a745' if cash_balance >= 0 else '#dc3545'};\">{cash_balance:.2f}</span> </div> <div style=\"background:white; padding:10px; border-radius:5px; border:1px solid #dee2e6;\"> <strong>Безналичный баланс:</strong><br> <span style=\"font-size:18px; color:{'#28a745' if card_balance >= 0 else '#dc3545'};\">{card_balance:.2f}</span> </div> <div style=\"background:white; padding:10px; border-radius:5px; border:1px solid #dee2e6;\"> <strong>Инвойс-баланс:</strong><br> <span style=\"font-size:18px; color:{'#28a745' if invoice_balance >= 0 else '#dc3545'};\">{invoice_balance:.2f}</span> </div> </div> <div style=\"background:white; padding:15px; border-radius:5px; border:2px solid {'#28a745' if total_balance >= 0 else '#dc3545'};\"> <s", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": ">= 0 else '#dc3545'};\">{invoice_balance:.2f}</span> </div> </div> <div style=\"background:white; padding:15px; border-radius:5px; border:2px solid {'#28a745' if total_balance >= 0 else '#dc3545'};\"> <strong style=\"color:{'#28a745' if total_balance >= 0 else '#dc3545'};\">Общий баланс:</strong><br> <span style=\"font-size:24px; font-weight:bold; color:{'#28a745' if total_balance >= 0 else '#dc3545'};\">{total_balance:.2f}</span> </div> <!-- Кнопка для перехода к дашборду (только для Caromoto Lithuania) --> {f''' <div style=\"margin-top:20px; text-align:center;\"> <a href=\"/company-dashboard/\" style=\"display:inline-block; padding:12px 24px; background:#667eea; color:white; text-decoration:none; border-radius:8px; font-weight:600; font-size:16px;\"> 🏢 Открыть дашборд компании </a> </div> ''' if obj.name == \"Caromoto Lithuania\" else \"\"} </div> \"\"\" return format_html(html) except Exception as e: return format_html(f'<p style=\"color:#dc3545;\">Ошибка загрузки баланса: {e}</p>') balance_summary_display.short_description = 'Сводка по балансу' def balance_transactions_display(self, obj): \"\"\"Показывает платежи компании\"\"\" try: # Получаем все платежи для компании payments = Payment.objects.filter( mo", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ay.short_description = 'Сводка по балансу' def balance_transactions_display(self, obj): \"\"\"Показывает платежи компании\"\"\" try: # Получаем все платежи для компании payments = Payment.objects.filter( models.Q(from_company=obj) | models.Q(to_company=obj) ).order_by('-date', '-id')[:20] # Последние 20 платежей if not payments.exists(): return format_html('<p style=\"color:#6c757d;\">Нет платежей</p>') html = ['<div style=\"margin-top:15px;\">'] html.append('<h4 style=\"margin-bottom:10px; color:#495057;\">Последние платежи</h4>') html.append('<table style=\"width:100%; border-collapse:collapse; font-size:12px;\">') html.append('<tr style=\"background-color:#f8f9fa;\">') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Дата</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Тип</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Сумма</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Отправитель</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Получатель</th>') html.append('<th style=\"border:1px solid #dee2e6; padding", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "g:8px; text-align:left;\">Отправитель</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Получатель</th>') html.append('<th style=\"border:1px solid #dee2e6; padding:8px; text-align:left;\">Описание</th>') html.append('</tr>') for payment in payments: amount_color = '#28a745' if payment.to_company == obj else '#dc3545' html.append('<tr>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{payment.date.strftime(\"%d.%m.%Y\")}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{payment.get_payment_type_display()}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px; color:{amount_color}; font-weight:bold;\">{payment.amount:.2f}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{payment.sender or \"-\"}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{payment.recipient or \"-\"}</td>') html.append(f'<td style=\"border:1px solid #dee2e6; padding:8px;\">{payment.description or \"-\"}</td>') html.append('</tr>') html.append('</table>') html.append('</div>') return format_html(''.join(html)) except Exception as e: return format_html(f'<p style=\"color:#dc3545;\">Ошибка з", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ption or \"-\"}</td>') html.append('</tr>') html.append('</table>') html.append('</div>') return format_html(''.join(html)) except Exception as e: return format_html(f'<p style=\"color:#dc3545;\">Ошибка загрузки платежей: {e}</p>') balance_transactions_display.short_description = 'Платежи' def reset_company_balance(self, request, queryset): \"\"\"Обнуляет балансы выбранных компаний\"\"\" from django.contrib import messages try: for company in queryset: company.balance = 0 company.save() messages.success(request, f'Балансы {queryset.count()} компаний успешно обнулены') except Exception as e: messages.error(request, f'Ошибка при обнулении балансов: {e}') reset_company_balance.short_description = 'Обнулить балансы выбранных компаний' # Регистрация моделей в админке Django admin.site.register(Container, ContainerAdmin) # LineServiceInline удален - используется кастомный раздел \"Управление услугами\" @admin.register(Line) class LineAdmin(admin.ModelAdmin): change_form_template = 'admin/line_change.html' form = LineForm list_display = ('name', 'balance_display') search_fields = ('name',) readonly_fields = ('balance',) actions = ['reset_line_balance'] exclude = ('ocean_freight_rate', 'documentation_", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "l' form = LineForm list_display = ('name', 'balance_display') search_fields = ('name',) readonly_fields = ('balance',) actions = ['reset_line_balance'] exclude = ('ocean_freight_rate', 'documentation_fee', 'handling_fee', 'ths_fee', 'additional_fees') inlines = [LineTHSCoefficientInline, LineServiceInline] fieldsets = ( ('Основные данные', { 'fields': ('name',) }), ('Баланс', { 'fields': ('balance',), 'description': 'Баланс линии' }), ) def balance_display(self, obj): \"\"\"Показывает баланс линии\"\"\" try: balance = obj.balance or 0 color = '#28a745' if balance >= 0 else '#dc3545' sign = '+' if balance >= 0 else '' return format_html( '<span style=\"color:{}; font-weight:bold;\">{} {:.2f}</span>', color, sign, balance ) except Exception as e: return '-' balance_display.short_description = 'Баланс' def reset_line_balance(self, request, queryset): \"\"\"Обнуляет балансы выбранных линий\"\"\" from django.contrib import messages try: for line in queryset: line.balance = 0 line.save() messages.success(request, f'Балансы {queryset.count()} линий успешно обнулены') except Exception as e: messages.error(request, f'Ошибка при обнулении балансов: {e}') reset_line_balance.short_description = 'Обнулить ба", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "request, f'Балансы {queryset.count()} линий успешно обнулены') except Exception as e: messages.error(request, f'Ошибка при обнулении балансов: {e}') reset_line_balance.short_description = 'Обнулить балансы выбранных линий' def get_urls(self): from django.urls import path urls = super().get_urls() custom_urls = [ path('<int:object_id>/recalculate_ths/', self.admin_site.admin_view(self.recalculate_ths_view), name='core_line_recalculate_ths'), ] return custom_urls + urls def recalculate_ths_view(self, request, object_id): \"\"\"Пересчитывает THS для всех машин линии со статусом UNLOADED и IN_PORT\"\"\" from django.contrib import messages from django.shortcuts import redirect from django.db import transaction from core.models import Container, Car, Line from core.signals import create_ths_services_for_container import logging logger = logging.getLogger(__name__) print(f\"=== RECALCULATE THS VIEW CALLED === object_id={object_id}\") logger.warning(f\"=== RECALCULATE THS VIEW CALLED === object_id={object_id}\") # Получаем линию напрямую по ID try: line = Line.objects.get(pk=object_id) except Line.DoesNotExist: messages.error(request, 'Линия не найдена') return redirect('admin:core_line_changelist')", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ect_id}\") # Получаем линию напрямую по ID try: line = Line.objects.get(pk=object_id) except Line.DoesNotExist: messages.error(request, 'Линия не найдена') return redirect('admin:core_line_changelist') print(f\"Line: {line}\") logger.info(f\"[RECALC THS] Starting for line {line.name}\") # Находим все контейнеры этой линии с машинами в нужных статусах containers = Container.objects.filter( line=line, container_cars__status__in=['UNLOADED', 'IN_PORT'] ).distinct() updated_containers = 0 updated_cars = 0 try: with transaction.atomic(): for container in containers: if container.ths: logger.info(f\"[RECALC THS] Container {container.number}, THS={container.ths}\") # Пересчитываем THS услуги created = create_ths_services_for_container(container) logger.info(f\"[RECALC THS] Created {created} THS services\") updated_containers += 1 # Пересчитываем цены машин for car in container.container_cars.filter(status__in=['UNLOADED', 'IN_PORT']): old_price = car.total_price # Очищаем кэш и получаем свежие данные car.refresh_from_db() if hasattr(car, '_prefetched_objects_cache'): car._prefetched_objects_cache.clear() car.calculate_total_price() car.save(update_fields=['total_price', 'storage_cost', 'days']) lo", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "car.refresh_from_db() if hasattr(car, '_prefetched_objects_cache'): car._prefetched_objects_cache.clear() car.calculate_total_price() car.save(update_fields=['total_price', 'storage_cost', 'days']) logger.info(f\"[RECALC THS] Car {car.vin}: {old_price} -> {car.total_price}\") updated_cars += 1 messages.success( request, f'Пересчитано: {updated_containers} контейнеров, {updated_cars} машин' ) except Exception as e: logger.error(f\"[RECALC THS] Error: {e}\", exc_info=True) messages.error(request, f'Ошибка при пересчёте: {e}') from django.urls import reverse return redirect(reverse('admin:core_line_change', args=[object_id])) def change_view(self, request, object_id, form_url='', extra_context=None): \"\"\"Переопределяем change_view для обработки услуг\"\"\" extra_context = extra_context or {} if object_id: obj = self.get_object(request, object_id) if request.method == 'POST': # Обрабатываем существующие услуги for key, value in request.POST.items(): if key.startswith('service_name_'): service_id = key.replace('service_name_', '') try: service = LineService.objects.get(id=service_id, line=obj) service.name = value service.save() except LineService.DoesNotExist: pass elif key.startswith('service", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": " key.replace('service_name_', '') try: service = LineService.objects.get(id=service_id, line=obj) service.name = value service.save() except LineService.DoesNotExist: pass elif key.startswith('service_price_'): service_id = key.replace('service_price_', '') try: service = LineService.objects.get(id=service_id, line=obj) service.default_price = float(value) if value else 0 service.save() except (LineService.DoesNotExist, ValueError): pass elif key.startswith('delete_service_'): service_id = key.replace('delete_service_', '') try: service = LineService.objects.get(id=service_id, line=obj) service.delete() except LineService.DoesNotExist: pass # Обрабатываем новые услуги for key, value in request.POST.items(): if key.startswith('new_service_name_'): index = key.replace('new_service_name_', '') name = value price = request.POST.get(f'new_service_price_{index}', 0) if name: try: LineService.objects.create( line=obj, name=name, default_price=float(price) if price else 0 ) except ValueError: pass return super().change_view(request, object_id, form_url, extra_context) # CarServiceAdmin удален def get_form(self, request, obj=None, **kwargs): \"\"\"Переопределяем форму для добавления динамическ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "pass return super().change_view(request, object_id, form_url, extra_context) # CarServiceAdmin удален def get_form(self, request, obj=None, **kwargs): \"\"\"Переопределяем форму для добавления динамических полей\"\"\" form = super().get_form(request, obj, **kwargs) if obj and obj.pk: # Добавляем динамические поля в fieldsets dynamic_fields = [] for service in obj.services.all(): field_name = f'service_{service.id}' dynamic_fields.append(field_name) if dynamic_fields: # Обновляем fieldsets для добавления динамических полей self.fieldsets = list(self.fieldsets) for i, (title, options) in enumerate(self.fieldsets): if title == 'Услуги и цены': fields = list(options['fields']) fields.append(tuple(dynamic_fields)) self.fieldsets[i] = (title, {**options, 'fields': tuple(fields)}) break return form # CarrierServiceInline удален - используется кастомный раздел \"Управление услугами\" @admin.register(Carrier) class CarrierAdmin(admin.ModelAdmin): change_form_template = 'admin/carrier_change.html' form = CarrierForm list_display = ('name', 'contact_person', 'phone', 'balance_display') search_fields = ('name', 'contact_person', 'phone', 'email') list_filter = ('created_at',) readonly_fields = ('creat", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "= CarrierForm list_display = ('name', 'contact_person', 'phone', 'balance_display') search_fields = ('name', 'contact_person', 'phone', 'email') list_filter = ('created_at',) readonly_fields = ('created_at', 'updated_at', 'balance') exclude = ('transport_rate', 'loading_fee', 'unloading_fee', 'fuel_surcharge', 'additional_fees') inlines = [CarrierServiceInline] fieldsets = ( ('Основная информация', { 'fields': ('name', 'short_name', 'contact_person', 'phone', 'email') }), ('Баланс', { 'fields': ('balance',) }), ('Системная информация', { 'fields': ('created_at', 'updated_at'), 'classes': ('collapse',) }), ) def balance_display(self, obj): \"\"\"Показывает баланс перевозчика\"\"\" try: balance = obj.balance or 0 color = '#28a745' if balance >= 0 else '#dc3545' sign = '+' if balance >= 0 else '' return format_html( '<span style=\"color:{}; font-weight:bold;\">{} {:.2f}</span>', color, sign, balance ) except: return '-' balance_display.short_description = 'Баланс' def change_view(self, request, object_id, form_url='', extra_context=None): \"\"\"Переопределяем change_view для обработки услуг\"\"\" extra_context = extra_context or {} if object_id: obj = self.get_object(request, object_id) if request.", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "bject_id, form_url='', extra_context=None): \"\"\"Переопределяем change_view для обработки услуг\"\"\" extra_context = extra_context or {} if object_id: obj = self.get_object(request, object_id) if request.method == 'POST': # Обрабатываем существующие услуги for key, value in request.POST.items(): if key.startswith('service_name_'): service_id = key.replace('service_name_', '') try: service = CarrierService.objects.get(id=service_id, carrier=obj) service.name = value service.save() except CarrierService.DoesNotExist: pass elif key.startswith('service_price_'): service_id = key.replace('service_price_', '') try: service = CarrierService.objects.get(id=service_id, carrier=obj) service.default_price = float(value) if value else 0 service.save() except (CarrierService.DoesNotExist, ValueError): pass elif key.startswith('delete_service_'): service_id = key.replace('delete_service_', '') try: service = CarrierService.objects.get(id=service_id, carrier=obj) service.delete() except CarrierService.DoesNotExist: pass # Обрабатываем новые услуги for key, value in request.POST.items(): if key.startswith('new_service_name_'): index = key.replace('new_service_name_', '') name = value price = request.P", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "esNotExist: pass # Обрабатываем новые услуги for key, value in request.POST.items(): if key.startswith('new_service_name_'): index = key.replace('new_service_name_', '') name = value price = request.POST.get(f'new_service_price_{index}', 0) if name: try: CarrierService.objects.create( carrier=obj, name=name, default_price=float(price) if price else 0 ) except ValueError: pass return super().change_view(request, object_id, form_url, extra_context) # Company уже зарегистрирован через @admin.register выше # ============================================================================== # 🎉 НОВАЯ СИСТЕМА ИНВОЙСОВ И ПЛАТЕЖЕЙ # ============================================================================== # Импортируем админку для новой системы # Модели автоматически регистрируются через @admin.register() в admin_billing.py try: from .admin_billing import NewInvoiceAdmin, TransactionAdmin # Регистрация происходит автоматически при импорте except ImportError as e: import logging logger = logging.getLogger('django') logger.warning(f\"⚠ Не удалось загрузить админку новой системы: {e}\") logger.warning(\"Убедитесь, что файлы admin_billing.py и models_billing.py существуют\") # Остальные модели уж", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\admin.py", "content": "ng.getLogger('django') logger.warning(f\"⚠ Не удалось загрузить админку новой системы: {e}\") logger.warning(\"Убедитесь, что файлы admin_billing.py и models_billing.py существуют\") # Остальные модели уже зарегистрированы через декораторы @admin.register", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "from django.db.models.signals import post_save, post_delete, pre_delete, pre_save from django.dispatch import receiver from .models import Car, Container, WarehouseService, LineService, CarrierService, Company, CompanyService, CarService, DeletedCarService, LineTHSCoefficient from .models_billing import NewInvoice from django.db.models import Sum from channels.layers import get_channel_layer from asgiref.sync import async_to_sync from django.db import transaction, OperationalError from django.utils import timezone from decimal import Decimal import logging logger = logging.getLogger('django') # Сохраняем старые значения контейнера для определения что изменилось _old_container_values = {} @receiver(pre_save, sender=Container) def save_old_container_values(sender, instance, **kwargs): \"\"\"Сохраняем старые значения контейнера до сохранения\"\"\" print(f\"[PRE_SAVE] Container {instance.number} pk={instance.pk}\", flush=True) if instance.pk: try: old = Container.objects.filter(pk=instance.pk).values('status', 'unload_date').first() if old: _old_container_values[instance.pk] = old print(f\"[PRE_SAVE] Saved old values: {old}\", flush=True) # Фиксируем момент получения статуса UNLOADED old_status ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "ues('status', 'unload_date').first() if old: _old_container_values[instance.pk] = old print(f\"[PRE_SAVE] Saved old values: {old}\", flush=True) # Фиксируем момент получения статуса UNLOADED old_status = old.get('status') if ( instance.status == 'UNLOADED' and old_status != 'UNLOADED' and not instance.unloaded_status_at ): instance.unloaded_status_at = timezone.now() except Exception as e: print(f\"[PRE_SAVE] Error: {e}\", flush=True) else: # Новый контейнер: если сразу UNLOADED — сохраняем момент статуса if instance.status == 'UNLOADED' and not instance.unloaded_status_at: instance.unloaded_status_at = timezone.now() @receiver(post_save, sender=Container) def update_related_on_container_save(sender, instance, created, **kwargs): \"\"\" Обновляет автомобили при изменении контейнера. Основная логика в ContainerAdmin.save_model(), но этот сигнал работает как резервный механизм для случаев когда: - form.changed_data не распознал изменение - Сохранение произошло не через админку (API, shell, management command) \"\"\" old_values = _old_container_values.pop(instance.pk, None) if not instance.pk: return # Проверяем изменилась ли дата разгрузки if old_values: old_unload_date = old_values.get('unloa", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "gement command) \"\"\" old_values = _old_container_values.pop(instance.pk, None) if not instance.pk: return # Проверяем изменилась ли дата разгрузки if old_values: old_unload_date = old_values.get('unload_date') new_unload_date = instance.unload_date # Если дата разгрузки изменилась - обновляем все авто if old_unload_date != new_unload_date and new_unload_date is not None: logger.info(f\"🔄 [SIGNAL] unload_date changed for container {instance.number}: {old_unload_date} -> {new_unload_date}\") try: # Проверяем, не обновлены ли уже авто (через admin.save_model) # Берём первый авто и проверяем его дату first_car = instance.container_cars.first() if first_car and first_car.unload_date == new_unload_date: logger.debug(f\"[SIGNAL] Cars already updated by admin.save_model, skipping\") return # Обновляем дату у всех авто одним запросом (быстро и надёжно) updated_count = instance.container_cars.update(unload_date=new_unload_date) logger.info(f\"✅ [SIGNAL] Updated unload_date to {new_unload_date} for {updated_count} cars in container {instance.number}\") # Пересчитываем дни и цены для каждого авто if updated_count > 0: cars_to_update = [] for car in instance.container_cars.select_related('warehouse').", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "dated_count} cars in container {instance.number}\") # Пересчитываем дни и цены для каждого авто if updated_count > 0: cars_to_update = [] for car in instance.container_cars.select_related('warehouse').all(): car.update_days_and_storage() car.calculate_total_price() cars_to_update.append(car) if cars_to_update: Car.objects.bulk_update( cars_to_update, ['days', 'storage_cost', 'total_price'], batch_size=50 ) logger.info(f\"✅ [SIGNAL] Recalculated prices for {len(cars_to_update)} cars\") except Exception as e: logger.error(f\"❌ [SIGNAL] Failed to update cars for container {instance.number}: {e}\", exc_info=True) @receiver(post_save, sender=Car) def update_related_on_car_save(sender, instance, **kwargs): # Обновляем total_amount инвойсов МАССОВО через bulk_update logger.debug(f\"🔔 Signal post_save triggered for Car {instance.id} ({instance.vin})\") # Проверяем, что у экземпляра есть первичный ключ if not instance.pk: logger.debug(\"Skipping - no PK\") return # Обновляем новые инвойсы (NewInvoice) # Добавляем защиту от рекурсии logger.debug(f\"Checking NewInvoice update for car {instance.id}, _updating_invoices={getattr(instance, '_updating_invoices', False)}\") if not getattr(instance, '_updating", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": " Добавляем защиту от рекурсии logger.debug(f\"Checking NewInvoice update for car {instance.id}, _updating_invoices={getattr(instance, '_updating_invoices', False)}\") if not getattr(instance, '_updating_invoices', False): try: instance._updating_invoices = True # Получаем все новые инвойсы, связанные с этим автомобилем # Используем select_for_update(nowait=True) чтобы не ждать блокировку new_invoices = list(NewInvoice.objects.filter(cars=instance).values_list('id', flat=True)) logger.debug(f\"Found {len(new_invoices)} NewInvoice(s) for car {instance.vin}\") if new_invoices: for invoice_id in new_invoices: try: # Каждый инвойс обрабатываем в отдельной транзакции with transaction.atomic(): invoice = NewInvoice.objects.select_for_update(nowait=True).get(id=invoice_id) logger.info(f\"Regenerating invoice {invoice.number} for car {instance.vin}...\") invoice.regenerate_items_from_cars() logger.info(f\"✅ Auto-regenerated invoice {invoice.number} for car {instance.vin}\") except OperationalError: # Инвойс заблокирован другой транзакцией - пропускаем logger.warning(f\"⏭️ Skipping invoice {invoice_id} - locked by another transaction\") except NewInvoice.DoesNotExist: logger.warning(f\"⏭️ Invoice {invo", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "нвойс заблокирован другой транзакцией - пропускаем logger.warning(f\"⏭️ Skipping invoice {invoice_id} - locked by another transaction\") except NewInvoice.DoesNotExist: logger.warning(f\"⏭️ Invoice {invoice_id} was deleted\") else: logger.debug(f\"No NewInvoice found for car {instance.vin}\") except Exception as e: logger.error(f\"❌ Failed to update new invoices for car {instance.id}: {e}\", exc_info=True) finally: instance._updating_invoices = False else: logger.debug(f\"Skipping NewInvoice update (recursion protection) for car {instance.id}\") # Сигналы для автоматического создания CarService при изменении контрагентов # Сохраняем старые значения контрагентов перед сохранением _old_contractors = {} @receiver(pre_save, sender=Car) def save_old_contractors(sender, instance, **kwargs): \"\"\"Сохраняет старые значения контрагентов перед сохранением\"\"\" if instance.pk: try: old_instance = Car.objects.get(pk=instance.pk) _old_contractors[instance.pk] = { 'warehouse_id': old_instance.warehouse_id, 'line_id': old_instance.line_id, 'carrier_id': old_instance.carrier_id } except Car.DoesNotExist: pass def find_line_service_by_container_count(line, container, vehicle_type): \"\"\" Находит подходящую услугу ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "id': old_instance.line_id, 'carrier_id': old_instance.carrier_id } except Car.DoesNotExist: pass def find_line_service_by_container_count(line, container, vehicle_type): \"\"\" Находит подходящую услугу линии на основе количества авто в контейнере и типа ТС. УСТАРЕВШИЙ МЕТОД - используется для обратной совместимости. Для новой логики с процентами используйте calculate_ths_for_container(). Логика выбора: - Для мотоциклов: ищем \"THS {ЛИНИЯ} MOTO\" или \"MOTO\" в названии - Для авто: ищем \"THS {ЛИНИЯ} {КОЛ-ВО} АВТО\" или \"{КОЛ-ВО} АВТО\" в названии ВАЖНО: Мотоциклы НЕ учитываются при подсчёте количества авто! \"\"\" if not line or not container: return None line_name_upper = line.name.upper() # Считаем количество ТОЛЬКО автомобилей в контейнере (мотоциклы не учитываются!) # Исключаем все мото-типы moto_types = ['MOTO', 'BIG_MOTO', 'ATV'] car_count = container.container_cars.exclude(vehicle_type__in=moto_types).count() # Получаем все активные услуги линии services = LineService.objects.filter(line=line, is_active=True) if vehicle_type in moto_types: # Для мотоциклов ищем услугу с MOTO в названии for service in services: service_name_upper = service.name.upper() if 'MOTO' in service_name_upper: # ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "ne, is_active=True) if vehicle_type in moto_types: # Для мотоциклов ищем услугу с MOTO в названии for service in services: service_name_upper = service.name.upper() if 'MOTO' in service_name_upper: # Проверяем что это услуга для этой линии if line_name_upper in service_name_upper or 'THS' in service_name_upper: return service # Если не нашли специфичную, ищем любую с MOTO for service in services: if 'MOTO' in service.name.upper(): return service else: # Для авто ищем услугу по количеству # Формат: \"THS MAERSK 3 АВТО\" или \"3 АВТО\" search_patterns = [ f'{car_count} АВТО', f'{car_count} AUTO', f'{car_count}АВТО', f'{car_count}AUTO', ] for service in services: service_name_upper = service.name.upper() for pattern in search_patterns: if pattern in service_name_upper: return service return None def calculate_ths_for_container(container): \"\"\" Рассчитывает THS для каждого ТС в контейнере пропорционально их коэффициентам. Алгоритм: 1. Получить общую сумму THS контейнера 2. Для каждого ТС получить коэффициент его типа из LineTHSCoefficient 3. Рассчитать долю каждого ТС = коэффициент / сумма_всех_коэффициентов 4. THS для ТС = общий_THS × доля Возвращает словарь: {car_id: ths_amount} Пример: -", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "ть коэффициент его типа из LineTHSCoefficient 3. Рассчитать долю каждого ТС = коэффициент / сумма_всех_коэффициентов 4. THS для ТС = общий_THS × доля Возвращает словарь: {car_id: ths_amount} Пример: - Контейнер THS = 500 EUR - 3 машины: легковой(1.0) + джип(2.0) + мото(0.5) = сумма коэффициентов 3.5 - Легковой: 500 × (1.0/3.5) = 143 EUR → округляем до 145 EUR - Джип: 500 × (2.0/3.5) = 286 EUR → округляем до 290 EUR - Мото: 500 × (0.5/3.5) = 71 EUR → округляем до 75 EUR \"\"\" from core.models import LineTHSCoefficient if not container or not container.line or not container.ths: return {} total_ths = Decimal(str(container.ths)) if total_ths <= 0: return {} # Получаем все ТС в контейнере cars = list(container.container_cars.all()) if not cars: return {} # Получаем коэффициенты для типов ТС этой линии ths_coefficients = { tc.vehicle_type: Decimal(str(tc.coefficient)) for tc in LineTHSCoefficient.objects.filter(line=container.line) } # Рассчитываем сумму коэффициентов для всех машин total_coefficient = Decimal('0.00') car_coefficients = {} for car in cars: # Получаем коэффициент для типа ТС, по умолчанию 1.0 (стандартный) coeff = ths_coefficients.get(car.vehicle_type, Decimal('1.00')) car", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "fficient = Decimal('0.00') car_coefficients = {} for car in cars: # Получаем коэффициент для типа ТС, по умолчанию 1.0 (стандартный) coeff = ths_coefficients.get(car.vehicle_type, Decimal('1.00')) car_coefficients[car.id] = coeff total_coefficient += coeff # Функция округления в большую сторону с шагом 5 EUR def round_up_to_5(value): \"\"\"Округляет в большую сторону с шагом 5 EUR. Пример: 73.12 -> 75\"\"\" import math return Decimal(str(math.ceil(float(value) / 5) * 5)) # Если сумма коэффициентов = 0, делим поровну if total_coefficient == 0: equal_share = total_ths / len(cars) return {car.id: round_up_to_5(equal_share) for car in cars} # Рассчитываем THS для каждого ТС пропорционально коэффициенту result = {} for car in cars: car_share = car_coefficients[car.id] / total_coefficient car_ths = total_ths * car_share # Округляем в большую сторону с шагом 5 EUR result[car.id] = round_up_to_5(car_ths) logger.info(f\"THS distribution for container {container.number}: total={total_ths}, coefficients={car_coefficients}, result={result}\") return result def create_ths_services_for_container(container): \"\"\" Создает услуги THS для всех ТС в контейнере на основе процентного распределения. Тип поставщи", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "={car_coefficients}, result={result}\") return result def create_ths_services_for_container(container): \"\"\" Создает услуги THS для всех ТС в контейнере на основе процентного распределения. Тип поставщика услуги (LINE или WAREHOUSE) определяется полем container.ths_payer. Возвращает количество созданных услуг. \"\"\" if not container or not container.line: return 0 # Рассчитываем THS для каждого ТС ths_distribution = calculate_ths_for_container(container) if not ths_distribution: return 0 # Определяем тип услуги (LINE или WAREHOUSE) service_type = container.ths_payer if hasattr(container, 'ths_payer') else 'LINE' # Получаем или создаем услугу THS для линии # Ищем услугу с названием \"THS\" или создаем абстрактную услугу line_service = None if service_type == 'LINE': line_service = LineService.objects.filter( line=container.line, is_active=True, name__icontains='THS' ).first() if not line_service: # Создаем услугу THS если её нет line_service, created = LineService.objects.get_or_create( line=container.line, name=f\"THS {container.line.name}\", defaults={ 'description': 'Услуга THS (рассчитывается пропорционально)', 'default_price': 0, 'is_active': True } ) warehouse_service = None if servic", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "container.line, name=f\"THS {container.line.name}\", defaults={ 'description': 'Услуга THS (рассчитывается пропорционально)', 'default_price': 0, 'is_active': True } ) warehouse_service = None if service_type == 'WAREHOUSE' and container.warehouse: warehouse_service = WarehouseService.objects.filter( warehouse=container.warehouse, is_active=True, name__icontains='THS' ).first() if not warehouse_service: # Создаем услугу THS если её нет warehouse_service, created = WarehouseService.objects.get_or_create( warehouse=container.warehouse, name=f\"THS {container.warehouse.name}\", defaults={ 'description': 'Услуга THS (рассчитывается пропорционально)', 'default_price': 0, 'is_active': True, 'add_by_default': False } ) created_count = 0 for car_id, ths_amount in ths_distribution.items(): try: car = Car.objects.get(id=car_id) # Удаляем старые услуги THS для этого авто # Удаляем от линии CarService.objects.filter( car=car, service_type='LINE' ).filter( service_id__in=LineService.objects.filter( name__icontains='THS' ).values_list('id', flat=True) ).delete() # Удаляем от склада CarService.objects.filter( car=car, service_type='WAREHOUSE' ).filter( service_id__in=WarehouseService.objects.filter( ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "e__icontains='THS' ).values_list('id', flat=True) ).delete() # Удаляем от склада CarService.objects.filter( car=car, service_type='WAREHOUSE' ).filter( service_id__in=WarehouseService.objects.filter( name__icontains='THS' ).values_list('id', flat=True) ).delete() # Создаем новую услугу THS if service_type == 'LINE' and line_service: CarService.objects.create( car=car, service_type='LINE', service_id=line_service.id, custom_price=ths_amount, quantity=1, notes=f\"THS рассчитан пропорционально. Тип ТС: {car.get_vehicle_type_display()}\" ) logger.info(f\"🚢 THS {ths_amount} EUR для {car.vin} (тип: {car.get_vehicle_type_display()}) от линии\") created_count += 1 elif service_type == 'WAREHOUSE' and warehouse_service: CarService.objects.create( car=car, service_type='WAREHOUSE', service_id=warehouse_service.id, custom_price=ths_amount, quantity=1, notes=f\"THS рассчитан пропорционально. Тип ТС: {car.get_vehicle_type_display()}\" ) logger.info(f\"🏭 THS {ths_amount} EUR для {car.vin} (тип: {car.get_vehicle_type_display()}) от склада\") created_count += 1 except Car.DoesNotExist: logger.warning(f\"Car {car_id} not found when creating THS service\") except Exception as e: logger.error(f\"Error creating ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "hicle_type_display()}) от склада\") created_count += 1 except Car.DoesNotExist: logger.warning(f\"Car {car_id} not found when creating THS service\") except Exception as e: logger.error(f\"Error creating THS service for car {car_id}: {e}\") return created_count def find_warehouse_services_for_car(warehouse): \"\"\" Находит услуги склада для автомобиля, которые должны добавляться по умолчанию. Возвращает только услуги с флагом add_by_default=True. \"\"\" if not warehouse: return [] # Возвращаем только услуги с флагом add_by_default=True return list(WarehouseService.objects.filter( warehouse=warehouse, is_active=True, add_by_default=True )) def find_line_services_for_car(line): \"\"\" Находит услуги линии для автомобиля, которые должны добавляться по умолчанию. THS-услуги исключаются (THS управляется отдельно). \"\"\" if not line: return [] return list(LineService.objects.filter( line=line, is_active=True, add_by_default=True ).exclude(name__icontains='THS')) def find_carrier_services_for_car(carrier): \"\"\" Находит услуги перевозчика для автомобиля, которые должны добавляться по умолчанию. \"\"\" if not carrier: return [] return list(CarrierService.objects.filter( carrier=carrier, is_active=True, add_by_", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "\"\" Находит услуги перевозчика для автомобиля, которые должны добавляться по умолчанию. \"\"\" if not carrier: return [] return list(CarrierService.objects.filter( carrier=carrier, is_active=True, add_by_default=True )) def get_main_company(): \"\"\"Возвращает главную компанию (Caromoto Lithuania), если есть.\"\"\" return Company.objects.filter(name=\"Caromoto Lithuania\").first() def find_company_services_for_car(company): \"\"\" Находит услуги компании для автомобиля, которые должны добавляться по умолчанию. \"\"\" if not company: return [] return list(CompanyService.objects.filter( company=company, is_active=True, add_by_default=True )) @receiver(post_save, sender=Car) def create_car_services_on_car_save(sender, instance, **kwargs): \"\"\" Создает записи CarService при сохранении автомобиля с контрагентами. Умный выбор услуг: - Услуги линий: выбираются по количеству авто в контейнере (THS MAERSK 3 АВТО) - Для мотоциклов: выбирается услуга с MOTO (THS CMA MOTO) - Услуги складов: добавляются \"Разгрузка/Погрузка/Декларация\" и \"Хранение\" \"\"\" if not instance.pk: return # Защита от рекурсии - пропускаем если уже создаем услуги для этого авто if getattr(instance, '_creating_services', False): return # Пров", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "грузка/Декларация\" и \"Хранение\" \"\"\" if not instance.pk: return # Защита от рекурсии - пропускаем если уже создаем услуги для этого авто if getattr(instance, '_creating_services', False): return # Проверяем, изменились ли контрагенты (только при создании или смене контрагентов) created = kwargs.get('created', False) if not created: # Если это не создание, проверяем, изменились ли контрагенты old_contractors = _old_contractors.get(instance.pk, {}) if old_contractors: warehouse_changed = old_contractors.get('warehouse_id') != instance.warehouse_id line_changed = old_contractors.get('line_id') != instance.line_id carrier_changed = old_contractors.get('carrier_id') != instance.carrier_id # Если контрагенты не изменились, не обновляем услуги if not (warehouse_changed or line_changed or carrier_changed): # Очищаем сохраненные значения _old_contractors.pop(instance.pk, None) return else: # Нет сохранённых значений - значит контрагенты не менялись return # Очищаем сохраненные значения _old_contractors.pop(instance.pk, None) # Устанавливаем флаг для защиты от рекурсии instance._creating_services = True try: # Получаем черные списки удаленных услуг deleted_warehouse_services = set( DeletedCar", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "ractors.pop(instance.pk, None) # Устанавливаем флаг для защиты от рекурсии instance._creating_services = True try: # Получаем черные списки удаленных услуг deleted_warehouse_services = set( DeletedCarService.objects.filter(car=instance, service_type='WAREHOUSE').values_list('service_id', flat=True) ) deleted_line_services = set( DeletedCarService.objects.filter(car=instance, service_type='LINE').values_list('service_id', flat=True) ) deleted_carrier_services = set( DeletedCarService.objects.filter(car=instance, service_type='CARRIER').values_list('service_id', flat=True) ) deleted_company_services = set( DeletedCarService.objects.filter(car=instance, service_type='COMPANY').values_list('service_id', flat=True) ) # ========== УСЛУГИ СКЛАДА ========== # Удаляем старые услуги склада если склад изменился instance.car_services.filter(service_type='WAREHOUSE').delete() if instance.warehouse: # Находим стандартные услуги склада (Разгрузка/Декларация и Хранение) warehouse_services = find_warehouse_services_for_car(instance.warehouse) for service in warehouse_services: if service.id not in deleted_warehouse_services: # Для услуги \"Хранение\" цена и наценка = платные_дни × ставка_за_день # Ес", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "ouse_services_for_car(instance.warehouse) for service in warehouse_services: if service.id not in deleted_warehouse_services: # Для услуги \"Хранение\" цена и наценка = платные_дни × ставка_за_день # Если платных дней нет - цена = 0 if service.name == 'Хранение': days = Decimal(str(instance.days or 0)) custom_price = days * Decimal(str(service.default_price or 0)) # Наценка тоже умножается на дни default_markup = days * Decimal(str(getattr(service, 'default_markup', 0) or 0)) else: custom_price = service.default_price # Получаем default_markup из услуги default_markup = getattr(service, 'default_markup', None) or Decimal('0') CarService.objects.get_or_create( car=instance, service_type='WAREHOUSE', service_id=service.id, defaults={'custom_price': custom_price, 'markup_amount': default_markup} ) logger.info(f\"🏭 Добавлена услуга склада '{service.name}' для {instance.vin} (цена: {custom_price}, наценка: {default_markup})\") # ========== УСЛУГИ ЛИНИИ ========== # THS создается отдельно через create_ths_services_for_container() # Здесь добавляем только услуги с add_by_default=True (кроме THS) instance.car_services.filter( service_type='LINE' ).exclude( service_id__in=LineService.objects.fi", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "create_ths_services_for_container() # Здесь добавляем только услуги с add_by_default=True (кроме THS) instance.car_services.filter( service_type='LINE' ).exclude( service_id__in=LineService.objects.filter(name__icontains='THS').values_list('id', flat=True) ).delete() if instance.line: line_services = find_line_services_for_car(instance.line) for service in line_services: if service.id not in deleted_line_services: default_markup = getattr(service, 'default_markup', None) or Decimal('0') CarService.objects.get_or_create( car=instance, service_type='LINE', service_id=service.id, defaults={'custom_price': service.default_price, 'markup_amount': default_markup} ) logger.info(f\"🚢 Добавлена услуга линии '{service.name}' для {instance.vin} (цена: {service.default_price}, наценка: {default_markup})\") # ========== УСЛУГИ ПЕРЕВОЗЧИКА ========== # Удаляем старые услуги перевозчика если перевозчик изменился instance.car_services.filter(service_type='CARRIER').delete() if instance.carrier: carrier_services = find_carrier_services_for_car(instance.carrier) for service in carrier_services: if service.id not in deleted_carrier_services: # Получаем default_markup из услуги default_markup = getattr(", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "services = find_carrier_services_for_car(instance.carrier) for service in carrier_services: if service.id not in deleted_carrier_services: # Получаем default_markup из услуги default_markup = getattr(service, 'default_markup', None) or Decimal('0') CarService.objects.get_or_create( car=instance, service_type='CARRIER', service_id=service.id, defaults={'custom_price': service.default_price, 'markup_amount': default_markup} ) # ========== УСЛУГИ КОМПАНИИ ========== # Добавляем только для новых авто и только для главной компании if created: main_company = get_main_company() if main_company: company_services = find_company_services_for_car(main_company) for service in company_services: if service.id in deleted_company_services: continue default_markup = getattr(service, 'default_markup', None) or Decimal('0') CarService.objects.get_or_create( car=instance, service_type='COMPANY', service_id=service.id, defaults={'custom_price': service.default_price, 'markup_amount': default_markup} ) except Exception as e: logger.error(f\"Error creating car services: {e}\") finally: # Сбрасываем флаг защиты от рекурсии instance._creating_services = False @receiver(post_save, sender=WarehouseService) def", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "pt Exception as e: logger.error(f\"Error creating car services: {e}\") finally: # Сбрасываем флаг защиты от рекурсии instance._creating_services = False @receiver(post_save, sender=WarehouseService) def update_cars_on_warehouse_service_change(sender, instance, **kwargs): \"\"\"Обновляет записи CarService при изменении услуг склада\"\"\" try: # Находим все автомобили с этим складом cars = Car.objects.filter(warehouse=instance.warehouse) for car in cars: car_service = CarService.objects.filter( car=car, service_type='WAREHOUSE', service_id=instance.id ).first() if instance.is_active and instance.default_price > 0: if not car_service: # Не добавляем услугу в существующие авто автоматически continue # Для услуги \"Хранение\" цена и наценка = платные_дни × ставка_за_день if instance.name == 'Хранение': days = Decimal(str(car.days or 0)) custom_price = days * Decimal(str(instance.default_price or 0)) default_markup = days * Decimal(str(getattr(instance, 'default_markup', 0) or 0)) else: custom_price = instance.default_price # Получаем default_markup из услуги default_markup = getattr(instance, 'default_markup', None) or Decimal('0') # Обновляем существующую запись CarService car_service.custom_pri", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": " instance.default_price # Получаем default_markup из услуги default_markup = getattr(instance, 'default_markup', None) or Decimal('0') # Обновляем существующую запись CarService car_service.custom_price = custom_price car_service.markup_amount = default_markup car_service.save(update_fields=['custom_price', 'markup_amount']) else: # Удаляем запись CarService если услуга неактивна или цена = 0 CarService.objects.filter( car=car, service_type='WAREHOUSE', service_id=instance.id ).delete() except Exception as e: logger.error(f\"Error updating cars on warehouse service change: {e}\") @receiver(post_save, sender=LineService) def update_cars_on_line_service_change(sender, instance, **kwargs): \"\"\" ОТКЛЮЧЕНО: Услуги линии (THS) теперь управляются централизованно через create_ths_services_for_container() при сохранении контейнера. Этот сигнал больше НЕ добавляет услуги линии автоматически к автомобилям. \"\"\" # Только удаляем услугу если она стала неактивной if not instance.is_active: try: deleted = CarService.objects.filter( service_type='LINE', service_id=instance.id ).delete() if deleted[0] > 0: logger.info(f\"Deleted {deleted[0]} LINE services for inactive LineService {instance.id}\") except ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "= CarService.objects.filter( service_type='LINE', service_id=instance.id ).delete() if deleted[0] > 0: logger.info(f\"Deleted {deleted[0]} LINE services for inactive LineService {instance.id}\") except Exception as e: logger.error(f\"Error deleting inactive line service: {e}\") @receiver(post_save, sender=CarrierService) def update_cars_on_carrier_service_change(sender, instance, **kwargs): \"\"\"Обновляет записи CarService при изменении услуг перевозчика\"\"\" try: # Находим все автомобили с этим перевозчиком cars = Car.objects.filter(carrier=instance.carrier) for car in cars: car_service = CarService.objects.filter( car=car, service_type='CARRIER', service_id=instance.id ).first() if instance.is_active and instance.default_price > 0: if not car_service: # Не добавляем услугу в существующие авто автоматически continue default_markup = getattr(instance, 'default_markup', None) or Decimal('0') car_service.custom_price = instance.default_price car_service.markup_amount = default_markup car_service.save(update_fields=['custom_price', 'markup_amount']) else: # Удаляем запись CarService если услуга неактивна или цена = 0 CarService.objects.filter( car=car, service_type='CARRIER', service_id=insta", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": ".save(update_fields=['custom_price', 'markup_amount']) else: # Удаляем запись CarService если услуга неактивна или цена = 0 CarService.objects.filter( car=car, service_type='CARRIER', service_id=instance.id ).delete() except Exception as e: logger.error(f\"Error updating cars on carrier service change: {e}\") @receiver(post_save, sender=CompanyService) def update_cars_on_company_service_change(sender, instance, **kwargs): \"\"\"Обновляет записи CarService при изменении услуг компании\"\"\" try: car_services = CarService.objects.filter( service_type='COMPANY', service_id=instance.id ) if instance.is_active and instance.default_price > 0: default_markup = getattr(instance, 'default_markup', None) or Decimal('0') car_services.update(custom_price=instance.default_price, markup_amount=default_markup) else: car_services.delete() except Exception as e: logger.error(f\"Error updating cars on company service change: {e}\") # ============================================================================ # СИГНАЛЫ ДЛЯ ПЕРЕСЧЕТА ИНВОЙСОВ ПРИ ИЗМЕНЕНИИ УСЛУГ АВТОМОБИЛЯ # ============================================================================ @receiver(post_save, sender=CarService) def recalculate_invo", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "ИГНАЛЫ ДЛЯ ПЕРЕСЧЕТА ИНВОЙСОВ ПРИ ИЗМЕНЕНИИ УСЛУГ АВТОМОБИЛЯ # ============================================================================ @receiver(post_save, sender=CarService) def recalculate_invoices_on_car_service_save(sender, instance, **kwargs): \"\"\"Пересчитывает инвойсы при изменении услуги автомобиля\"\"\" try: car = instance.car if not car: return # Находим все инвойсы с этим автомобилем (кроме оплаченных и отмененных) invoices = NewInvoice.objects.filter( cars=car, status__in=['DRAFT', 'ISSUED', 'PARTIALLY_PAID', 'OVERDUE'] ) for invoice in invoices: logger.info(f\"🔄 Пересчет инвойса {invoice.number} после изменения услуги авто {car.vin}\") invoice.regenerate_items_from_cars() except Exception as e: logger.error(f\"Error recalculating invoices on CarService save: {e}\") @receiver(post_delete, sender=CarService) def recalculate_invoices_on_car_service_delete(sender, instance, **kwargs): \"\"\"Пересчитывает инвойсы при удалении услуги автомобиля\"\"\" try: car = instance.car if not car: return # Находим все инвойсы с этим автомобилем (кроме оплаченных и отмененных) invoices = NewInvoice.objects.filter( cars=car, status__in=['DRAFT', 'ISSUED', 'PARTIALLY_PAID', 'OVERDUE'] ) for invoice ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "turn # Находим все инвойсы с этим автомобилем (кроме оплаченных и отмененных) invoices = NewInvoice.objects.filter( cars=car, status__in=['DRAFT', 'ISSUED', 'PARTIALLY_PAID', 'OVERDUE'] ) for invoice in invoices: logger.info(f\"🔄 Пересчет инвойса {invoice.number} после удаления услуги авто {car.vin}\") invoice.regenerate_items_from_cars() except Exception as e: logger.error(f\"Error recalculating invoices on CarService delete: {e}\") # ============================================================================ # КАСКАДНОЕ УДАЛЕНИЕ CarService ПРИ УДАЛЕНИИ УСЛУГ ИЗ СПРАВОЧНИКОВ # ============================================================================ @receiver(pre_delete, sender=LineService) def delete_car_services_on_line_service_delete(sender, instance, **kwargs): \"\"\" Удаляет связанные CarService записи при удалении услуги линии. Это предотвращает появление 'битых' записей с несуществующими service_id. \"\"\" try: deleted_count = CarService.objects.filter( service_type='LINE', service_id=instance.id ).delete()[0] if deleted_count > 0: logger.info(f\"🗑️ Удалено {deleted_count} CarService записей при удалении LineService '{instance.name}' (id={instance.id})\") except Exception as e: log", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "d=instance.id ).delete()[0] if deleted_count > 0: logger.info(f\"🗑️ Удалено {deleted_count} CarService записей при удалении LineService '{instance.name}' (id={instance.id})\") except Exception as e: logger.error(f\"Error deleting CarService on LineService delete: {e}\") @receiver(pre_delete, sender=WarehouseService) def delete_car_services_on_warehouse_service_delete(sender, instance, **kwargs): \"\"\" Удаляет связанные CarService записи при удалении услуги склада. Это предотвращает появление 'битых' записей с несуществующими service_id. \"\"\" try: deleted_count = CarService.objects.filter( service_type='WAREHOUSE', service_id=instance.id ).delete()[0] if deleted_count > 0: logger.info(f\"🗑️ Удалено {deleted_count} CarService записей при удалении WarehouseService '{instance.name}' (id={instance.id})\") except Exception as e: logger.error(f\"Error deleting CarService on WarehouseService delete: {e}\") @receiver(pre_delete, sender=CarrierService) def delete_car_services_on_carrier_service_delete(sender, instance, **kwargs): \"\"\" Удаляет связанные CarService записи при удалении услуги перевозчика. Это предотвращает появление 'битых' записей с несуществующими service_id. \"\"\" try: deleted_count = Car", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "er, instance, **kwargs): \"\"\" Удаляет связанные CarService записи при удалении услуги перевозчика. Это предотвращает появление 'битых' записей с несуществующими service_id. \"\"\" try: deleted_count = CarService.objects.filter( service_type='CARRIER', service_id=instance.id ).delete()[0] if deleted_count > 0: logger.info(f\"🗑️ Удалено {deleted_count} CarService записей при удалении CarrierService '{instance.name}' (id={instance.id})\") except Exception as e: logger.error(f\"Error deleting CarService on CarrierService delete: {e}\") @receiver(pre_delete, sender=CompanyService) def delete_car_services_on_company_service_delete(sender, instance, **kwargs): \"\"\" Удаляет связанные CarService записи при удалении услуги компании. \"\"\" try: deleted_count = CarService.objects.filter( service_type='COMPANY', service_id=instance.id ).delete()[0] if deleted_count > 0: logger.info(f\"🗑️ Удалено {deleted_count} CarService записей при удалении CompanyService '{instance.name}' (id={instance.id})\") except Exception as e: logger.error(f\"Error deleting CarService on CompanyService delete: {e}\") # ============================================================================ # СИГНАЛЫ ДЛЯ EMAIL-УВЕДОМЛЕНИЙ КЛИЕНТО", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "on as e: logger.error(f\"Error deleting CarService on CompanyService delete: {e}\") # ============================================================================ # СИГНАЛЫ ДЛЯ EMAIL-УВЕДОМЛЕНИЙ КЛИЕНТОВ # ============================================================================ # Храним старые значения для определения изменений _old_notification_values = {} @receiver(pre_save, sender=Container) def save_old_notification_values(sender, instance, **kwargs): \"\"\"Сохраняем старые значения planned_unload_date и unload_date перед сохранением\"\"\" if instance.pk: try: old = Container.objects.filter(pk=instance.pk).values('planned_unload_date', 'unload_date').first() if old: _old_notification_values[instance.pk] = { 'planned_unload_date': old.get('planned_unload_date'), 'unload_date': old.get('unload_date') } except Exception: pass @receiver(post_save, sender=Container) def send_container_notifications_on_save(sender, instance, created, **kwargs): \"\"\" Автоматически отправляет уведомления клиентам: - При установке planned_unload_date -> уведомление о планируемой разгрузке - При установке unload_date -> уведомление о фактической разгрузке \"\"\" if not instance.pk: return # Получаем старые значе", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "ам: - При установке planned_unload_date -> уведомление о планируемой разгрузке - При установке unload_date -> уведомление о фактической разгрузке \"\"\" if not instance.pk: return # Получаем старые значения old_values = _old_notification_values.pop(instance.pk, {}) old_planned_unload_date = old_values.get('planned_unload_date') old_unload_date = old_values.get('unload_date') # Проверяем нужно ли отправить уведомление о планируемой разгрузке should_notify_planned = False if instance.planned_unload_date: if created: should_notify_planned = True elif old_planned_unload_date is None: # Планируемая дата разгрузки была установлена впервые should_notify_planned = True # Проверяем нужно ли отправить уведомление о фактической разгрузке should_notify_unload = False if instance.unload_date: if created: should_notify_unload = True elif old_unload_date is None: # Дата разгрузки была установлена впервые should_notify_unload = True # Отправляем уведомления асинхронно после коммита транзакции if should_notify_planned: def send_planned_notifications(): try: from core.services.email_service import ContainerNotificationService if not ContainerNotificationService.was_planned_notification_sent(instance): ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": "otify_planned: def send_planned_notifications(): try: from core.services.email_service import ContainerNotificationService if not ContainerNotificationService.was_planned_notification_sent(instance): sent, failed = ContainerNotificationService.send_planned_to_all_clients(instance) if sent > 0: logger.info(f\"📧 Auto-sent planned unload notifications for {instance.number}: {sent} sent, {failed} failed\") else: logger.debug(f\"Planned unload notifications already sent for {instance.number}\") except Exception as e: logger.error(f\"Failed to send planned unload notifications for {instance.number}: {e}\") transaction.on_commit(send_planned_notifications) if should_notify_unload: def send_unload_notifications(): try: from core.services.email_service import ContainerNotificationService if not ContainerNotificationService.was_unload_notification_sent(instance): sent, failed = ContainerNotificationService.send_unload_to_all_clients(instance) if sent > 0: logger.info(f\"📧 Auto-sent unload notifications for {instance.number}: {sent} sent, {failed} failed\") else: logger.debug(f\"Unload notifications already sent for {instance.number}\") except Exception as e: logger.error(f\"Failed to send unload notifi", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\signals.py", "content": " for {instance.number}: {sent} sent, {failed} failed\") else: logger.debug(f\"Unload notifications already sent for {instance.number}\") except Exception as e: logger.error(f\"Failed to send unload notifications for {instance.number}: {e}\") transaction.on_commit(send_unload_notifications) # Сигнал для автоматической синхронизации фотографий с Google Drive @receiver(post_save, sender=Container) def auto_sync_photos_on_container_change(sender, instance, created, **kwargs): \"\"\" Автоматическая синхронизация фотографий перенесена в регулярный cron. Логика: через 12 часов после статуса \"Разгружен\" и затем каждый час. \"\"\" if not instance.pk: return if instance.status == 'UNLOADED': logger.info( f\"📸 Контейнер {instance.number}: статус UNLOADED. \" \"Синхронизация будет выполнена по крону (через 12 часов и далее каждый час).\" )", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "from django.http import HttpResponse, JsonResponse import re from django.views.decorators.http import require_GET from django.utils import timezone from django.template.loader import render_to_string from django.contrib.auth.decorators import login_required from django.db.models import Q, Sum from datetime import timedelta, datetime from typing import Optional from .models import Car, Container, Client, Warehouse, Line, Company, Carrier, CarService, WarehouseService, LineService, CarrierService, CompanyService from .models_billing import NewInvoice as Invoice, Transaction as Payment from .services.comparison_service import ComparisonService from .pagination import paginate_queryset, paginated_json_response, PaginationHelper from .cache_utils import cache_company_stats, cache_client_stats, cache_warehouse_stats, cache_comparison_data from decimal import Decimal import logging from django.shortcuts import render, get_object_or_404 from django.contrib.admin.views.decorators import staff_member_required from django.utils import timezone from django.views.decorators.csrf import csrf_exempt from django.apps import apps logger = logging.getLogger('django') def car_list_api(request): \"\"\"Во", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "ember_required from django.utils import timezone from django.views.decorators.csrf import csrf_exempt from django.apps import apps logger = logging.getLogger('django') def car_list_api(request): \"\"\"Возвращает список автомобилей для клиента, отфильтрованный по статусу.\"\"\" raw_client = (request.GET.get('client_id') or request.GET.get('client') or '').strip() # Нормализуем client_id: берём только цифры m = re.search(r\"\\d+\", raw_client) raw_client = m.group(0) if m else '' search_query: str = request.GET.get('search', '').strip().lower() logger.info(f\"car_list_api called with GET: {request.GET}\") logger.info(f\"Extracted client: '{raw_client}', search: '{search_query}'\") try: client_id_int = int(raw_client) except (TypeError, ValueError): client_id_int = None if client_id_int: # Используем оптимизированный менеджер с prefetch allowed_statuses = ['UNLOADED', 'IN_PORT', 'FLOATING', 'TRANSFERRED'] all_cars = Car.objects.by_client(client_id_int).filter( status__in=allowed_statuses ).select_related('client', 'warehouse', 'container', 'line', 'carrier') logger.info(f\"All cars for client {client_id_int}: {all_cars.count()}\") if all_cars.exists(): for car in all_cars: logger.debug(f\"Car {car.pk", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "ted('client', 'warehouse', 'container', 'line', 'carrier') logger.info(f\"All cars for client {client_id_int}: {all_cars.count()}\") if all_cars.exists(): for car in all_cars: logger.debug(f\"Car {car.pk}: VIN={car.vin}, Brand={car.brand}, Year={car.year}, Status={car.status}, Transfer Date={car.transfer_date}\") else: logger.warning(f\"No cars found for client {client_id_int}\") if search_query: year_q = Q() if search_query.isdigit(): try: year_q = Q(year=int(search_query)) except Exception: year_q = Q() all_cars = all_cars.filter( Q(vin__icontains=search_query) | Q(brand__icontains=search_query) | year_q ) logger.info(f\"Filtered cars with search '{search_query}': {all_cars.count()}\") if all_cars.exists(): for car in all_cars: logger.debug(f\"Filtered car: {car.pk} - VIN: {car.vin}, Brand: {car.brand}, Year: {car.year}, Status: {car.status}, Transfer Date={car.transfer_date}\") html = render_to_string('admin/car_options.html', context={'cars': all_cars}, request=request) logger.debug(f\"Returning HTML: {html[:100]}...\") return HttpResponse(html, content_type='text/html') logger.warning(\"Invalid or missing client id, returning no client selected\") return HttpResponse('<option class=\"no-resu", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "ing HTML: {html[:100]}...\") return HttpResponse(html, content_type='text/html') logger.warning(\"Invalid or missing client id, returning no client selected\") return HttpResponse('<option class=\"no-results\">Клиент не выбран</option>', content_type='text/html') @require_GET def get_invoice_total(request): \"\"\"Вычисляет общую сумму для выбранных автомобилей.\"\"\" car_ids = request.GET.get('car_ids', '').split(',') car_ids = [int(cid) for cid in car_ids if cid.strip().isdigit()] logger.info(f\"get_invoice_total called with car_ids: {car_ids}\") result = {'total_amount': '0.00'} if not car_ids: logger.warning(\"No valid car IDs provided, returning 0.00\") return JsonResponse(result) try: cars = Car.objects.filter(id__in=car_ids).select_related( 'client', 'warehouse', 'container', 'line', 'carrier' ) if not cars.exists(): logger.warning(f\"No cars found for IDs: {car_ids}\") result['error'] = 'No cars found for the provided IDs' return JsonResponse(result) logger.info(f\"Cars found: {list(cars)}\") for car in cars: logger.debug(f\"Car {car.pk}: total_price={car.total_price}, storage_cost={car.storage_cost}\") except Exception as e: logger.error(f\"Error querying cars: {e}\") result['error'] = f\"Error qu", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "car in cars: logger.debug(f\"Car {car.pk}: total_price={car.total_price}, storage_cost={car.storage_cost}\") except Exception as e: logger.error(f\"Error querying cars: {e}\") result['error'] = f\"Error querying cars: {e}\" return JsonResponse(result, status=500) try: total = Decimal('0.00') for car in cars: current_price, total_price = car.calculate_total_price() add = total_price if (total_price and total_price > 0) else (current_price or Decimal('0.00')) total += Decimal(str(add)) result['total_amount'] = str(total) logger.info(f\"Calculated total_amount (in-memory): {result['total_amount']}\") return JsonResponse(result) except Exception as e: logger.error(f\"Error calculating total in-memory: {e}\") result['error'] = str(e) return JsonResponse(result, status=500) @require_GET def get_container_data(request, container_id: int): \"\"\"Возвращает данные контейнера по ID.\"\"\" logger.info(f\"get_container_data called with container_id: {container_id}\") try: container = Container.objects.get(id=container_id) container.refresh_from_db() data = { 'free_days': container.free_days, 'storage_cost': str(container.storage_cost), 'status': container.status, } logger.info(f\"get_container_data: ID={containe", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "ner_id) container.refresh_from_db() data = { 'free_days': container.free_days, 'storage_cost': str(container.storage_cost), 'status': container.status, } logger.info(f\"get_container_data: ID={container_id}, free_days={container.free_days}, storage_cost={container.storage_cost}\") return JsonResponse(data) except Container.DoesNotExist: logger.error(f\"Container not found: ID={container_id}\") return JsonResponse({'error': 'Container not found'}, status=404) @require_GET def get_client_balance(request): \"\"\"Возвращает детализированный баланс клиента по ID.\"\"\" client_id: Optional[str] = request.GET.get('client_id') logger.info(f\"get_client_balance called with client_id: {client_id}\") if client_id and client_id.isdigit(): try: from decimal import Decimal client = Client.objects.get(id=client_id) details = client.balance_details() # Совместимость с фронтендом: total_balance и status real_balance = client.real_balance total_balance = real_balance # используем реальный баланс status = 'Переплата' if total_balance < 0 else ('Задолженность' if total_balance > 0 else 'Ноль') response = { **details, 'total_balance': str(total_balance), 'status': status, } logger.info(f\"Client balance for {client", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "' if total_balance < 0 else ('Задолженность' if total_balance > 0 else 'Ноль') response = { **details, 'total_balance': str(total_balance), 'status': status, } logger.info(f\"Client balance for {client_id}: {response}\") return JsonResponse(response) except Client.DoesNotExist: logger.error(f\"Client not found: ID={client_id}\") return JsonResponse({'error': 'Client not found'}, status=404) logger.warning(\"Invalid client ID\") return JsonResponse({'error': 'Invalid client ID'}, status=400) @login_required def register_payment(request): \"\"\"Регистрирует платеж для инвойса.\"\"\" if request.method != 'POST': logger.warning(\"Invalid request method for register_payment\") return JsonResponse({'status': 'error', 'message': 'Invalid request method'}, status=400) invoice_id: Optional[str] = request.POST.get('invoice_id') amount: float = float(request.POST.get('amount', 0)) payment_type: Optional[str] = request.POST.get('payment_type') from_balance: bool = request.POST.get('from_balance') == 'on' from_cash_balance: bool = request.POST.get('from_cash_balance') == 'on' description: str = request.POST.get('description', '') payer_id: Optional[str] = request.POST.get('payer_id') recipient: str = request", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "ash_balance: bool = request.POST.get('from_cash_balance') == 'on' description: str = request.POST.get('description', '') payer_id: Optional[str] = request.POST.get('payer_id') recipient: str = request.POST.get('recipient', '') logger.info(f\"Registering payment: invoice_id={invoice_id}, amount={amount}, payment_type={payment_type}, from_balance={from_balance}, from_cash_balance={from_cash_balance}, payer_id={payer_id}\") try: invoice = Invoice.objects.get(id=invoice_id) if invoice_id else None payer = Client.objects.get(id=payer_id) if payer_id else None if from_balance and not payer: logger.error(\"Payer required for balance payment\") return JsonResponse({'status': 'error', 'message': 'Плательщик обязателен для оплаты с баланса'}, status=400) # Проверка достаточности баланса для платежа с баланса if from_balance and payer: if not payer.can_pay_from_balance(amount, payment_type, from_cash_balance): logger.error(f\"Insufficient funds for client {payer.name}: amount={amount}, from_cash_balance={from_cash_balance}\") return JsonResponse({'status': 'error', 'message': f\"Недостаточно средств на {'наличном' if from_cash_balance else 'безналичном'} балансе\"}, status=400) payment = Payment( inv", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "ce={from_cash_balance}\") return JsonResponse({'status': 'error', 'message': f\"Недостаточно средств на {'наличном' if from_cash_balance else 'безналичном'} балансе\"}, status=400) payment = Payment( invoice=invoice, amount=amount, payment_type=payment_type, description=description, from_client=payer, to_client=recipient if hasattr(recipient, 'name') else None, to_warehouse=recipient if hasattr(recipient, 'name') and 'warehouse' in str(type(recipient)).lower() else None, to_line=recipient if hasattr(recipient, 'name') and 'line' in str(type(recipient)).lower() else None, to_company=recipient if hasattr(recipient, 'name') and 'company' in str(type(recipient)).lower() else None ) payment.save() logger.info(f\"Payment saved: id={payment.pk}, client_id={payer.pk if payer else 'N/A'}, cash_balance={payer.cash_balance if payer else 'N/A'}, card_balance={payer.card_balance if payer else 'N/A'}\") return JsonResponse({ 'status': 'success', 'message': f'Платеж на сумму {amount} зарегистрирован', 'client_balance': str(payer.invoice_balance) if payer else None, 'cash_balance': str(payer.cash_balance) if payer else None, 'card_balance': str(payer.card_balance) if payer else None }) except (Invoice.", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "ient_balance': str(payer.invoice_balance) if payer else None, 'cash_balance': str(payer.cash_balance) if payer else None, 'card_balance': str(payer.card_balance) if payer else None }) except (Invoice.DoesNotExist, Client.DoesNotExist) as e: logger.error(f\"Error registering payment: {e}\") return JsonResponse({'status': 'error', 'message': str(e)}, status=404) except ValueError as e: logger.error(f\"Error registering payment: {e}\") return JsonResponse({'status': 'error', 'message': str(e)}, status=400) except Exception as e: logger.error(f\"Unexpected error registering payment: {e}\") return JsonResponse({'status': 'error', 'message': str(e)}, status=500) @staff_member_required def company_dashboard(request): \"\"\"Дашборд для Caromoto Lithuania с кэшированием\"\"\" # Получаем кэшированную статистику компании stats = cache_company_stats() if not stats: # Fallback к прямому запросу если кэш недоступен company = get_object_or_404(Company, name=\"Caromoto Lithuania\") # Получаем текущий месяц now = timezone.now() start_of_month = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0) # Общий баланс компании company_total_balance = company.invoice_balance + company.cash_balance + company.car", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "mezone.now() start_of_month = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0) # Общий баланс компании company_total_balance = company.invoice_balance + company.cash_balance + company.card_balance # Прибыль за месяц (входящие платежи) monthly_income = Payment.objects.filter( to_company=company, date__gte=start_of_month ).aggregate(total=Sum('amount'))['total'] or 0 # Расходы за месяц (исходящие платежи) monthly_expenses = Payment.objects.filter( from_company=company, date__gte=start_of_month ).aggregate(total=Sum('amount'))['total'] or 0 # Прибыль за месяц monthly_profit = monthly_income - monthly_expenses # Количество активных инвойсов (неоплаченные и частично оплаченные) active_invoices_count = Invoice.objects.filter( paid=False ).count() # Последние транзакции (последние 20) recent_transactions = Payment.objects.filter( Q(from_company=company) | Q(to_company=company) ).order_by('-date')[:20] # Активные инвойсы (неоплаченные и частично оплаченные) active_invoices = Invoice.objects.filter( paid=False ).order_by('-issue_date')[:10] else: # Используем кэшированные данные company_total_balance = stats['company']['total_balance'] monthly_profit = stats['monthly']['payment", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "ce.objects.filter( paid=False ).order_by('-issue_date')[:10] else: # Используем кэшированные данные company_total_balance = stats['company']['total_balance'] monthly_profit = stats['monthly']['payments']['total_amount'] - stats['monthly']['invoices']['total_amount'] monthly_expenses = stats['monthly']['invoices']['total_amount'] active_invoices_count = stats['monthly']['invoices']['count'] # Получаем компанию для дополнительных данных company = get_object_or_404(Company, name=\"Caromoto Lithuania\") # Последние транзакции (последние 20) - не кэшируем для актуальности recent_transactions = Payment.objects.filter( Q(from_company=company) | Q(to_company=company) ).order_by('-date')[:20] # Активные инвойсы (неоплаченные и частично оплаченные) - не кэшируем для актуальности active_invoices = Invoice.objects.filter( paid=False ).order_by('-issue_date')[:10] # Последние действия (имитация) recent_activities = [ { 'icon': '💰', 'title': 'Платеж получен', 'description': f'От клиента на сумму {monthly_income:.2f} €', 'time': now }, { 'icon': '📄', 'title': 'Инвойс создан', 'description': f'Новый инвойс #{active_invoices_count + 1}', 'time': now - timedelta(hours=2) }, { 'icon': '💳', 'title': 'Тр", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "hly_income:.2f} €', 'time': now }, { 'icon': '📄', 'title': 'Инвойс создан', 'description': f'Новый инвойс #{active_invoices_count + 1}', 'time': now - timedelta(hours=2) }, { 'icon': '💳', 'title': 'Транзакция баланса', 'description': 'Обновление баланса компании', 'time': now - timedelta(hours=4) } ] context = { 'company': company, 'company_total_balance': company_total_balance, 'monthly_profit': monthly_profit, 'monthly_expenses': monthly_expenses, 'active_invoices_count': active_invoices_count, 'recent_transactions': recent_transactions, 'active_invoices': active_invoices, 'recent_activities': recent_activities, } return render(request, 'admin/company_dashboard.html', context) @staff_member_required def get_payment_objects(request): \"\"\"AJAX view для получения списка объектов определенного типа для формы платежа\"\"\" object_type = request.GET.get('type') logger.info(f\"get_payment_objects called with type: {object_type}\") if not object_type: logger.warning(\"No type parameter provided\") return JsonResponse({'error': 'Type parameter is required'}, status=400) try: # Получаем модель по типу logger.info(f\"Getting model for type: {object_type}\") model = apps.get_model('core', object_type.", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "eturn JsonResponse({'error': 'Type parameter is required'}, status=400) try: # Получаем модель по типу logger.info(f\"Getting model for type: {object_type}\") model = apps.get_model('core', object_type.title()) logger.info(f\"Model class: {model}\") # Получаем все объекты модели, отсортированные по имени objects = model.objects.all().order_by('name' if hasattr(model, 'name') else 'id') logger.info(f\"Found {objects.count()} objects\") # Формируем список объектов для JSON objects_list = [] for obj in objects: display_name = getattr(obj, 'name', str(obj)) objects_list.append({ 'id': obj.id, 'name': display_name }) logger.info(f\"Returning {len(objects_list)} objects\") return JsonResponse({ 'type': object_type, 'objects': objects_list }) except Exception as e: logger.error(f\"Error getting objects for type {object_type}: {e}\") return JsonResponse({'error': str(e)}, status=500) @require_GET def search_partners_api(request): \"\"\"API для поиска партнеров по типу и названию\"\"\" entity_type = request.GET.get('entity_type', '').strip().upper() search_query = request.GET.get('search', '').strip() if not entity_type: response = JsonResponse({'error': 'Entity type is required'}, status=400) response['Co", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "T.get('entity_type', '').strip().upper() search_query = request.GET.get('search', '').strip() if not entity_type: response = JsonResponse({'error': 'Entity type is required'}, status=400) response['Content-Type'] = 'application/json' return response try: # Определяем модель на основе типа model_map = { 'CLIENT': Client, 'WAREHOUSE': Warehouse, 'LINE': Line, 'CARRIER': Carrier, 'COMPANY': Company } if entity_type not in model_map: response = JsonResponse({'error': f'Invalid entity type: {entity_type}'}, status=400) response['Content-Type'] = 'application/json' return response model = model_map[entity_type] # Поиск по названию if search_query and len(search_query) >= 2: # Создаем базовый фильтр name_filter = Q(name__icontains=search_query) # Добавляем фильтр по short_name, если модель его поддерживает if hasattr(model, 'short_name'): name_filter |= Q(short_name__icontains=search_query) objects = model.objects.filter(name_filter).order_by('name' if hasattr(model, 'name') else 'id')[:10] else: # Если поисковый запрос пустой или слишком короткий, не возвращаем ничего objects = model.objects.none() # Формируем список объектов для JSON objects_list = [] for obj in objects: display_name = ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "lse: # Если поисковый запрос пустой или слишком короткий, не возвращаем ничего objects = model.objects.none() # Формируем список объектов для JSON objects_list = [] for obj in objects: display_name = getattr(obj, 'name', str(obj)) objects_list.append({ 'id': obj.id, 'name': display_name, 'type': entity_type }) response = JsonResponse({ 'type': entity_type, 'objects': objects_list }) response['Content-Type'] = 'application/json' return response except Exception as e: logger.error(f\"Error searching partners for type {entity_type}: {e}\") response = JsonResponse({'error': str(e)}, status=500) response['Content-Type'] = 'application/json' return response @require_GET def get_invoice_cars_api(request): \"\"\"API для получения автомобилей для инвойса - показываем автомобили, связанные с отправителем\"\"\" from_entity_type = request.GET.get('from_entity_type') from_entity_id = request.GET.get('from_entity_id') to_entity_type = request.GET.get('to_entity_type') to_entity_id = request.GET.get('to_entity_id') search_query = request.GET.get('search', '').strip() logger.info(f\"get_invoice_cars_api called with: from_entity_type={from_entity_type}, from_entity_id={from_entity_id}, to_entity_type={to_en", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "ty_id') search_query = request.GET.get('search', '').strip() logger.info(f\"get_invoice_cars_api called with: from_entity_type={from_entity_type}, from_entity_id={from_entity_id}, to_entity_type={to_entity_type}, to_entity_id={to_entity_id}, search_query={search_query}\") # Проверяем наличие отправителя (обязательно) и получателя (опционально) if not all([from_entity_type, from_entity_id]): logger.warning(f\"Missing from_entity parameters: from_entity_type={from_entity_type}, from_entity_id={from_entity_id}\") response = JsonResponse({'error': 'From entity parameters are required'}, status=400) response['Content-Type'] = 'application/json' return response try: # Получаем автомобили за последние 6 месяцев six_months_ago = timezone.now().date() - timedelta(days=180) cars = Car.objects.none() # Показываем автомобили, связанные с отправителем if from_entity_type == 'CLIENT': # Если отправитель - клиент, показываем автомобили этого клиента cars = Car.objects.filter( Q(client_id=from_entity_id) & Q(status__in=['UNLOADED', 'IN_PORT', 'TRANSFERRED', 'FLOATING']) & Q(unload_date__gte=six_months_ago) ).select_related('client', 'warehouse', 'container', 'line', 'carrier') elif from_entity_type ==", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "& Q(status__in=['UNLOADED', 'IN_PORT', 'TRANSFERRED', 'FLOATING']) & Q(unload_date__gte=six_months_ago) ).select_related('client', 'warehouse', 'container', 'line', 'carrier') elif from_entity_type == 'WAREHOUSE': # Если отправитель - склад, показываем автомобили на этом складе cars = Car.objects.filter( Q(warehouse_id=from_entity_id) & Q(status__in=['UNLOADED', 'IN_PORT', 'TRANSFERRED']) & Q(unload_date__gte=six_months_ago) ).select_related('client', 'warehouse', 'container', 'line', 'carrier') elif from_entity_type == 'LINE': # Если отправитель - линия, показываем автомобили, связанные с этой линией cars = Car.objects.filter( Q(line_id=from_entity_id) & Q(status__in=['UNLOADED', 'IN_PORT', 'TRANSFERRED']) & Q(unload_date__gte=six_months_ago) ).select_related('client', 'warehouse', 'container', 'line', 'carrier') elif from_entity_type == 'COMPANY': # Если отправитель - компания, показываем все автомобили cars = Car.objects.filter( Q(status__in=['UNLOADED', 'IN_PORT', 'TRANSFERRED']) & Q(unload_date__gte=six_months_ago) ).select_related('client', 'warehouse', 'container', 'line', 'carrier') # Дополнительная фильтрация по получателю, если указан if to_entity_type and to_entity_id: i", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": " Q(unload_date__gte=six_months_ago) ).select_related('client', 'warehouse', 'container', 'line', 'carrier') # Дополнительная фильтрация по получателю, если указан if to_entity_type and to_entity_id: if to_entity_type == 'WAREHOUSE': # Если получатель - склад, фильтруем автомобили на этом складе cars = cars.filter(warehouse_id=to_entity_id) elif to_entity_type == 'CLIENT': # Если получатель - клиент, фильтруем автомобили этого клиента cars = cars.filter(client_id=to_entity_id) # Поиск по автомобилям if search_query: year_q = Q() if search_query.isdigit(): try: year_q = Q(year=int(search_query)) except Exception: year_q = Q() cars = cars.filter( Q(vin__icontains=search_query) | Q(brand__icontains=search_query) | year_q ) # Формируем данные для каждого автомобиля cars_data = [] logger.info(f\"Found {cars.count()} cars for entity type {to_entity_type} with ID {to_entity_id}\") for car in cars: # Всегда показываем полную стоимость автомобиля total_cost = car.total_price or car.current_price or Decimal('0.00') cars_data.append({ 'id': car.id, 'vin': car.vin, 'brand': car.brand, 'year': car.year, 'status': car.status, 'client_name': car.client.name if car.client else 'Не указан', 'warehouse", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "r Decimal('0.00') cars_data.append({ 'id': car.id, 'vin': car.vin, 'brand': car.brand, 'year': car.year, 'status': car.status, 'client_name': car.client.name if car.client else 'Не указан', 'warehouse_name': car.warehouse.name if car.warehouse else 'Не указан', 'unload_date': car.unload_date.strftime('%d.%m.%Y') if car.unload_date else 'Не указана', 'transfer_date': car.transfer_date.strftime('%d.%m.%Y') if car.transfer_date else 'Не указана', 'total_cost': f\"{total_cost:.2f}\", # Добавляем поля для расчета стоимости услуг 'storage_cost': float(car.storage_cost or 0), 'ocean_freight': float(car.ocean_freight or 0), 'ths': float(car.ths or 0), 'delivery_fee': float(car.delivery_fee or 0), 'transport_kz': float(car.transport_kz or 0) }) logger.info(f\"Returning {len(cars_data)} cars\") response = JsonResponse({'cars': cars_data}) response['Content-Type'] = 'application/json' return response except Exception as e: logger.error(f\"Error getting invoice cars: {e}\") response = JsonResponse({'error': str(e)}, status=500) response['Content-Type'] = 'application/json' return response @require_GET def get_warehouse_cars_api(request): \"\"\"API для получения доступных автомобилей для склада (Caromot", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "or': str(e)}, status=500) response['Content-Type'] = 'application/json' return response @require_GET def get_warehouse_cars_api(request): \"\"\"API для получения доступных автомобилей для склада (Caromoto Lithuania)\"\"\" warehouse_id = request.GET.get('warehouse_id') search_query = request.GET.get('search', '').strip() if not warehouse_id: response = JsonResponse({'error': 'Warehouse ID is required'}, status=400) response['Content-Type'] = 'application/json' return response try: # Получаем автомобили за последний месяц для указанного склада month_ago = timezone.now().date() - timedelta(days=30) # Ищем автомобили, которые были разгружены или переданы на склад за последний месяц cars = Car.objects.filter( Q(warehouse_id=warehouse_id) & Q(status__in=['UNLOADED', 'TRANSFERRED']) & Q(unload_date__gte=month_ago) ).select_related('client', 'warehouse', 'container', 'line', 'carrier') if search_query: year_q = Q() if search_query.isdigit(): try: year_q = Q(year=int(search_query)) except Exception: year_q = Q() cars = cars.filter( Q(vin__icontains=search_query) | Q(brand__icontains=search_query) | year_q ) # Формируем данные для каждого автомобиля cars_data = [] for car in cars: # Вычисляем стои", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "year_q = Q() cars = cars.filter( Q(vin__icontains=search_query) | Q(brand__icontains=search_query) | year_q ) # Формируем данные для каждого автомобиля cars_data = [] for car in cars: # Вычисляем стоимость складских услуг warehouse_services = ( (car.unload_fee or Decimal('0.00')) + (car.delivery_fee or Decimal('0.00')) + (car.loading_fee or Decimal('0.00')) + (car.docs_fee or Decimal('0.00')) + (car.transfer_fee or Decimal('0.00')) + (car.transit_declaration or Decimal('0.00')) + (car.export_declaration or Decimal('0.00')) + (car.extra_costs or Decimal('0.00')) + (car.complex_fee or Decimal('0.00')) + (car.storage_cost or Decimal('0.00')) ) cars_data.append({ 'id': car.id, 'vin': car.vin, 'brand': car.brand, 'year': car.year, 'status': car.status, 'client_name': car.client.name if car.client else 'Не указан', 'unload_date': car.unload_date.strftime('%d.%m.%Y') if car.unload_date else 'Не указана', 'transfer_date': car.transfer_date.strftime('%d.%m.%Y') if car.transfer_date else 'Не указана', 'warehouse_services_cost': f\"{warehouse_services:.2f}\", 'storage_cost': f\"{car.storage_cost or 0:.2f}\", 'total_warehouse_cost': f\"{warehouse_services:.2f}\" }) response = JsonResponse({'cars': c", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "зана', 'warehouse_services_cost': f\"{warehouse_services:.2f}\", 'storage_cost': f\"{car.storage_cost or 0:.2f}\", 'total_warehouse_cost': f\"{warehouse_services:.2f}\" }) response = JsonResponse({'cars': cars_data}) response['Content-Type'] = 'application/json' return response except Exception as e: logger.error(f\"Error getting warehouse cars: {e}\") response = JsonResponse({'error': str(e)}, status=500) response['Content-Type'] = 'application/json' return response @staff_member_required def comparison_dashboard(request): \"\"\"Дашборд для сравнения сумм между расчетами и счетами склада\"\"\" # Получаем параметры фильтрации start_date = request.GET.get('start_date') end_date = request.GET.get('end_date') if start_date: start_date = datetime.strptime(start_date, '%Y-%m-%d').date() if end_date: end_date = datetime.strptime(end_date, '%Y-%m-%d').date() # Создаем сервис сравнения comparison_service = ComparisonService() # Получаем общий отчет report = comparison_service.get_comparison_report(start_date, end_date) # Находим расхождения discrepancies = comparison_service.find_discrepancies(start_date, end_date) # Получаем статистику по клиентам clients = Client.objects.all() client_comparisons = [] ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "e, end_date) # Находим расхождения discrepancies = comparison_service.find_discrepancies(start_date, end_date) # Получаем статистику по клиентам clients = Client.objects.all() client_comparisons = [] for client in clients: comparison = comparison_service.compare_client_costs_with_warehouse_invoices( client, start_date, end_date ) if comparison['status'] != 'no_data': client_comparisons.append(comparison) # Получаем статистику по складам warehouses = Warehouse.objects.all() warehouse_comparisons = [] for warehouse in warehouses: comparison = comparison_service.compare_warehouse_costs_with_payments( warehouse, start_date, end_date ) if comparison['status'] != 'no_data': warehouse_comparisons.append(comparison) context = { 'report': report, 'discrepancies': discrepancies, 'client_comparisons': client_comparisons, 'warehouse_comparisons': warehouse_comparisons, 'start_date': start_date, 'end_date': end_date, } return render(request, 'admin/comparison_dashboard.html', context) @require_GET def compare_car_costs_api(request): \"\"\"API для сравнения стоимости конкретного автомобиля\"\"\" car_id = request.GET.get('car_id') if not car_id: return JsonResponse({'error': 'Car ID is required'}, stat", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "def compare_car_costs_api(request): \"\"\"API для сравнения стоимости конкретного автомобиля\"\"\" car_id = request.GET.get('car_id') if not car_id: return JsonResponse({'error': 'Car ID is required'}, status=400) try: car = Car.objects.get(id=car_id) comparison_service = ComparisonService() result = comparison_service.compare_car_costs_with_warehouse_invoices(car) return JsonResponse(result) except Car.DoesNotExist: return JsonResponse({'error': 'Car not found'}, status=404) except Exception as e: return JsonResponse({'error': str(e)}, status=500) @require_GET def compare_client_costs_api(request): \"\"\"API для сравнения стоимости автомобилей клиента\"\"\" client_id = request.GET.get('client_id') start_date = request.GET.get('start_date') end_date = request.GET.get('end_date') if not client_id: return JsonResponse({'error': 'Client ID is required'}, status=400) try: client = Client.objects.get(id=client_id) comparison_service = ComparisonService() if start_date: start_date = datetime.strptime(start_date, '%Y-%m-%d').date() if end_date: end_date = datetime.strptime(end_date, '%Y-%m-%d').date() result = comparison_service.compare_client_costs_with_warehouse_invoices( client, start_date, end_da", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "art_date, '%Y-%m-%d').date() if end_date: end_date = datetime.strptime(end_date, '%Y-%m-%d').date() result = comparison_service.compare_client_costs_with_warehouse_invoices( client, start_date, end_date ) return JsonResponse(result) except Client.DoesNotExist: return JsonResponse({'error': 'Client not found'}, status=404) except Exception as e: return JsonResponse({'error': str(e)}, status=500) @require_GET def compare_warehouse_costs_api(request): \"\"\"API для сравнения стоимости услуг склада\"\"\" warehouse_id = request.GET.get('warehouse_id') start_date = request.GET.get('start_date') end_date = request.GET.get('end_date') if not warehouse_id: return JsonResponse({'error': 'Warehouse ID is required'}, status=400) try: warehouse = Warehouse.objects.get(id=warehouse_id) comparison_service = ComparisonService() if start_date: start_date = datetime.strptime(start_date, '%Y-%m-%d').date() if end_date: end_date = datetime.strptime(end_date, '%Y-%m-%d').date() result = comparison_service.compare_warehouse_costs_with_payments( warehouse, start_date, end_date ) return JsonResponse(result) except Warehouse.DoesNotExist: return JsonResponse({'error': 'Warehouse not found'}, status=404) except E", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "e_warehouse_costs_with_payments( warehouse, start_date, end_date ) return JsonResponse(result) except Warehouse.DoesNotExist: return JsonResponse({'error': 'Warehouse not found'}, status=404) except Exception as e: return JsonResponse({'error': str(e)}, status=500) @require_GET def get_discrepancies_api(request): \"\"\"API для получения расхождений\"\"\" start_date = request.GET.get('start_date') end_date = request.GET.get('end_date') try: comparison_service = ComparisonService() if start_date: start_date = datetime.strptime(start_date, '%Y-%m-%d').date() if end_date: end_date = datetime.strptime(end_date, '%Y-%m-%d').date() discrepancies = comparison_service.find_discrepancies(start_date, end_date) return JsonResponse({'discrepancies': discrepancies}) except Exception as e: return JsonResponse({'error': str(e)}, status=500) @staff_member_required @csrf_exempt def get_warehouses(request): \"\"\"Получает список всех активных складов\"\"\" try: warehouses = Warehouse.objects.all().order_by('name') warehouses_data = [{ 'id': warehouse.id, 'name': warehouse.name } for warehouse in warehouses] return JsonResponse({'warehouses': warehouses_data}) except Exception as e: logger.error(f\"Error loading w", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "arehouses_data = [{ 'id': warehouse.id, 'name': warehouse.name } for warehouse in warehouses] return JsonResponse({'warehouses': warehouses_data}) except Exception as e: logger.error(f\"Error loading warehouses: {e}\") return JsonResponse({'error': str(e)}, status=500) @staff_member_required @csrf_exempt def get_companies(request): \"\"\"Получает список всех компаний\"\"\" try: companies = Company.objects.all().order_by('name') companies_data = [{ 'id': company.id, 'name': company.name } for company in companies] return JsonResponse({'companies': companies_data}) except Exception as e: logger.error(f\"Error loading companies: {e}\") return JsonResponse({'error': str(e)}, status=500) def get_available_services(request, car_id): \"\"\"Получает доступные услуги для добавления к автомобилю\"\"\" logger.info(f\"get_available_services called: car_id={car_id}, method={request.method}\") service_type = request.GET.get('type') logger.info(f\"get_available_services called: car_id={car_id}, service_type={service_type}\") if not service_type: logger.error(\"Service type is required\") return JsonResponse({'error': 'Service type is required'}, status=400) try: car = Car.objects.get(id=car_id) logger.info(f\"Found car", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "pe}\") if not service_type: logger.error(\"Service type is required\") return JsonResponse({'error': 'Service type is required'}, status=400) try: car = Car.objects.get(id=car_id) logger.info(f\"Found car: {car.vin}, warehouse={car.warehouse}, line={car.line}, carrier={car.carrier}\") services = [] if service_type == 'warehouse': # Проверяем, передан ли конкретный склад warehouse_id = request.GET.get('warehouse_id') if warehouse_id: warehouse = Warehouse.objects.get(id=warehouse_id) logger.info(f\"Processing warehouse services for selected warehouse: {warehouse}\") elif car.warehouse: warehouse = car.warehouse logger.info(f\"Processing warehouse services for car's warehouse: {warehouse}\") else: logger.info(\"No warehouse selected or assigned to car\") return JsonResponse({'services': []}) # Получаем услуги склада, которые еще не добавлены к автомобилю existing_service_ids = CarService.objects.filter( car=car, service_type='WAREHOUSE' ).values_list('service_id', flat=True) logger.info(f\"Existing warehouse service IDs: {list(existing_service_ids)}\") available_services = WarehouseService.objects.filter( warehouse=warehouse ).exclude(id__in=existing_service_ids) logger.info(f\"Available warehouse", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "warehouse service IDs: {list(existing_service_ids)}\") available_services = WarehouseService.objects.filter( warehouse=warehouse ).exclude(id__in=existing_service_ids) logger.info(f\"Available warehouse services count: {available_services.count()}\") services = [{ 'id': service.id, 'name': service.name, 'price': float(service.default_price) } for service in available_services] elif service_type == 'line' and car.line: logger.info(f\"Processing line services for line: {car.line}\") # Получаем услуги линии, которые еще не добавлены к автомобилю existing_service_ids = CarService.objects.filter( car=car, service_type='LINE' ).values_list('service_id', flat=True) logger.info(f\"Existing line service IDs: {list(existing_service_ids)}\") available_services = LineService.objects.filter( line=car.line ).exclude(id__in=existing_service_ids) logger.info(f\"Available line services count: {available_services.count()}\") services = [{ 'id': service.id, 'name': service.name, 'price': float(service.default_price) } for service in available_services] elif service_type == 'carrier' and car.carrier: logger.info(f\"Processing carrier services for carrier: {car.carrier}\") # Получаем услуги перевозчика, которые е", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "ce) } for service in available_services] elif service_type == 'carrier' and car.carrier: logger.info(f\"Processing carrier services for carrier: {car.carrier}\") # Получаем услуги перевозчика, которые еще не добавлены к автомобилю existing_service_ids = CarService.objects.filter( car=car, service_type='CARRIER' ).values_list('service_id', flat=True) logger.info(f\"Existing carrier service IDs: {list(existing_service_ids)}\") available_services = CarrierService.objects.filter( carrier=car.carrier ).exclude(id__in=existing_service_ids) logger.info(f\"Available carrier services count: {available_services.count()}\") services = [{ 'id': service.id, 'name': service.name, 'price': float(service.default_price) } for service in available_services] elif service_type == 'company': company_id = request.GET.get('company_id') if not company_id: logger.info(\"No company selected\") return JsonResponse({'services': []}) company = Company.objects.get(id=company_id) logger.info(f\"Processing company services for company: {company}\") existing_service_ids = CarService.objects.filter( car=car, service_type='COMPANY' ).values_list('service_id', flat=True) available_services = CompanyService.objects.filter( comp", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "r company: {company}\") existing_service_ids = CarService.objects.filter( car=car, service_type='COMPANY' ).values_list('service_id', flat=True) available_services = CompanyService.objects.filter( company=company ).exclude(id__in=existing_service_ids) services = [{ 'id': service.id, 'name': service.name, 'price': float(service.default_price) } for service in available_services] else: logger.warning(f\"No {service_type} associated with car {car_id}\") services = [] logger.info(f\"Returning {len(services)} services\") return JsonResponse({'services': services}) except Car.DoesNotExist: logger.error(f\"Car not found: {car_id}\") return JsonResponse({'error': 'Car not found'}, status=404) except Exception as e: logger.error(f\"Error getting available services: {e}\", exc_info=True) return JsonResponse({'error': str(e)}, status=500) @staff_member_required @csrf_exempt def add_services(request, car_id): \"\"\"Добавляет выбранные услуги к автомобилю\"\"\" if request.method != 'POST': return JsonResponse({'error': 'Only POST method allowed'}, status=405) try: import json data = json.loads(request.body) service_type = data.get('service_type') service_ids = data.get('service_ids', []) if not service_type o", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "rror': 'Only POST method allowed'}, status=405) try: import json data = json.loads(request.body) service_type = data.get('service_type') service_ids = data.get('service_ids', []) if not service_type or not service_ids: return JsonResponse({'error': 'Service type and IDs are required'}, status=400) car = Car.objects.get(id=car_id) added_count = 0 for service_id in service_ids: service_type_upper = service_type.upper() custom_price = None markup_amount = Decimal('0') try: if service_type_upper == 'WAREHOUSE': service = WarehouseService.objects.get(id=service_id) if service.name == 'Хранение': days = Decimal(str(car.days or 0)) custom_price = days * Decimal(str(service.default_price or 0)) markup_amount = days * Decimal(str(getattr(service, 'default_markup', 0) or 0)) else: custom_price = service.default_price markup_amount = getattr(service, 'default_markup', 0) or 0 elif service_type_upper == 'LINE': service = LineService.objects.get(id=service_id) custom_price = service.default_price markup_amount = getattr(service, 'default_markup', 0) or 0 elif service_type_upper == 'CARRIER': service = CarrierService.objects.get(id=service_id) custom_price = service.default_price markup_amount =", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "arkup_amount = getattr(service, 'default_markup', 0) or 0 elif service_type_upper == 'CARRIER': service = CarrierService.objects.get(id=service_id) custom_price = service.default_price markup_amount = getattr(service, 'default_markup', 0) or 0 elif service_type_upper == 'COMPANY': service = CompanyService.objects.get(id=service_id) custom_price = service.default_price markup_amount = getattr(service, 'default_markup', 0) or 0 else: continue CarService.objects.create( car=car, service_type=service_type_upper, service_id=service_id, custom_price=custom_price, markup_amount=markup_amount ) added_count += 1 except Exception as e: logger.error(f\"Error adding service {service_id} ({service_type_upper}) to car {car_id}: {e}\") return JsonResponse({ 'success': True, 'message': f'Добавлено {added_count} услуг', 'added_count': added_count }) except Exception as e: return JsonResponse({'error': str(e)}, status=500) def get_container_photos_json(request, container_id): \"\"\" API endpoint для получения списка фотографий контейнера. Вызывается через AJAX при клике на раздел \"Фотографии контейнера\". \"\"\" try: from .models import Container from .models_website import ContainerPhoto container = Contain", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "я списка фотографий контейнера. Вызывается через AJAX при клике на раздел \"Фотографии контейнера\". \"\"\" try: from .models import Container from .models_website import ContainerPhoto container = Container.objects.get(id=container_id) photos_data = [] for photo in container.photos.only('id', 'photo', 'thumbnail', 'photo_type').all(): # Ensure URLs have /media/ prefix photo_url = photo.photo.url if photo.photo else '' if photo_url and not photo_url.startswith('/media/') and not photo_url.startswith('http'): photo_url = '/media/' + photo_url.lstrip('/') thumb_url = photo.thumbnail.url if photo.thumbnail else photo_url if thumb_url and not thumb_url.startswith('/media/') and not thumb_url.startswith('http'): thumb_url = '/media/' + thumb_url.lstrip('/') photos_data.append({ 'id': photo.id, 'url': photo_url, 'thumbnail': thumb_url, 'type': photo.photo_type or 'GENERAL' }) return JsonResponse({ 'success': True, 'photos': photos_data, 'count': len(photos_data) }) except Container.DoesNotExist: return JsonResponse({'success': False, 'error': 'Container not found'}, status=404) except Exception as e: return JsonResponse({'success': False, 'error': str(e)}, status=500) @csrf_exempt def sync_co", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "return JsonResponse({'success': False, 'error': 'Container not found'}, status=404) except Exception as e: return JsonResponse({'success': False, 'error': str(e)}, status=500) @csrf_exempt def sync_container_photos_from_gdrive(request, container_id): \"\"\" Синхронизирует фотографии контейнера с Google Drive. Если указана ссылка на папку Google Drive - использует её. Если ссылка не указана - автоматически ищет папку по номеру контейнера в структуре папок Google Drive (ВЫГРУЖЕННЫЕ / В КОНТЕЙНЕРЕ). \"\"\" try: if request.method != 'POST': return JsonResponse({'success': False, 'error': 'Only POST method allowed'}, status=405) from .google_drive_sync import GoogleDriveSync from .models import Container from django.db import connection container = Container.objects.get(id=container_id) container_number = container.number folder_url = container.google_drive_folder_url # Закрываем соединение с БД перед запуском в фоне connection.close() # Запускаем загрузку в отдельном потоке import threading def download_in_background(): try: # Django пересоздаст соединение автоматически в новом потоке from django.db import connection as thread_connection from .models import Container as ContainerModel # Пере", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "download_in_background(): try: # Django пересоздаст соединение автоматически в новом потоке from django.db import connection as thread_connection from .models import Container as ContainerModel # Перезагружаем контейнер в новом потоке container_obj = ContainerModel.objects.get(id=container_id) if folder_url: # Используем указанную ссылку GoogleDriveSync.download_folder_photos(folder_url, container_obj) else: # Автопоиск по номеру контейнера в структуре Google Drive GoogleDriveSync.sync_container_by_number(container_number) thread_connection.close() except Exception as e: logger.error(f\"Background download error for {container_number}: {e}\", exc_info=True) thread = threading.Thread(target=download_in_background, daemon=True) thread.start() # Сразу возвращаем ответ message = 'Загрузка фотографий начата. ' if folder_url: message += 'Используется указанная ссылка на папку.' else: message += 'Ищем папку по номеру контейнера.' message += ' Обновите страницу через 1-2 минуты.' return JsonResponse({ 'success': True, 'message': message, 'photos_count': 0 }) except Container.DoesNotExist: return JsonResponse({'success': False, 'error': 'Контейнер не найден'}, status=404) except Exception as ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "onse({ 'success': True, 'message': message, 'photos_count': 0 }) except Container.DoesNotExist: return JsonResponse({'success': False, 'error': 'Контейнер не найден'}, status=404) except Exception as e: logger.error(f\"Error syncing Google Drive photos: {e}\", exc_info=True) return JsonResponse({'success': False, 'error': str(e)}, status=500) @staff_member_required @require_GET def search_counterparties(request): \"\"\" API для поиска контрагентов (клиенты, склады, линии, перевозчики, компании) Используется для автокомплита в форме инвойса \"\"\" query = request.GET.get('q', '').strip() if len(query) < 1: return JsonResponse({'results': []}) results = [] # Поиск по компаниям companies = Company.objects.filter(name__icontains=query)[:5] for obj in companies: results.append({ 'id': f'company_{obj.pk}', 'text': f'🏢 {obj.name}', 'type': 'company', 'type_id': obj.pk, }) # Поиск по клиентам clients = Client.objects.filter(name__icontains=query)[:5] for obj in clients: results.append({ 'id': f'client_{obj.pk}', 'text': f'👤 {obj.name}', 'type': 'client', 'type_id': obj.pk, }) # Поиск по складам warehouses = Warehouse.objects.filter(name__icontains=query)[:5] for obj in warehouses: results.append({", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "_{obj.pk}', 'text': f'👤 {obj.name}', 'type': 'client', 'type_id': obj.pk, }) # Поиск по складам warehouses = Warehouse.objects.filter(name__icontains=query)[:5] for obj in warehouses: results.append({ 'id': f'warehouse_{obj.pk}', 'text': f'🏭 {obj.name}', 'type': 'warehouse', 'type_id': obj.pk, }) # Поиск по линиям lines = Line.objects.filter(name__icontains=query)[:5] for obj in lines: results.append({ 'id': f'line_{obj.pk}', 'text': f'🚢 {obj.name}', 'type': 'line', 'type_id': obj.pk, }) # Поиск по перевозчикам carriers = Carrier.objects.filter(Q(name__icontains=query) | Q(contact_person__icontains=query))[:5] for obj in carriers: results.append({ 'id': f'carrier_{obj.pk}', 'text': f'🚚 {obj.name}', 'type': 'carrier', 'type_id': obj.pk, }) return JsonResponse({'results': results}) @staff_member_required @require_GET def search_cars(request): \"\"\" API для поиска автомобилей по VIN, марке Используется для автокомплита в форме инвойса \"\"\" query = request.GET.get('q', '').strip() selected = request.GET.getlist('selected', []) # Уже выбранные ID if len(query) < 2: return JsonResponse({'results': []}) # Исключаем уже выбранные cars = Car.objects.filter( Q(vin__icontains=query) | Q(brand__i", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "request.GET.getlist('selected', []) # Уже выбранные ID if len(query) < 2: return JsonResponse({'results': []}) # Исключаем уже выбранные cars = Car.objects.filter( Q(vin__icontains=query) | Q(brand__icontains=query) ).exclude(pk__in=selected).select_related('client')[:15] results = [] for car in cars: client_name = car.client.name if car.client else 'Без клиента' results.append({ 'id': car.pk, 'text': f'{car.brand} {car.year} ({car.vin})', 'vin': car.vin, 'brand': car.brand, 'year': car.year, 'client': client_name, }) return JsonResponse({'results': results}) @staff_member_required @require_GET def search_counterparties(request): \"\"\" API для поиска контрагентов (клиенты, склады, линии, перевозчики, компании) Используется для автокомплита в форме инвойса \"\"\" query = request.GET.get('q', '').strip() if len(query) < 1: return JsonResponse({'results': []}) results = [] # Поиск по компаниям companies = Company.objects.filter(name__icontains=query)[:5] for obj in companies: results.append({ 'id': f'company_{obj.pk}', 'text': f'🏢 {obj.name}', 'type': 'company', 'type_id': obj.pk, }) # Поиск по клиентам clients = Client.objects.filter(name__icontains=query)[:5] for obj in clients: results.", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "'id': f'company_{obj.pk}', 'text': f'🏢 {obj.name}', 'type': 'company', 'type_id': obj.pk, }) # Поиск по клиентам clients = Client.objects.filter(name__icontains=query)[:5] for obj in clients: results.append({ 'id': f'client_{obj.pk}', 'text': f'👤 {obj.name}', 'type': 'client', 'type_id': obj.pk, }) # Поиск по складам warehouses = Warehouse.objects.filter(name__icontains=query)[:5] for obj in warehouses: results.append({ 'id': f'warehouse_{obj.pk}', 'text': f'🏭 {obj.name}', 'type': 'warehouse', 'type_id': obj.pk, }) # Поиск по линиям lines = Line.objects.filter(name__icontains=query)[:5] for obj in lines: results.append({ 'id': f'line_{obj.pk}', 'text': f'🚢 {obj.name}', 'type': 'line', 'type_id': obj.pk, }) # Поиск по перевозчикам carriers = Carrier.objects.filter(Q(name__icontains=query) | Q(contact_person__icontains=query))[:5] for obj in carriers: results.append({ 'id': f'carrier_{obj.pk}', 'text': f'🚚 {obj.name}', 'type': 'carrier', 'type_id': obj.pk, }) return JsonResponse({'results': results}) @staff_member_required @require_GET def search_cars(request): \"\"\" API для поиска автомобилей по VIN, марке Используется для автокомплита в форме инвойса \"\"\" query = request.GET.get('q', ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\views.py", "content": "s': results}) @staff_member_required @require_GET def search_cars(request): \"\"\" API для поиска автомобилей по VIN, марке Используется для автокомплита в форме инвойса \"\"\" query = request.GET.get('q', '').strip() selected = request.GET.getlist('selected', []) # Уже выбранные ID if len(query) < 2: return JsonResponse({'results': []}) # Исключаем уже выбранные cars = Car.objects.filter( Q(vin__icontains=query) | Q(brand__icontains=query) ).exclude(pk__in=selected).select_related('client')[:15] results = [] for car in cars: client_name = car.client.name if car.client else 'Без клиента' results.append({ 'id': car.pk, 'text': f'{car.brand} {car.year} ({car.vin})', 'vin': car.vin, 'brand': car.brand, 'year': car.year, 'client': client_name, }) return JsonResponse({'results': results})", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "\"\"\" Новая упрощенная система инвойсов, платежей и балансов ========================================================= Основные принципы: - Простота и понятность - Прямые связи вместо generic - Один баланс вместо трех - Транзакционная безопасность - Полная история операций Авторы: AI Assistant Дата: 30 сентября 2025 \"\"\" from django.db import models from django.core.validators import MinValueValidator from django.utils import timezone from django.contrib.auth import get_user_model from decimal import Decimal import logging logger = logging.getLogger('django') User = get_user_model() # ============================================================================ # БАЗОВЫЙ МИКСИН ДЛЯ БАЛАНСОВ # ============================================================================ class SimpleBalanceMixin(models.Model): \"\"\" Простой миксин для балансов - ОДИН баланс вместо трех! Разделение по способам оплаты происходит через историю транзакций, а не через отдельные поля баланса. \"\"\" balance = models.DecimalField( max_digits=15, decimal_places=2, default=0, verbose_name=\"Баланс\", help_text=\"Текущий баланс (положительный = переплата, отрицательный = долг)\" ) balance_updated_at = models.DateTimeField( ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "imalField( max_digits=15, decimal_places=2, default=0, verbose_name=\"Баланс\", help_text=\"Текущий баланс (положительный = переплата, отрицательный = долг)\" ) balance_updated_at = models.DateTimeField( auto_now=True, verbose_name=\"Дата обновления баланса\" ) class Meta: abstract = True def get_balance_breakdown(self): \"\"\" Получить разбивку баланса по способам оплаты из истории транзакций Returns: dict: {'cash': Decimal, 'card': Decimal, 'transfer': Decimal, 'total': Decimal} \"\"\" from django.db.models import Sum, Q # Определяем тип сущности для фильтрации транзакций model_name = self.__class__.__name__.lower() # Фильтры для входящих и исходящих транзакций incoming_filter = Q(**{f'to_{model_name}': self}) outgoing_filter = Q(**{f'from_{model_name}': self}) # Получаем транзакции from .models_billing import Transaction transactions = Transaction.objects.filter(incoming_filter | outgoing_filter) # Разбивка по способам оплаты breakdown = {} for method in ['CASH', 'CARD', 'TRANSFER']: incoming = transactions.filter( incoming_filter, method=method ).aggregate(total=Sum('amount'))['total'] or Decimal('0.00') outgoing = transactions.filter( outgoing_filter, method=method ).aggregate(total=Sum('", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": " transactions.filter( incoming_filter, method=method ).aggregate(total=Sum('amount'))['total'] or Decimal('0.00') outgoing = transactions.filter( outgoing_filter, method=method ).aggregate(total=Sum('amount'))['total'] or Decimal('0.00') breakdown[method.lower()] = incoming - outgoing breakdown['total'] = self.balance return breakdown def get_balance_info(self): \"\"\" Получить информацию о балансе в понятном виде Returns: dict: Информация о балансе с статусом и цветом \"\"\" balance = self.balance if balance > 0: status = \"ПЕРЕПЛАТА\" color = \"#28a745\" # зеленый description = f\"Переплата {balance:.2f}\" elif balance < 0: status = \"ДОЛГ\" color = \"#dc3545\" # красный description = f\"Долг {abs(balance):.2f}\" else: status = \"БАЛАНС\" color = \"#6c757d\" # серый description = \"Баланс нулевой\" return { 'balance': balance, 'status': status, 'color': color, 'description': description, 'breakdown': self.get_balance_breakdown() } # ============================================================================ # НОВАЯ МОДЕЛЬ ИНВОЙСА # ============================================================================ class NewInvoice(models.Model): \"\"\" Упрощенная модель инвойса с прямыми связями Основные улучшен", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "= # НОВАЯ МОДЕЛЬ ИНВОЙСА # ============================================================================ class NewInvoice(models.Model): \"\"\" Упрощенная модель инвойса с прямыми связями Основные улучшения: - Прямые ForeignKey вместо generic связей - Понятные статусы - Автоматический расчет сумм - История изменений \"\"\" # Статусы инвойса STATUS_CHOICES = [ ('DRAFT', 'Черновик'), ('ISSUED', 'Выставлен'), ('PARTIALLY_PAID', 'Частично оплачен'), ('PAID', 'Оплачен'), ('OVERDUE', 'Просрочен'), ('CANCELLED', 'Отменен'), ] # ======================================================================== # ИДЕНТИФИКАЦИЯ # ======================================================================== number = models.CharField( max_length=50, unique=True, verbose_name=\"Номер инвойса\", help_text=\"Уникальный номер инвойса (генерируется автоматически)\" ) date = models.DateField( default=timezone.now, verbose_name=\"Дата выставления\" ) due_date = models.DateField( null=True, blank=True, verbose_name=\"Срок оплаты\", help_text=\"Дата, до которой должен быть оплачен инвойс (автоматически +14 дней)\" ) # ======================================================================== # КТО ВЫСТАВИЛ (может быть любая сущность!) ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "lp_text=\"Дата, до которой должен быть оплачен инвойс (автоматически +14 дней)\" ) # ======================================================================== # КТО ВЫСТАВИЛ (может быть любая сущность!) # ======================================================================== issuer_company = models.ForeignKey( 'Company', on_delete=models.PROTECT, null=True, blank=True, related_name='issued_invoices_new', verbose_name=\"Компания-выставитель\" ) issuer_warehouse = models.ForeignKey( 'Warehouse', on_delete=models.PROTECT, null=True, blank=True, related_name='issued_invoices_new', verbose_name=\"Склад-выставитель\" ) issuer_line = models.ForeignKey( 'Line', on_delete=models.PROTECT, null=True, blank=True, related_name='issued_invoices_new', verbose_name=\"Линия-выставитель\" ) issuer_carrier = models.ForeignKey( 'Carrier', on_delete=models.PROTECT, null=True, blank=True, related_name='issued_invoices_new', verbose_name=\"Перевозчик-выставитель\" ) # ======================================================================== # КОМУ ВЫСТАВЛЕН (прямые связи - ТОЛЬКО ОДНА заполнена!) # ======================================================================== recipient_client = models.ForeignKey( 'Clien", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "======================= # КОМУ ВЫСТАВЛЕН (прямые связи - ТОЛЬКО ОДНА заполнена!) # ======================================================================== recipient_client = models.ForeignKey( 'Client', on_delete=models.PROTECT, null=True, blank=True, related_name='received_invoices_new', verbose_name=\"Клиент-получатель\" ) recipient_warehouse = models.ForeignKey( 'Warehouse', on_delete=models.PROTECT, null=True, blank=True, related_name='received_invoices_new', verbose_name=\"Склад-получатель\" ) recipient_line = models.ForeignKey( 'Line', on_delete=models.PROTECT, null=True, blank=True, related_name='received_invoices_new', verbose_name=\"Линия-получатель\" ) recipient_carrier = models.ForeignKey( 'Carrier', on_delete=models.PROTECT, null=True, blank=True, related_name='received_invoices_new', verbose_name=\"Перевозчик-получатель\" ) recipient_company = models.ForeignKey( 'Company', on_delete=models.PROTECT, null=True, blank=True, related_name='received_invoices_new', verbose_name=\"Компания-получатель\" ) # ======================================================================== # ФИНАНСЫ # ======================================================================== subtotal = models.Decima", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "я-получатель\" ) # ======================================================================== # ФИНАНСЫ # ======================================================================== subtotal = models.DecimalField( max_digits=15, decimal_places=2, default=0, validators=[MinValueValidator(0)], verbose_name=\"Подытог\", help_text=\"Сумма всех позиций без дополнительных сборов\" ) discount = models.DecimalField( max_digits=15, decimal_places=2, default=0, validators=[MinValueValidator(0)], verbose_name=\"Скидка\" ) tax = models.DecimalField( max_digits=15, decimal_places=2, default=0, validators=[MinValueValidator(0)], verbose_name=\"Налог\" ) total = models.DecimalField( max_digits=15, decimal_places=2, default=0, validators=[MinValueValidator(0)], verbose_name=\"Итого к оплате\", help_text=\"Итоговая сумма инвойса\" ) paid_amount = models.DecimalField( max_digits=15, decimal_places=2, default=0, validators=[MinValueValidator(0)], verbose_name=\"Оплачено\", help_text=\"Сумма, которая уже оплачена\" ) # ======================================================================== # СТАТУС И МЕТАДАННЫЕ # ======================================================================== status = models.CharField( max_length", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "================================================================= # СТАТУС И МЕТАДАННЫЕ # ======================================================================== status = models.CharField( max_length=20, choices=STATUS_CHOICES, default='DRAFT', verbose_name=\"Статус\" ) notes = models.TextField( blank=True, verbose_name=\"Примечания\", help_text=\"Дополнительная информация об инвойсе\" ) # Связь с автомобилями для автоматического формирования позиций cars = models.ManyToManyField( 'Car', blank=True, related_name='invoices_new', verbose_name=\"Выбранные автомобили\", help_text=\"Выберите автомобили - позиции создадутся автоматически из их услуг\" ) # Аудит created_at = models.DateTimeField(auto_now_add=True, verbose_name=\"Дата создания\") updated_at = models.DateTimeField(auto_now=True, verbose_name=\"Дата обновления\") created_by = models.ForeignKey( User, on_delete=models.SET_NULL, null=True, related_name='created_invoices_new', verbose_name=\"Создал\" ) # Служебное поле для отслеживания обновления баланса _balance_updated = models.BooleanField(default=False, editable=False) class Meta: verbose_name = \"Инвойс\" verbose_name_plural = \"Инвойсы\" ordering = ['-date', '-created_at'] indexes = [ model", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": " баланса _balance_updated = models.BooleanField(default=False, editable=False) class Meta: verbose_name = \"Инвойс\" verbose_name_plural = \"Инвойсы\" ordering = ['-date', '-created_at'] indexes = [ models.Index(fields=['number']), models.Index(fields=['status', 'date']), models.Index(fields=['due_date', 'status']), models.Index(fields=['recipient_client', 'status']), models.Index(fields=['recipient_warehouse', 'status']), models.Index(fields=['recipient_line', 'status']), models.Index(fields=['recipient_carrier', 'status']), models.Index(fields=['recipient_company', 'status']), models.Index(fields=['issuer_company', 'status']), models.Index(fields=['issuer_warehouse', 'status']), models.Index(fields=['issuer_line', 'status']), models.Index(fields=['issuer_carrier', 'status']), ] def __str__(self): return f\"Инвойс {self.number} ({self.get_status_display()})\" # ======================================================================== # СВОЙСТВА # ======================================================================== @property def issuer(self): \"\"\"Получить выставителя инвойса\"\"\" if self.issuer_company: return self.issuer_company elif self.issuer_warehouse: return self.issuer_warehouse e", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "=========================== @property def issuer(self): \"\"\"Получить выставителя инвойса\"\"\" if self.issuer_company: return self.issuer_company elif self.issuer_warehouse: return self.issuer_warehouse elif self.issuer_line: return self.issuer_line elif self.issuer_carrier: return self.issuer_carrier return None @property def issuer_name(self): \"\"\"Получить имя выставителя\"\"\" issuer = self.issuer return str(issuer) if issuer else \"Не указан\" @property def recipient(self): \"\"\"Получить получателя инвойса\"\"\" if self.recipient_client: return self.recipient_client elif self.recipient_warehouse: return self.recipient_warehouse elif self.recipient_line: return self.recipient_line elif self.recipient_carrier: return self.recipient_carrier elif self.recipient_company: return self.recipient_company return None @property def recipient_name(self): \"\"\"Получить имя получателя\"\"\" recipient = self.recipient return str(recipient) if recipient else \"Не указан\" @property def remaining_amount(self): \"\"\"Остаток к оплате\"\"\" return max(Decimal('0.00'), self.total - self.paid_amount) @property def is_overdue(self): \"\"\"Просрочен ли инвойс\"\"\" if self.status in ['PAID', 'CANCELLED']: return False if not self.due", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "к к оплате\"\"\" return max(Decimal('0.00'), self.total - self.paid_amount) @property def is_overdue(self): \"\"\"Просрочен ли инвойс\"\"\" if self.status in ['PAID', 'CANCELLED']: return False if not self.due_date: return False return self.due_date < timezone.now().date() @property def days_until_due(self): \"\"\"Количество дней до срока оплаты\"\"\" if not self.due_date: return 0 delta = self.due_date - timezone.now().date() return delta.days # ======================================================================== # МЕТОДЫ # ======================================================================== def calculate_totals(self): \"\"\"Пересчитать итоговые суммы на основе позиций\"\"\" items = self.items.all() self.subtotal = sum(item.total_price for item in items) self.total = self.subtotal - self.discount + self.tax return self.total def update_status(self): \"\"\"Обновить статус на основе оплаты\"\"\" # Не меняем статус если total = 0 (инвойс без позиций) if self.total > 0 and self.paid_amount >= self.total: self.status = 'PAID' elif self.paid_amount > 0 and self.total > 0: self.status = 'PARTIALLY_PAID' elif self.is_overdue: self.status = 'OVERDUE' elif self.status == 'DRAFT': pass # Остается черновиком el", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "lf.status = 'PAID' elif self.paid_amount > 0 and self.total > 0: self.status = 'PARTIALLY_PAID' elif self.is_overdue: self.status = 'OVERDUE' elif self.status == 'DRAFT': pass # Остается черновиком elif self.status == 'PAID' and self.total == 0: # Если был PAID но теперь total=0, сбрасываем на ISSUED self.status = 'ISSUED' # Если уже установлен валидный статус - не меняем def generate_number(self): \"\"\"Сгенерировать уникальный номер инвойса\"\"\" from django.utils.timezone import now date = now() prefix = f\"INV-{date.year}{date.month:02d}\" # Находим последний номер за текущий месяц last_invoice = NewInvoice.objects.filter( number__startswith=prefix ).order_by('-number').first() if last_invoice: # Извлекаем номер и увеличиваем try: last_num = int(last_invoice.number.split('-')[-1]) next_num = last_num + 1 except (ValueError, IndexError): next_num = 1 else: next_num = 1 return f\"{prefix}-{next_num:04d}\" def regenerate_items_from_cars(self): \"\"\" Автоматически создает позиции инвойса из услуг выбранных автомобилей \"\"\" # Удаляем старые позиции self.items.all().delete() issuer = self.issuer if not issuer: import logging logger = logging.getLogger(__name__) logger.warning(f\"⚠️ Инвойс {self.nu", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "выбранных автомобилей \"\"\" # Удаляем старые позиции self.items.all().delete() issuer = self.issuer if not issuer: import logging logger = logging.getLogger(__name__) logger.warning(f\"⚠️ Инвойс {self.number}: выставитель не указан, позиции не будут созданы\") return issuer_type = issuer.__class__.__name__ import logging logger = logging.getLogger(__name__) logger.info(f\"📋 Генерация позиций для инвойса {self.number}, выставитель: {issuer} (тип: {issuer_type})\") order = 0 for car in self.cars.all(): # ВАЖНО! Пересчитываем хранение и стоимость перед генерацией позиций # НО НЕ СОХРАНЯЕМ - чтобы не вызвать рекурсивный сигнал # Данные автомобиля должны быть актуальными на момент вызова regenerate car.update_days_and_storage() car.calculate_total_price() # Определяем какие услуги брать в зависимости от типа выставителя if issuer_type == 'Warehouse': services = car.get_warehouse_services() prefix = 'Склад' # ВАЖНО! Добавляем хранение как отдельную позицию if car.storage_cost and car.storage_cost > 0: InvoiceItem.objects.create( invoice=self, description=f\"Хранение - {car.brand} {car.vin} ({car.days} дн.)\", car=car, quantity=car.days, unit_price=car._get_storage_daily_rate() if car.warehouse e", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "> 0: InvoiceItem.objects.create( invoice=self, description=f\"Хранение - {car.brand} {car.vin} ({car.days} дн.)\", car=car, quantity=car.days, unit_price=car._get_storage_daily_rate() if car.warehouse else Decimal('0'), order=order ) order += 1 elif issuer_type == 'Line': services = car.get_line_services() prefix = 'Линия' elif issuer_type == 'Carrier': services = car.get_carrier_services() prefix = 'Перевозчик' elif issuer_type == 'Company': # Компания выставляет клиенту - все услуги + хранение + наценка services = car.car_services.all() prefix = 'Все услуги' # Определяем статус для описания status_note = \"\" if car.status == 'TRANSFERRED' and car.transfer_date: status_note = f\" [Передан {car.transfer_date}]\" else: from django.utils import timezone status_note = f\" [Текущее хранение на {timezone.now().date()}]\" # Добавляем хранение для клиентских инвойсов if car.storage_cost and car.storage_cost > 0: InvoiceItem.objects.create( invoice=self, description=f\"Хранение - {car.brand} {car.vin} ({car.days} дн.){status_note}\", car=car, quantity=car.days, unit_price=car._get_storage_daily_rate() if car.warehouse else Decimal('0'), order=order ) order += 1 # Наценка НЕ показывается отдельной с", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": " ({car.days} дн.){status_note}\", car=car, quantity=car.days, unit_price=car._get_storage_daily_rate() if car.warehouse else Decimal('0'), order=order ) order += 1 # Наценка НЕ показывается отдельной строкой в инвойсе! # Она скрыто добавляется к ценам услуг через markup_amount в CarService # Это прибыль Caromoto Lithuania, которая не видна клиенту else: continue # Создаем позиции из услуг for service in services: service_name = service.get_service_name() # ЗАЩИТА: Пропускаем услуги, которые не найдены в справочнике # Это может произойти если услуга была удалена, а CarService остался if service_name == \"Услуга не найдена\": logger.warning(f\"⚠️ Пропущена битая услуга: type={service.service_type}, id={service.service_id} для авто {car.vin}\") continue # ЗАЩИТА: Для Company пропускаем услугу \"Хранение\" - она уже добавлена выше вручную # Это предотвращает дублирование стоимости хранения в инвойсе if issuer_type == 'Company' and service_name == 'Хранение': logger.debug(f\"⏭️ Пропускаем услугу 'Хранение' для {car.vin} - уже добавлена вручную\") continue # Для Company используем invoice_price (включает скрытую наценку) # Для остальных - обычную цену if issuer_type == 'Company': # invoice_price ", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "ранение' для {car.vin} - уже добавлена вручную\") continue # Для Company используем invoice_price (включает скрытую наценку) # Для остальных - обычную цену if issuer_type == 'Company': # invoice_price уже включает markup_amount и учитывает quantity unit_price = (service.custom_price if service.custom_price else service.get_default_price()) + (service.markup_amount or Decimal('0')) else: unit_price = service.custom_price if service.custom_price else service.get_default_price() InvoiceItem.objects.create( invoice=self, description=f\"{prefix}: {service_name} - {car.brand} {car.vin}\", car=car, quantity=service.quantity, unit_price=unit_price, order=order ) order += 1 # Пересчитываем итоги self.calculate_totals() self.save(update_fields=['subtotal', 'total']) def save(self, *args, **kwargs): \"\"\"Переопределяем save для автоматической генерации номера и обновления статуса\"\"\" # Генерируем номер для новых инвойсов if not self.number: self.number = self.generate_number() # Устанавливаем срок оплаты, если не указан if not self.due_date: self.due_date = timezone.now().date() + timezone.timedelta(days=14) # Обновляем статус self.update_status() super().save(*args, **kwargs) # ===================", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "ты, если не указан if not self.due_date: self.due_date = timezone.now().date() + timezone.timedelta(days=14) # Обновляем статус self.update_status() super().save(*args, **kwargs) # ============================================================================ # ПОЗИЦИЯ В ИНВОЙСЕ # ============================================================================ class InvoiceItem(models.Model): \"\"\" Позиция (строка) в инвойсе Может быть связана с автомобилем или быть произвольной услугой \"\"\" # Связь с инвойсом invoice = models.ForeignKey( NewInvoice, on_delete=models.CASCADE, related_name='items', verbose_name=\"Инвойс\" ) # Связь с автомобилем (опционально) car = models.ForeignKey( 'Car', on_delete=models.SET_NULL, null=True, blank=True, related_name='invoice_items_new', verbose_name=\"Автомобиль\" ) # Описание услуги/товара description = models.CharField( max_length=500, verbose_name=\"Описание\", help_text=\"Например: 'Хранение авто VIN12345 (10 дней)'\" ) # Количество и цена quantity = models.DecimalField( max_digits=10, decimal_places=2, default=1, validators=[MinValueValidator(0)], verbose_name=\"Количество\" ) unit_price = models.DecimalField( max_digits=15, decimal_places=2, validators=[MinVa", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "alField( max_digits=10, decimal_places=2, default=1, validators=[MinValueValidator(0)], verbose_name=\"Количество\" ) unit_price = models.DecimalField( max_digits=15, decimal_places=2, validators=[MinValueValidator(0)], verbose_name=\"Цена за единицу\" ) total_price = models.DecimalField( max_digits=15, decimal_places=2, validators=[MinValueValidator(0)], verbose_name=\"Сумма\", help_text=\"Автоматически рассчитывается: количество × цена\" ) # Порядок отображения order = models.PositiveIntegerField( default=0, verbose_name=\"Порядок\" ) class Meta: verbose_name = \"Позиция инвойса\" verbose_name_plural = \"Позиции инвойса\" ordering = ['order', 'id'] indexes = [ models.Index(fields=['invoice', 'order']), models.Index(fields=['car']), ] def __str__(self): return f\"{self.description} - {self.total_price}\" def calculate_total(self): \"\"\"Рассчитать итоговую сумму позиции\"\"\" self.total_price = self.quantity * self.unit_price return self.total_price def save(self, *args, **kwargs): \"\"\"Переопределяем save для автоматического расчета суммы\"\"\" self.calculate_total() super().save(*args, **kwargs) # Обновляем итоги инвойса if self.invoice_id: self.invoice.calculate_totals() self.invoice.save(update_fields=[", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "ля автоматического расчета суммы\"\"\" self.calculate_total() super().save(*args, **kwargs) # Обновляем итоги инвойса if self.invoice_id: self.invoice.calculate_totals() self.invoice.save(update_fields=['subtotal', 'total', 'updated_at']) # ============================================================================ # ТРАНЗАКЦИЯ (ПЛАТЕЖ/ВОЗВРАТ/ПЕРЕВОД) # ============================================================================ class Transaction(models.Model): \"\"\" Универсальная модель для всех финансовых операций Заменяет старую модель Payment и включает все типы операций: - Платежи по инвойсам - Пополнение баланса - Возвраты - Переводы между сущностями - Корректировки \"\"\" # Типы транзакций TYPE_CHOICES = [ ('PAYMENT', 'Платеж'), ('REFUND', 'Возврат'), ('ADJUSTMENT', 'Корректировка'), ('TRANSFER', 'Перевод'), ('BALANCE_TOPUP', 'Пополнение баланса'), ] # Способы оплаты METHOD_CHOICES = [ ('CASH', 'Наличные'), ('CARD', 'Банковская карта'), ('TRANSFER', 'Банковский перевод'), ('BALANCE', 'Списание с баланса'), ('OTHER', 'Другое'), ] # Статусы транзакции STATUS_CHOICES = [ ('PENDING', 'В ожидании'), ('COMPLETED', 'Завершена'), ('FAILED', 'Ошибка'), ('CANCELLED', 'Отменена'), ] # ======", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "'Списание с баланса'), ('OTHER', 'Другое'), ] # Статусы транзакции STATUS_CHOICES = [ ('PENDING', 'В ожидании'), ('COMPLETED', 'Завершена'), ('FAILED', 'Ошибка'), ('CANCELLED', 'Отменена'), ] # ======================================================================== # ИДЕНТИФИКАЦИЯ # ======================================================================== number = models.CharField( max_length=50, unique=True, verbose_name=\"Номер транзакции\" ) date = models.DateTimeField( default=timezone.now, verbose_name=\"Дата и время\" ) # ======================================================================== # ТИП И СПОСОБ # ======================================================================== type = models.CharField( max_length=20, choices=TYPE_CHOICES, verbose_name=\"Тип операции\" ) method = models.CharField( max_length=20, choices=METHOD_CHOICES, verbose_name=\"Способ оплаты\" ) status = models.CharField( max_length=20, choices=STATUS_CHOICES, default='COMPLETED', verbose_name=\"Статус\" ) # ======================================================================== # ОТКУДА (отправитель) - ТОЛЬКО ОДНО поле заполнено! # ======================================================================== from", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "=================================================================== # ОТКУДА (отправитель) - ТОЛЬКО ОДНО поле заполнено! # ======================================================================== from_client = models.ForeignKey( 'Client', on_delete=models.PROTECT, null=True, blank=True, related_name='transactions_sent_new', verbose_name=\"От клиента\" ) from_warehouse = models.ForeignKey( 'Warehouse', on_delete=models.PROTECT, null=True, blank=True, related_name='transactions_sent_new', verbose_name=\"От склада\" ) from_line = models.ForeignKey( 'Line', on_delete=models.PROTECT, null=True, blank=True, related_name='transactions_sent_new', verbose_name=\"От линии\" ) from_carrier = models.ForeignKey( 'Carrier', on_delete=models.PROTECT, null=True, blank=True, related_name='transactions_sent_new', verbose_name=\"От перевозчика\" ) from_company = models.ForeignKey( 'Company', on_delete=models.PROTECT, null=True, blank=True, related_name='transactions_sent_new', verbose_name=\"От компании\" ) # ======================================================================== # КУДА (получатель) - ТОЛЬКО ОДНО поле заполнено! # ======================================================================== to_cli", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "==================================================================== # КУДА (получатель) - ТОЛЬКО ОДНО поле заполнено! # ======================================================================== to_client = models.ForeignKey( 'Client', on_delete=models.PROTECT, null=True, blank=True, related_name='transactions_received_new', verbose_name=\"Клиенту\" ) to_warehouse = models.ForeignKey( 'Warehouse', on_delete=models.PROTECT, null=True, blank=True, related_name='transactions_received_new', verbose_name=\"Складу\" ) to_line = models.ForeignKey( 'Line', on_delete=models.PROTECT, null=True, blank=True, related_name='transactions_received_new', verbose_name=\"Линии\" ) to_carrier = models.ForeignKey( 'Carrier', on_delete=models.PROTECT, null=True, blank=True, related_name='transactions_received_new', verbose_name=\"Перевозчику\" ) to_company = models.ForeignKey( 'Company', on_delete=models.PROTECT, null=True, blank=True, related_name='transactions_received_new', verbose_name=\"Компании\" ) # ======================================================================== # СВЯЗЬ С ИНВОЙСОМ # ======================================================================== invoice = models.ForeignKey( NewInvoice, on_", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "============================================================= # СВЯЗЬ С ИНВОЙСОМ # ======================================================================== invoice = models.ForeignKey( NewInvoice, on_delete=models.SET_NULL, null=True, blank=True, related_name='transactions', verbose_name=\"Инвойс\", help_text=\"Если это оплата инвойса, указываем его здесь\" ) # ======================================================================== # СУММА И ОПИСАНИЕ # ======================================================================== amount = models.DecimalField( max_digits=15, decimal_places=2, validators=[MinValueValidator(0)], verbose_name=\"Сумма\" ) description = models.TextField( verbose_name=\"Описание\", help_text=\"Подробное описание операции\" ) # ======================================================================== # МЕТАДАННЫЕ # ======================================================================== created_at = models.DateTimeField(auto_now_add=True, verbose_name=\"Создана\") created_by = models.ForeignKey( User, on_delete=models.SET_NULL, null=True, related_name='created_transactions_new', verbose_name=\"Создал\" ) class Meta: verbose_name = \"Транзакция\" verbose_name_plural = \"Транзакци", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "models.ForeignKey( User, on_delete=models.SET_NULL, null=True, related_name='created_transactions_new', verbose_name=\"Создал\" ) class Meta: verbose_name = \"Транзакция\" verbose_name_plural = \"Транзакции\" ordering = ['-date'] indexes = [ models.Index(fields=['number']), models.Index(fields=['date', 'type']), models.Index(fields=['invoice']), models.Index(fields=['from_client', 'date']), models.Index(fields=['to_client', 'date']), models.Index(fields=['from_warehouse', 'date']), models.Index(fields=['to_warehouse', 'date']), models.Index(fields=['from_line', 'date']), models.Index(fields=['to_line', 'date']), models.Index(fields=['from_carrier', 'date']), models.Index(fields=['to_carrier', 'date']), models.Index(fields=['from_company', 'date']), models.Index(fields=['to_company', 'date']), models.Index(fields=['status', 'date']), ] def __str__(self): return f\"{self.number}: {self.get_type_display()} {self.amount}\" # ======================================================================== # СВОЙСТВА # ======================================================================== @property def sender(self): \"\"\"Получить отправителя\"\"\" if self.from_client: return self.from_client elif self.from", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "# СВОЙСТВА # ======================================================================== @property def sender(self): \"\"\"Получить отправителя\"\"\" if self.from_client: return self.from_client elif self.from_warehouse: return self.from_warehouse elif self.from_line: return self.from_line elif self.from_carrier: return self.from_carrier elif self.from_company: return self.from_company return None @property def recipient(self): \"\"\"Получить получателя\"\"\" if self.to_client: return self.to_client elif self.to_warehouse: return self.to_warehouse elif self.to_line: return self.to_line elif self.to_carrier: return self.to_carrier elif self.to_company: return self.to_company return None @property def sender_name(self): \"\"\"Имя отправителя\"\"\" sender = self.sender return str(sender) if sender else \"Не указан\" @property def recipient_name(self): \"\"\"Имя получателя\"\"\" recipient = self.recipient return str(recipient) if recipient else \"Не указан\" # ======================================================================== # МЕТОДЫ # ======================================================================== def generate_number(self): \"\"\"Сгенерировать уникальный номер транзакции\"\"\" from django.utils.timezone i", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\models_billing.py", "content": "============ # МЕТОДЫ # ======================================================================== def generate_number(self): \"\"\"Сгенерировать уникальный номер транзакции\"\"\" from django.utils.timezone import now date = now() prefix = f\"TRX-{date.year}{date.month:02d}{date.day:02d}\" # Находим последнюю транзакцию за текущий день last_transaction = Transaction.objects.filter( number__startswith=prefix ).order_by('-number').first() if last_transaction: try: last_num = int(last_transaction.number.split('-')[-1]) next_num = last_num + 1 except (ValueError, IndexError): next_num = 1 else: next_num = 1 return f\"{prefix}-{next_num:05d}\" def save(self, *args, **kwargs): \"\"\"Переопределяем save для автоматической генерации номера\"\"\" if not self.number: self.number = self.generate_number() super().save(*args, **kwargs) \"\"\"Переопределяем save для автоматической генерации номера\"\"\" if not self.number: self.number = self.generate_number() super().save(*args, **kwargs)", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\services\\ai_chat_service.py", "content": "import logging import re from typing import List, Optional import requests from django.conf import settings from core.models import Car, Container from core.models_website import AIChat, CarPhoto, ContainerPhoto logger = logging.getLogger(__name__) class AIServiceError(Exception): pass def _get_recent_messages(session_id: Optional[str], user) -> List[dict]: if not session_id: return [] chats = AIChat.objects.filter(session_id=session_id) if user: chats = chats.filter(user=user) chats = chats.order_by(\"-created_at\")[:6] messages = [] for chat in reversed(list(chats)): messages.append({\"role\": \"user\", \"content\": chat.message}) messages.append({\"role\": \"assistant\", \"content\": chat.response}) return messages def _build_company_context() -> str: return ( \"Вы — ИИ-помощник логистической компании Caromoto Lithuania. \" \"Компания специализируется на доставке автомобилей из США, \" \"контейнерных перевозках, таможенном оформлении и складском хранении. \" \"Отвечайте вежливо, профессионально и по существу. \" \"Не отвечайте на финансовые вопросы, цены, платежи, балансы, инвойсы или стоимость услуг. \" \"Если спрашивают про финансы — вежливо направьте к менеджеру. \" \"Если вопрос требует персональных д", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\services\\ai_chat_service.py", "content": "еству. \" \"Не отвечайте на финансовые вопросы, цены, платежи, балансы, инвойсы или стоимость услуг. \" \"Если спрашивают про финансы — вежливо направьте к менеджеру. \" \"Если вопрос требует персональных данных, отвечайте только на основе контекста. \" \"Если данных недостаточно — уточните у клиента VIN или номер контейнера.\" ) def _build_client_context(client) -> str: if not client: return \"\" cars = ( Car.objects.filter(client=client) .select_related(\"container\", \"warehouse\") .order_by(\"-id\")[:5] ) containers = ( Container.objects.filter(client=client) .select_related(\"line\", \"warehouse\") .order_by(\"-id\")[:5] ) cars_info = [] for car in cars: cars_info.append( f\"VIN: {car.vin}, статус: {car.get_status_display()}, \" f\"контейнер: {car.container.number if car.container else '—'}\" ) containers_info = [] for container in containers: containers_info.append( f\"Контейнер: {container.number}, статус: {container.get_status_display()}, \" f\"ETA: {container.eta or '—'}, выгрузка: {container.unload_date or '—'}\" ) return ( f\"Информация о клиенте: {client.name}. \" f\"Последние автомобили: {', '.join(cars_info) if cars_info else 'нет данных'}. \" f\"Последние контейнеры: {', '.join(containers_info) if cont", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\services\\ai_chat_service.py", "content": "r '—'}\" ) return ( f\"Информация о клиенте: {client.name}. \" f\"Последние автомобили: {', '.join(cars_info) if cars_info else 'нет данных'}. \" f\"Последние контейнеры: {', '.join(containers_info) if containers_info else 'нет данных'}.\" ) def _build_system_prompt(language_code: str) -> str: language_map = { \"ru\": \"Русский\", \"en\": \"English\", \"lt\": \"Lietuvių\", } language_name = language_map.get(language_code, \"Русский\") return ( \"Отвечай кратко и по делу. \" \"Не придумывай данные, которых нет в контексте. \" f\"Язык ответа: {language_name}.\" ) def _find_identifiers(message: str) -> dict: vin_pattern = re.compile(r\"\\b[A-HJ-NPR-Z0-9]{17}\\b\", re.IGNORECASE) container_pattern = re.compile(r\"\\b[A-Z]{4}\\d{7}\\b\", re.IGNORECASE) vins = list({m.group(0).upper() for m in vin_pattern.finditer(message or \"\")}) containers = list({m.group(0).upper() for m in container_pattern.finditer(message or \"\")}) return {\"vins\": vins, \"containers\": containers} def _build_tracking_context(message: str, user=None, client=None) -> str: identifiers = _find_identifiers(message) vins = identifiers[\"vins\"] containers = identifiers[\"containers\"] if not vins and not containers: return \"\" is_staff = bool(user and (getattr(use", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\services\\ai_chat_service.py", "content": "None) -> str: identifiers = _find_identifiers(message) vins = identifiers[\"vins\"] containers = identifiers[\"containers\"] if not vins and not containers: return \"\" is_staff = bool(user and (getattr(user, \"is_staff\", False) or getattr(user, \"is_superuser\", False))) parts = [] for vin in vins: car_qs = Car.objects.select_related(\"container\", \"warehouse\").filter(vin__iexact=vin) if client: car_qs = car_qs.filter(client=client) car = car_qs.first() if not car: parts.append(f\"По VIN {vin} автомобиль не найден.\") continue unload_date = car.unload_date or (car.container.unload_date if car.container else None) transfer_date = car.transfer_date events = [] if unload_date: events.append(f\"Разгружен: {unload_date}\") if transfer_date: events.append(f\"Передан: {transfer_date}\") history_text = \"; \".join(events) if events else \"История статусов: нет дат.\" photos_qs = CarPhoto.objects.filter(car=car) if not is_staff: photos_qs = photos_qs.filter(is_public=True) photos_count = photos_qs.count() last_photo = photos_qs.order_by(\"-uploaded_at\").first() if last_photo: photos_text = ( f\"Фото авто: {photos_count} шт., последняя загрузка: \" f\"{last_photo.uploaded_at.strftime('%Y-%m-%d %H:%M')}\" ) else: con", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\services\\ai_chat_service.py", "content": "to = photos_qs.order_by(\"-uploaded_at\").first() if last_photo: photos_text = ( f\"Фото авто: {photos_count} шт., последняя загрузка: \" f\"{last_photo.uploaded_at.strftime('%Y-%m-%d %H:%M')}\" ) else: container_photos_text = \"\" if car.container: container_photos = ContainerPhoto.objects.filter(container=car.container) if not is_staff: container_photos = container_photos.filter(is_public=True) container_count = container_photos.count() last_container_photo = container_photos.order_by(\"-uploaded_at\").first() if container_count: if last_container_photo: container_photos_text = ( f\"Фото контейнера: {container_count} шт., последняя загрузка: \" f\"{last_container_photo.uploaded_at.strftime('%Y-%m-%d %H:%M')}\" ) else: container_photos_text = f\"Фото контейнера: {container_count} шт.\" photos_text = \"Фото авто: 0 шт.\" + (f\" {container_photos_text}\" if container_photos_text else \"\") parts.append( \"Статус автомобиля по VIN {vin}: {status}. Контейнер: {container}. \" \"ETA: {eta}. Дата выгрузки: {unload}. Склад: {warehouse}. {history} {photos}\".format( vin=vin, status=car.get_status_display(), container=car.container.number if car.container else \"—\", eta=car.container.eta if car.container and car.cont", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\services\\ai_chat_service.py", "content": " Склад: {warehouse}. {history} {photos}\".format( vin=vin, status=car.get_status_display(), container=car.container.number if car.container else \"—\", eta=car.container.eta if car.container and car.container.eta else \"—\", unload=unload_date or \"—\", warehouse=car.warehouse.name if car.warehouse else \"—\", history=history_text, photos=photos_text, ) ) for number in containers: container_qs = Container.objects.select_related(\"warehouse\").filter(number__iexact=number) if client: container_qs = container_qs.filter(client=client) container = container_qs.first() if not container: parts.append(f\"Контейнер {number} не найден.\") continue events = [] if container.planned_unload_date: events.append(f\"План разгрузки: {container.planned_unload_date}\") if container.unload_date: events.append(f\"Разгружен: {container.unload_date}\") if container.unloaded_status_at: events.append(f\"Статус 'Разгружен' с: {container.unloaded_status_at}\") transfer_date = None if container.status == \"TRANSFERRED\": transfer_date = ( Car.objects.filter(container=container, transfer_date__isnull=False) .order_by(\"-transfer_date\") .values_list(\"transfer_date\", flat=True) .first() ) if transfer_date: events.append(f\"Передан: {t", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\services\\ai_chat_service.py", "content": "e = ( Car.objects.filter(container=container, transfer_date__isnull=False) .order_by(\"-transfer_date\") .values_list(\"transfer_date\", flat=True) .first() ) if transfer_date: events.append(f\"Передан: {transfer_date}\") else: events.append(\"Передан: дата не указана\") history_text = \"; \".join(events) if events else \"История статусов: нет дат.\" photos_qs = ContainerPhoto.objects.filter(container=container) if not is_staff: photos_qs = photos_qs.filter(is_public=True) photos_count = photos_qs.count() last_photo = photos_qs.order_by(\"-uploaded_at\").first() photos_text = ( f\"Фото: {photos_count} шт., последняя загрузка: {last_photo.uploaded_at.strftime('%Y-%m-%d %H:%M')}\" if last_photo else f\"Фото: {photos_count} шт.\" ) parts.append( \"Статус контейнера {number}: {status}. ETA: {eta}. Дата выгрузки: {unload}. \" \"Склад: {warehouse}. {history} {photos}\".format( number=number, status=container.get_status_display(), eta=container.eta or \"—\", unload=container.unload_date or \"—\", warehouse=container.warehouse.name if container.warehouse else \"—\", history=history_text, photos=photos_text, ) ) return \" \".join(parts) def _call_ai_api(messages: List[dict]) -> str: if not settings.AI_CHAT_ENABLED: rais", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\services\\ai_chat_service.py", "content": "arehouse.name if container.warehouse else \"—\", history=history_text, photos=photos_text, ) ) return \" \".join(parts) def _call_ai_api(messages: List[dict]) -> str: if not settings.AI_CHAT_ENABLED: raise AIServiceError(\"AI chat is disabled\") api_key = settings.AI_API_KEY if not api_key: raise AIServiceError(\"AI API key is missing\") base_url = settings.AI_API_BASE_URL.rstrip(\"/\") url = f\"{base_url}/chat/completions\" payload = { \"model\": settings.AI_MODEL, \"messages\": messages, \"temperature\": settings.AI_TEMPERATURE, \"max_tokens\": settings.AI_MAX_TOKENS, } try: response = requests.post( url, headers={ \"Authorization\": f\"Bearer {api_key}\", \"Content-Type\": \"application/json\", }, json=payload, timeout=settings.AI_REQUEST_TIMEOUT, ) except requests.RequestException as exc: logger.exception(\"AI API request failed\") raise AIServiceError(\"AI API request failed\") from exc if not response.ok: error_text = response.text[:1000] if response.text else \"\" logger.error(\"AI API error: %s - %s\", response.status_code, error_text) raise AIServiceError(f\"AI API returned error ({response.status_code})\") data = response.json() try: return data[\"choices\"][0][\"message\"][\"content\"].strip() except (KeyError, In", "embedding": null}, {"source_path": "C:\\Users\\art-f\\PycharmProjects\\logist2\\core\\services\\ai_chat_service.py", "content": "tatus_code, error_text) raise AIServiceError(f\"AI API returned error ({response.status_code})\") data = response.json() try: return data[\"choices\"][0][\"message\"][\"content\"].strip() except (KeyError, IndexError, TypeError) as exc: logger.error(\"AI API response parsing error: %s\", data) raise AIServiceError(\"AI API response parsing error\") from exc def generate_ai_response(message: str, user=None, client=None, session_id: Optional[str] = None, language_code: str = \"ru\") -> str: system_prompt = _build_system_prompt(language_code) company_context = _build_company_context() client_context = _build_client_context(client) tracking_context = _build_tracking_context(message, user=user, client=client) history_messages = _get_recent_messages(session_id, user) messages = [ {\"role\": \"system\", \"content\": system_prompt}, {\"role\": \"system\", \"content\": company_context}, ] if client_context: messages.append({\"role\": \"system\", \"content\": client_context}) if tracking_context: messages.append({\"role\": \"system\", \"content\": tracking_context}) messages.extend(history_messages) messages.append({\"role\": \"user\", \"content\": message}) return _call_ai_api(messages)", "embedding": null}]}